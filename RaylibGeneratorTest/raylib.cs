// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace Raylib
{
    [Flags]
    public enum ConfigFlag
    {
        FLAG_RESERVED = 1,
        FLAG_FULLSCREEN_MODE = 2,
        FLAG_WINDOW_RESIZABLE = 4,
        FLAG_WINDOW_UNDECORATED = 8,
        FLAG_WINDOW_TRANSPARENT = 16,
        FLAG_WINDOW_HIDDEN = 128,
        FLAG_WINDOW_ALWAYS_RUN = 256,
        FLAG_MSAA_4X_HINT = 32,
        FLAG_VSYNC_HINT = 64
    }

    public enum TraceLogType
    {
        LOG_ALL = 0,
        LOG_TRACE = 1,
        LOG_DEBUG = 2,
        LOG_INFO = 3,
        LOG_WARNING = 4,
        LOG_ERROR = 5,
        LOG_FATAL = 6,
        LOG_NONE = 7
    }

    public enum KeyboardKey
    {
        KEY_APOSTROPHE = 39,
        KEY_COMMA = 44,
        KEY_MINUS = 45,
        KEY_PERIOD = 46,
        KEY_SLASH = 47,
        KEY_ZERO = 48,
        KEY_ONE = 49,
        KEY_TWO = 50,
        KEY_THREE = 51,
        KEY_FOUR = 52,
        KEY_FIVE = 53,
        KEY_SIX = 54,
        KEY_SEVEN = 55,
        KEY_EIGHT = 56,
        KEY_NINE = 57,
        KEY_SEMICOLON = 59,
        KEY_EQUAL = 61,
        KEY_A = 65,
        KEY_B = 66,
        KEY_C = 67,
        KEY_D = 68,
        KEY_E = 69,
        KEY_F = 70,
        KEY_G = 71,
        KEY_H = 72,
        KEY_I = 73,
        KEY_J = 74,
        KEY_K = 75,
        KEY_L = 76,
        KEY_M = 77,
        KEY_N = 78,
        KEY_O = 79,
        KEY_P = 80,
        KEY_Q = 81,
        KEY_R = 82,
        KEY_S = 83,
        KEY_T = 84,
        KEY_U = 85,
        KEY_V = 86,
        KEY_W = 87,
        KEY_X = 88,
        KEY_Y = 89,
        KEY_Z = 90,
        KEY_SPACE = 32,
        KEY_ESCAPE = 256,
        KEY_ENTER = 257,
        KEY_TAB = 258,
        KEY_BACKSPACE = 259,
        KEY_INSERT = 260,
        KEY_DELETE = 261,
        KEY_RIGHT = 262,
        KEY_LEFT = 263,
        KEY_DOWN = 264,
        KEY_UP = 265,
        KEY_PAGE_UP = 266,
        KEY_PAGE_DOWN = 267,
        KEY_HOME = 268,
        KEY_END = 269,
        KEY_CAPS_LOCK = 280,
        KEY_SCROLL_LOCK = 281,
        KEY_NUM_LOCK = 282,
        KEY_PRINT_SCREEN = 283,
        KEY_PAUSE = 284,
        KEY_F1 = 290,
        KEY_F2 = 291,
        KEY_F3 = 292,
        KEY_F4 = 293,
        KEY_F5 = 294,
        KEY_F6 = 295,
        KEY_F7 = 296,
        KEY_F8 = 297,
        KEY_F9 = 298,
        KEY_F10 = 299,
        KEY_F11 = 300,
        KEY_F12 = 301,
        KEY_LEFT_SHIFT = 340,
        KEY_LEFT_CONTROL = 341,
        KEY_LEFT_ALT = 342,
        KEY_LEFT_SUPER = 343,
        KEY_RIGHT_SHIFT = 344,
        KEY_RIGHT_CONTROL = 345,
        KEY_RIGHT_ALT = 346,
        KEY_RIGHT_SUPER = 347,
        KEY_KB_MENU = 348,
        KEY_LEFT_BRACKET = 91,
        KEY_BACKSLASH = 92,
        KEY_RIGHT_BRACKET = 93,
        KEY_GRAVE = 96,
        KEY_KP_0 = 320,
        KEY_KP_1 = 321,
        KEY_KP_2 = 322,
        KEY_KP_3 = 323,
        KEY_KP_4 = 324,
        KEY_KP_5 = 325,
        KEY_KP_6 = 326,
        KEY_KP_7 = 327,
        KEY_KP_8 = 328,
        KEY_KP_9 = 329,
        KEY_KP_DECIMAL = 330,
        KEY_KP_DIVIDE = 331,
        KEY_KP_MULTIPLY = 332,
        KEY_KP_SUBTRACT = 333,
        KEY_KP_ADD = 334,
        KEY_KP_ENTER = 335,
        KEY_KP_EQUAL = 336
    }

    public enum AndroidButton
    {
        KEY_BACK = 4,
        KEY_MENU = 82,
        KEY_VOLUME_UP = 24,
        KEY_VOLUME_DOWN = 25
    }

    public enum MouseButton
    {
        MOUSE_LEFT_BUTTON = 0,
        MOUSE_RIGHT_BUTTON = 1,
        MOUSE_MIDDLE_BUTTON = 2
    }

    public enum GamepadNumber
    {
        GAMEPAD_PLAYER1 = 0,
        GAMEPAD_PLAYER2 = 1,
        GAMEPAD_PLAYER3 = 2,
        GAMEPAD_PLAYER4 = 3
    }

    public enum GamepadButton
    {
        GAMEPAD_BUTTON_UNKNOWN = 0,
        GAMEPAD_BUTTON_LEFT_FACE_UP = 1,
        GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2,
        GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3,
        GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4,
        GAMEPAD_BUTTON_RIGHT_FACE_UP = 5,
        GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6,
        GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7,
        GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8,
        GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9,
        GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10,
        GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11,
        GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12,
        GAMEPAD_BUTTON_MIDDLE_LEFT = 13,
        GAMEPAD_BUTTON_MIDDLE = 14,
        GAMEPAD_BUTTON_MIDDLE_RIGHT = 15,
        GAMEPAD_BUTTON_LEFT_THUMB = 16,
        GAMEPAD_BUTTON_RIGHT_THUMB = 17
    }

    public enum GamepadAxis
    {
        GAMEPAD_AXIS_UNKNOWN = 0,
        GAMEPAD_AXIS_LEFT_X = 1,
        GAMEPAD_AXIS_LEFT_Y = 2,
        GAMEPAD_AXIS_RIGHT_X = 3,
        GAMEPAD_AXIS_RIGHT_Y = 4,
        GAMEPAD_AXIS_LEFT_TRIGGER = 5,
        GAMEPAD_AXIS_RIGHT_TRIGGER = 6
    }

    public enum ShaderLocationIndex
    {
        LOC_VERTEX_POSITION = 0,
        LOC_VERTEX_TEXCOORD01 = 1,
        LOC_VERTEX_TEXCOORD02 = 2,
        LOC_VERTEX_NORMAL = 3,
        LOC_VERTEX_TANGENT = 4,
        LOC_VERTEX_COLOR = 5,
        LOC_MATRIX_MVP = 6,
        LOC_MATRIX_MODEL = 7,
        LOC_MATRIX_VIEW = 8,
        LOC_MATRIX_PROJECTION = 9,
        LOC_VECTOR_VIEW = 10,
        LOC_COLOR_DIFFUSE = 11,
        LOC_COLOR_SPECULAR = 12,
        LOC_COLOR_AMBIENT = 13,
        LOC_MAP_ALBEDO = 14,
        LOC_MAP_METALNESS = 15,
        LOC_MAP_NORMAL = 16,
        LOC_MAP_ROUGHNESS = 17,
        LOC_MAP_OCCLUSION = 18,
        LOC_MAP_EMISSION = 19,
        LOC_MAP_HEIGHT = 20,
        LOC_MAP_CUBEMAP = 21,
        LOC_MAP_IRRADIANCE = 22,
        LOC_MAP_PREFILTER = 23,
        LOC_MAP_BRDF = 24
    }

    public enum ShaderUniformDataType
    {
        UNIFORM_FLOAT = 0,
        UNIFORM_VEC2 = 1,
        UNIFORM_VEC3 = 2,
        UNIFORM_VEC4 = 3,
        UNIFORM_INT = 4,
        UNIFORM_IVEC2 = 5,
        UNIFORM_IVEC3 = 6,
        UNIFORM_IVEC4 = 7,
        UNIFORM_SAMPLER2D = 8
    }

    public enum MaterialMapType
    {
        MAP_ALBEDO = 0,
        MAP_METALNESS = 1,
        MAP_NORMAL = 2,
        MAP_ROUGHNESS = 3,
        MAP_OCCLUSION = 4,
        MAP_EMISSION = 5,
        MAP_HEIGHT = 6,
        MAP_CUBEMAP = 7,
        MAP_IRRADIANCE = 8,
        MAP_PREFILTER = 9,
        MAP_BRDF = 10
    }

    public enum PixelFormat
    {
        UNCOMPRESSED_GRAYSCALE = 1,
        UNCOMPRESSED_GRAY_ALPHA = 2,
        UNCOMPRESSED_R5G6B5 = 3,
        UNCOMPRESSED_R8G8B8 = 4,
        UNCOMPRESSED_R5G5B5A1 = 5,
        UNCOMPRESSED_R4G4B4A4 = 6,
        UNCOMPRESSED_R8G8B8A8 = 7,
        UNCOMPRESSED_R32 = 8,
        UNCOMPRESSED_R32G32B32 = 9,
        UNCOMPRESSED_R32G32B32A32 = 10,
        COMPRESSED_DXT1RGB = 11,
        COMPRESSED_DXT1RGBA = 12,
        COMPRESSED_DXT3RGBA = 13,
        COMPRESSED_DXT5RGBA = 14,
        COMPRESSED_ETC1RGB = 15,
        COMPRESSED_ETC2RGB = 16,
        COMPRESSED_ETC2EAC_RGBA = 17,
        COMPRESSED_PVRT_RGB = 18,
        COMPRESSED_PVRT_RGBA = 19,
        COMPRESSED_ASTC_4x4RGBA = 20,
        COMPRESSED_ASTC_8x8RGBA = 21
    }

    public enum TextureFilterMode
    {
        FILTER_POINT = 0,
        FILTER_BILINEAR = 1,
        FILTER_TRILINEAR = 2,
        FILTER_ANISOTROPIC_4X = 3,
        FILTER_ANISOTROPIC_8X = 4,
        FILTER_ANISOTROPIC_16X = 5
    }

    public enum CubemapLayoutType
    {
        CUBEMAP_AUTO_DETECT = 0,
        CUBEMAP_LINE_VERTICAL = 1,
        CUBEMAP_LINE_HORIZONTAL = 2,
        CUBEMAP_CROSS_THREE_BY_FOUR = 3,
        CUBEMAP_CROSS_FOUR_BY_THREE = 4,
        CUBEMAP_PANORAMA = 5
    }

    public enum TextureWrapMode
    {
        WRAP_REPEAT = 0,
        WRAP_CLAMP = 1,
        WRAP_MIRROR_REPEAT = 2,
        WRAP_MIRROR_CLAMP = 3
    }

    public enum FontType
    {
        FONT_DEFAULT = 0,
        FONT_BITMAP = 1,
        FONT_SDF = 2
    }

    public enum BlendMode
    {
        BLEND_ALPHA = 0,
        BLEND_ADDITIVE = 1,
        BLEND_MULTIPLIED = 2
    }

    [Flags]
    public enum GestureType
    {
        GESTURE_NONE = 0,
        GESTURE_TAP = 1,
        GESTURE_DOUBLETAP = 2,
        GESTURE_HOLD = 4,
        GESTURE_DRAG = 8,
        GESTURE_SWIPE_RIGHT = 16,
        GESTURE_SWIPE_LEFT = 32,
        GESTURE_SWIPE_UP = 64,
        GESTURE_SWIPE_DOWN = 128,
        GESTURE_PINCH_IN = 256,
        GESTURE_PINCH_OUT = 512
    }

    public enum CameraMode
    {
        CAMERA_CUSTOM = 0,
        CAMERA_FREE = 1,
        CAMERA_ORBITAL = 2,
        CAMERA_FIRST_PERSON = 3,
        CAMERA_THIRD_PERSON = 4
    }

    public enum CameraType
    {
        CAMERA_PERSPECTIVE = 0,
        CAMERA_ORTHOGRAPHIC = 1
    }

    public enum NPatchType
    {
        NPT_9PATCH = 0,
        NPT_3PATCH_VERTICAL = 1,
        NPT_3PATCH_HORIZONTAL = 2
    }

    public unsafe partial class Vector2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x;

            [FieldOffset(4)]
            internal float y;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Add@@YA?AUVector2@@U1@0@Z")]
            internal static extern global::Raylib.Vector2.__Internal Add(global::System.IntPtr __instance, global::Raylib.Vector2.__Internal v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Subtract@@YA?AUVector2@@U1@0@Z")]
            internal static extern global::Raylib.Vector2.__Internal Subtract(global::System.IntPtr __instance, global::Raylib.Vector2.__Internal v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2DotProduct@@YAMUVector2@@0@Z")]
            internal static extern float DotProduct(global::System.IntPtr __instance, global::Raylib.Vector2.__Internal v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Distance@@YAMUVector2@@0@Z")]
            internal static extern float Distance(global::System.IntPtr __instance, global::Raylib.Vector2.__Internal v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Angle@@YAMUVector2@@0@Z")]
            internal static extern float Angle(global::System.IntPtr __instance, global::Raylib.Vector2.__Internal v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Scale@@YA?AUVector2@@U1@M@Z")]
            internal static extern global::Raylib.Vector2.__Internal Scale(global::System.IntPtr __instance, float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2MultiplyV@@YA?AUVector2@@U1@0@Z")]
            internal static extern global::Raylib.Vector2.__Internal MultiplyV(global::System.IntPtr __instance, global::Raylib.Vector2.__Internal v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Negate@@YA?AUVector2@@U1@@Z")]
            internal static extern global::Raylib.Vector2.__Internal Negate(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Divide@@YA?AUVector2@@U1@M@Z")]
            internal static extern global::Raylib.Vector2.__Internal Divide(global::System.IntPtr __instance, float div);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2DivideV@@YA?AUVector2@@U1@0@Z")]
            internal static extern global::Raylib.Vector2.__Internal DivideV(global::System.IntPtr __instance, global::Raylib.Vector2.__Internal v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Normalize@@YA?AUVector2@@U1@@Z")]
            internal static extern global::Raylib.Vector2.__Internal Normalize(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Lerp@@YA?AUVector2@@U1@0M@Z")]
            internal static extern global::Raylib.Vector2.__Internal Lerp(global::System.IntPtr __instance, global::Raylib.Vector2.__Internal v2, float amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Length@@YAMUVector2@@@Z")]
            internal static extern float Length(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Vector2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Vector2>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Vector2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Vector2(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Vector2 __CreateInstance(global::Raylib.Vector2.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Vector2(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Vector2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Vector2.__Internal));
            *(global::Raylib.Vector2.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vector2(global::Raylib.Vector2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Vector2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Vector2(global::Raylib.Vector2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Vector2.__Internal*) __Instance) = *((global::Raylib.Vector2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Vector2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Vector2 Add(global::Raylib.Vector2 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Add((__Instance + __PointerAdjustment), *(global::Raylib.Vector2.__Internal*)__arg0);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public global::Raylib.Vector2 Subtract(global::Raylib.Vector2 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Subtract((__Instance + __PointerAdjustment), *(global::Raylib.Vector2.__Internal*)__arg0);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public float DotProduct(global::Raylib.Vector2 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.DotProduct((__Instance + __PointerAdjustment), *(global::Raylib.Vector2.__Internal*)__arg0);
            return __ret;
        }

        public float Distance(global::Raylib.Vector2 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), *(global::Raylib.Vector2.__Internal*)__arg0);
            return __ret;
        }

        public float Angle(global::Raylib.Vector2 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), *(global::Raylib.Vector2.__Internal*)__arg0);
            return __ret;
        }

        public global::Raylib.Vector2 Scale(float scale)
        {
            var __ret = __Internal.Scale((__Instance + __PointerAdjustment), scale);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public global::Raylib.Vector2 MultiplyV(global::Raylib.Vector2 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.MultiplyV((__Instance + __PointerAdjustment), *(global::Raylib.Vector2.__Internal*)__arg0);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public global::Raylib.Vector2 Negate()
        {
            var __ret = __Internal.Negate((__Instance + __PointerAdjustment));
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public global::Raylib.Vector2 Divide(float div)
        {
            var __ret = __Internal.Divide((__Instance + __PointerAdjustment), div);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public global::Raylib.Vector2 DivideV(global::Raylib.Vector2 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.DivideV((__Instance + __PointerAdjustment), *(global::Raylib.Vector2.__Internal*)__arg0);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public global::Raylib.Vector2 Normalize()
        {
            var __ret = __Internal.Normalize((__Instance + __PointerAdjustment));
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public global::Raylib.Vector2 Lerp(global::Raylib.Vector2 v2, float amount)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Lerp((__Instance + __PointerAdjustment), *(global::Raylib.Vector2.__Internal*)__arg0, amount);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public float X
        {
            get
            {
                return ((global::Raylib.Vector2.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::Raylib.Vector2.__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((global::Raylib.Vector2.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::Raylib.Vector2.__Internal*)__Instance)->y = value;
            }
        }

        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class RAudioBuffer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.RAudioBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.RAudioBuffer>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.RAudioBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.RAudioBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.RAudioBuffer __CreateInstance(global::Raylib.RAudioBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.RAudioBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.RAudioBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.RAudioBuffer.__Internal));
            *(global::Raylib.RAudioBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RAudioBuffer(global::Raylib.RAudioBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RAudioBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Vector3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x;

            [FieldOffset(4)]
            internal float y;

            [FieldOffset(8)]
            internal float z;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Add@@YA?AUVector3@@U1@0@Z")]
            internal static extern global::Raylib.Vector3.__Internal Add(global::System.IntPtr __instance, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Subtract@@YA?AUVector3@@U1@0@Z")]
            internal static extern global::Raylib.Vector3.__Internal Subtract(global::System.IntPtr __instance, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Multiply@@YA?AUVector3@@U1@M@Z")]
            internal static extern global::Raylib.Vector3.__Internal Multiply(global::System.IntPtr __instance, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3MultiplyV@@YA?AUVector3@@U1@0@Z")]
            internal static extern global::Raylib.Vector3.__Internal MultiplyV(global::System.IntPtr __instance, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3CrossProduct@@YA?AUVector3@@U1@0@Z")]
            internal static extern global::Raylib.Vector3.__Internal CrossProduct(global::System.IntPtr __instance, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3DotProduct@@YAMUVector3@@0@Z")]
            internal static extern float DotProduct(global::System.IntPtr __instance, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Distance@@YAMUVector3@@0@Z")]
            internal static extern float Distance(global::System.IntPtr __instance, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Scale@@YA?AUVector3@@U1@M@Z")]
            internal static extern global::Raylib.Vector3.__Internal Scale(global::System.IntPtr __instance, float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Negate@@YA?AUVector3@@U1@@Z")]
            internal static extern global::Raylib.Vector3.__Internal Negate(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Divide@@YA?AUVector3@@U1@M@Z")]
            internal static extern global::Raylib.Vector3.__Internal Divide(global::System.IntPtr __instance, float div);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3DivideV@@YA?AUVector3@@U1@0@Z")]
            internal static extern global::Raylib.Vector3.__Internal DivideV(global::System.IntPtr __instance, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Normalize@@YA?AUVector3@@U1@@Z")]
            internal static extern global::Raylib.Vector3.__Internal Normalize(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Transform@@YA?AUVector3@@U1@UMatrix@@@Z")]
            internal static extern global::Raylib.Vector3.__Internal Transform(global::System.IntPtr __instance, global::System.IntPtr mat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3RotateByQuaternion@@YA?AUVector3@@U1@UVector4@@@Z")]
            internal static extern global::Raylib.Vector3.__Internal RotateByQuaternion(global::System.IntPtr __instance, global::System.IntPtr q);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Lerp@@YA?AUVector3@@U1@0M@Z")]
            internal static extern global::Raylib.Vector3.__Internal Lerp(global::System.IntPtr __instance, global::System.IntPtr v2, float amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Reflect@@YA?AUVector3@@U1@0@Z")]
            internal static extern global::Raylib.Vector3.__Internal Reflect(global::System.IntPtr __instance, global::System.IntPtr normal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Min@@YA?AUVector3@@U1@0@Z")]
            internal static extern global::Raylib.Vector3.__Internal Min(global::System.IntPtr __instance, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Max@@YA?AUVector3@@U1@0@Z")]
            internal static extern global::Raylib.Vector3.__Internal Max(global::System.IntPtr __instance, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Barycenter@@YA?AUVector3@@U1@000@Z")]
            internal static extern global::Raylib.Vector3.__Internal Barycenter(global::System.IntPtr __instance, global::System.IntPtr a, global::System.IntPtr b, global::System.IntPtr c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3ToFloatV@@YA?AUfloat3@@UVector3@@@Z")]
            internal static extern global::Raylib.Float3.__Internal ToFloatV(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Perpendicular@@YA?AUVector3@@U1@@Z")]
            internal static extern global::Raylib.Vector3.__Internal Perpendicular(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Length@@YAMUVector3@@@Z")]
            internal static extern float Length(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Vector3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Vector3>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Vector3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Vector3(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Vector3 __CreateInstance(global::Raylib.Vector3.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Vector3(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Vector3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Vector3.__Internal));
            *(global::Raylib.Vector3.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vector3(global::Raylib.Vector3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Vector3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Vector3(global::Raylib.Vector3 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Vector3.__Internal*) __Instance) = *((global::Raylib.Vector3.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Vector3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Vector3 Add(global::Raylib.Vector3 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Add((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Subtract(global::Raylib.Vector3 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Subtract((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Multiply(float scalar)
        {
            var __ret = __Internal.Multiply((__Instance + __PointerAdjustment), scalar);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 MultiplyV(global::Raylib.Vector3 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.MultiplyV((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 CrossProduct(global::Raylib.Vector3 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.CrossProduct((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public float DotProduct(global::Raylib.Vector3 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.DotProduct((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public float Distance(global::Raylib.Vector3 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public global::Raylib.Vector3 Scale(float scale)
        {
            var __ret = __Internal.Scale((__Instance + __PointerAdjustment), scale);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Negate()
        {
            var __ret = __Internal.Negate((__Instance + __PointerAdjustment));
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Divide(float div)
        {
            var __ret = __Internal.Divide((__Instance + __PointerAdjustment), div);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 DivideV(global::Raylib.Vector3 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.DivideV((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Normalize()
        {
            var __ret = __Internal.Normalize((__Instance + __PointerAdjustment));
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Transform(global::Raylib.Matrix mat)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Transform((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 RotateByQuaternion(global::Raylib.Vector4 q)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.RotateByQuaternion((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Lerp(global::Raylib.Vector3 v2, float amount)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Lerp((__Instance + __PointerAdjustment), __arg0, amount);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Reflect(global::Raylib.Vector3 normal)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Reflect((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Min(global::Raylib.Vector3 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Min((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Max(global::Raylib.Vector3 v2)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Max((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 Barycenter(global::Raylib.Vector3 a, global::Raylib.Vector3 b, global::Raylib.Vector3 c)
        {
            var __arg0 = __Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            var __ret = __Internal.Barycenter((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public global::Raylib.Float3 ToFloatV()
        {
            var __ret = __Internal.ToFloatV((__Instance + __PointerAdjustment));
            return global::Raylib.Float3.__CreateInstance(__ret);
        }

        public float X
        {
            get
            {
                return ((global::Raylib.Vector3.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::Raylib.Vector3.__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((global::Raylib.Vector3.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::Raylib.Vector3.__Internal*)__Instance)->y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((global::Raylib.Vector3.__Internal*) __Instance)->z;
            }

            set
            {
                ((global::Raylib.Vector3.__Internal*)__Instance)->z = value;
            }
        }

        public global::Raylib.Vector3 Perpendicular
        {
            get
            {
                var __ret = __Internal.Perpendicular((__Instance + __PointerAdjustment));
                return global::Raylib.Vector3.__CreateInstance(__ret);
            }
        }

        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class Vector4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x;

            [FieldOffset(4)]
            internal float y;

            [FieldOffset(8)]
            internal float z;

            [FieldOffset(12)]
            internal float w;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Vector4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Vector4>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Vector4 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Vector4(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Vector4 __CreateInstance(global::Raylib.Vector4.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Vector4(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Vector4.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Vector4.__Internal));
            *(global::Raylib.Vector4.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vector4(global::Raylib.Vector4.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Vector4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Vector4(global::Raylib.Vector4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Vector4.__Internal*) __Instance) = *((global::Raylib.Vector4.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Vector4 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((global::Raylib.Vector4.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::Raylib.Vector4.__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((global::Raylib.Vector4.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::Raylib.Vector4.__Internal*)__Instance)->y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((global::Raylib.Vector4.__Internal*) __Instance)->z;
            }

            set
            {
                ((global::Raylib.Vector4.__Internal*)__Instance)->z = value;
            }
        }

        public float W
        {
            get
            {
                return ((global::Raylib.Vector4.__Internal*) __Instance)->w;
            }

            set
            {
                ((global::Raylib.Vector4.__Internal*)__Instance)->w = value;
            }
        }
    }

    public unsafe partial class Matrix : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m0;

            [FieldOffset(4)]
            internal float m4;

            [FieldOffset(8)]
            internal float m8;

            [FieldOffset(12)]
            internal float m12;

            [FieldOffset(16)]
            internal float m1;

            [FieldOffset(20)]
            internal float m5;

            [FieldOffset(24)]
            internal float m9;

            [FieldOffset(28)]
            internal float m13;

            [FieldOffset(32)]
            internal float m2;

            [FieldOffset(36)]
            internal float m6;

            [FieldOffset(40)]
            internal float m10;

            [FieldOffset(44)]
            internal float m14;

            [FieldOffset(48)]
            internal float m3;

            [FieldOffset(52)]
            internal float m7;

            [FieldOffset(56)]
            internal float m11;

            [FieldOffset(60)]
            internal float m15;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixNormalize@@YA?AUMatrix@@U1@@Z")]
            internal static extern global::Raylib.Matrix.__Internal Normalize(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixAdd@@YA?AUMatrix@@U1@0@Z")]
            internal static extern global::Raylib.Matrix.__Internal Add(global::System.IntPtr __instance, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixSubtract@@YA?AUMatrix@@U1@0@Z")]
            internal static extern global::Raylib.Matrix.__Internal Subtract(global::System.IntPtr __instance, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixMultiply@@YA?AUMatrix@@U1@0@Z")]
            internal static extern global::Raylib.Matrix.__Internal Multiply(global::System.IntPtr __instance, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixToFloatV@@YA?AUfloat16@@UMatrix@@@Z")]
            internal static extern global::Raylib.Float16.__Internal ToFloatV(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixDeterminant@@YAMUMatrix@@@Z")]
            internal static extern float Determinant(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixTrace@@YAMUMatrix@@@Z")]
            internal static extern float Trace(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixTranspose@@YA?AUMatrix@@U1@@Z")]
            internal static extern global::Raylib.Matrix.__Internal Transpose(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixInvert@@YA?AUMatrix@@U1@@Z")]
            internal static extern global::Raylib.Matrix.__Internal Invert(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Matrix> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Matrix>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Matrix __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Matrix(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Matrix __CreateInstance(global::Raylib.Matrix.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Matrix(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Matrix.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Matrix.__Internal));
            *(global::Raylib.Matrix.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Matrix(global::Raylib.Matrix.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Matrix()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Matrix.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Matrix(global::Raylib.Matrix _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Matrix.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Matrix.__Internal*) __Instance) = *((global::Raylib.Matrix.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Matrix __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Matrix Normalize()
        {
            var __ret = __Internal.Normalize((__Instance + __PointerAdjustment));
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public global::Raylib.Matrix Add(global::Raylib.Matrix right)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Add((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public global::Raylib.Matrix Subtract(global::Raylib.Matrix right)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Subtract((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public global::Raylib.Matrix Multiply(global::Raylib.Matrix right)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.Multiply((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public global::Raylib.Float16 ToFloatV()
        {
            var __ret = __Internal.ToFloatV((__Instance + __PointerAdjustment));
            return global::Raylib.Float16.__CreateInstance(__ret);
        }

        public float M0
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m0;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m0 = value;
            }
        }

        public float M4
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m4;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m4 = value;
            }
        }

        public float M8
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m8;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m8 = value;
            }
        }

        public float M12
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m12;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m12 = value;
            }
        }

        public float M1
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m1;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m1 = value;
            }
        }

        public float M5
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m5;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m5 = value;
            }
        }

        public float M9
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m9;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m9 = value;
            }
        }

        public float M13
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m13;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m13 = value;
            }
        }

        public float M2
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m2;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m2 = value;
            }
        }

        public float M6
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m6;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m6 = value;
            }
        }

        public float M10
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m10;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m10 = value;
            }
        }

        public float M14
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m14;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m14 = value;
            }
        }

        public float M3
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m3;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m3 = value;
            }
        }

        public float M7
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m7;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m7 = value;
            }
        }

        public float M11
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m11;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m11 = value;
            }
        }

        public float M15
        {
            get
            {
                return ((global::Raylib.Matrix.__Internal*) __Instance)->m15;
            }

            set
            {
                ((global::Raylib.Matrix.__Internal*)__Instance)->m15 = value;
            }
        }

        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Trace
        {
            get
            {
                var __ret = __Internal.Trace((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Raylib.Matrix Transpose
        {
            get
            {
                var __ret = __Internal.Transpose((__Instance + __PointerAdjustment));
                return global::Raylib.Matrix.__CreateInstance(__ret);
            }
        }

        public global::Raylib.Matrix Invert
        {
            get
            {
                var __ret = __Internal.Invert((__Instance + __PointerAdjustment));
                return global::Raylib.Matrix.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class Color : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte r;

            [FieldOffset(1)]
            internal byte g;

            [FieldOffset(2)]
            internal byte b;

            [FieldOffset(3)]
            internal byte a;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Color@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ColorToInt")]
            internal static extern int ToInt(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ColorNormalize")]
            internal static extern global::Raylib.Vector4.__Internal Normalize(global::System.IntPtr __instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ColorToHSV")]
            internal static extern global::Raylib.Vector3.__Internal ToHSV(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Color> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Color>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Color __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Color(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Color __CreateInstance(global::Raylib.Color.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Color(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Color.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Color.__Internal));
            *(global::Raylib.Color.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Color(global::Raylib.Color.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Color(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Color()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Color.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Color(global::Raylib.Color _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Color.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Color.__Internal*) __Instance) = *((global::Raylib.Color.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Color __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ToInt()
        {
            var __ret = __Internal.ToInt((__Instance + __PointerAdjustment));
            return __ret;
        }

        public global::Raylib.Vector4 Normalize()
        {
            var __ret = __Internal.Normalize((__Instance + __PointerAdjustment));
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public global::Raylib.Vector3 ToHSV()
        {
            var __ret = __Internal.ToHSV((__Instance + __PointerAdjustment));
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public byte R
        {
            get
            {
                return ((global::Raylib.Color.__Internal*) __Instance)->r;
            }

            set
            {
                ((global::Raylib.Color.__Internal*)__Instance)->r = value;
            }
        }

        public byte G
        {
            get
            {
                return ((global::Raylib.Color.__Internal*) __Instance)->g;
            }

            set
            {
                ((global::Raylib.Color.__Internal*)__Instance)->g = value;
            }
        }

        public byte B
        {
            get
            {
                return ((global::Raylib.Color.__Internal*) __Instance)->b;
            }

            set
            {
                ((global::Raylib.Color.__Internal*)__Instance)->b = value;
            }
        }

        public byte A
        {
            get
            {
                return ((global::Raylib.Color.__Internal*) __Instance)->a;
            }

            set
            {
                ((global::Raylib.Color.__Internal*)__Instance)->a = value;
            }
        }
    }

    public unsafe partial class Rectangle : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x;

            [FieldOffset(4)]
            internal float y;

            [FieldOffset(8)]
            internal float width;

            [FieldOffset(12)]
            internal float height;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Rectangle@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Rectangle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Rectangle>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Rectangle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Rectangle(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Rectangle __CreateInstance(global::Raylib.Rectangle.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Rectangle(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Rectangle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Rectangle.__Internal));
            *(global::Raylib.Rectangle.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Rectangle(global::Raylib.Rectangle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Rectangle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Rectangle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Rectangle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Rectangle(global::Raylib.Rectangle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Rectangle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Rectangle.__Internal*) __Instance) = *((global::Raylib.Rectangle.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Rectangle __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((global::Raylib.Rectangle.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::Raylib.Rectangle.__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((global::Raylib.Rectangle.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::Raylib.Rectangle.__Internal*)__Instance)->y = value;
            }
        }

        public float Width
        {
            get
            {
                return ((global::Raylib.Rectangle.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::Raylib.Rectangle.__Internal*)__Instance)->width = value;
            }
        }

        public float Height
        {
            get
            {
                return ((global::Raylib.Rectangle.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::Raylib.Rectangle.__Internal*)__Instance)->height = value;
            }
        }
    }

    public unsafe partial class Image : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr data;

            [FieldOffset(8)]
            internal int width;

            [FieldOffset(12)]
            internal int height;

            [FieldOffset(16)]
            internal int mipmaps;

            [FieldOffset(20)]
            internal int format;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Image@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageFromImage")]
            internal static extern global::Raylib.Image.__Internal FromImage(global::System.IntPtr __instance, global::System.IntPtr rec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageExtractPalette")]
            internal static extern global::System.IntPtr ExtractPalette(global::System.IntPtr __instance, int maxPaletteSize, int* extractCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageCopy")]
            internal static extern global::Raylib.Image.__Internal Copy(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Image> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Image>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Image __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Image(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Image __CreateInstance(global::Raylib.Image.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Image(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Image.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Image.__Internal));
            *(global::Raylib.Image.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Image(global::Raylib.Image.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Image(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Image()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Image.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Image(global::Raylib.Image _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Image.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Image.__Internal*) __Instance) = *((global::Raylib.Image.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Image __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Image FromImage(global::Raylib.Rectangle rec)
        {
            var __arg0 = __Instance;
            var __ret = __Internal.FromImage((__Instance + __PointerAdjustment), __arg0);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public global::Raylib.Color ExtractPalette(int maxPaletteSize, ref int extractCount)
        {
            fixed (int* __extractCount1 = &extractCount)
            {
                var __arg1 = __extractCount1;
                var __ret = __Internal.ExtractPalette((__Instance + __PointerAdjustment), maxPaletteSize, __arg1);
                global::Raylib.Color __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.Color.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Raylib.Color) global::Raylib.Color.NativeToManagedMap[__ret];
                else __result0 = global::Raylib.Color.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::System.IntPtr Data
        {
            get
            {
                return ((global::Raylib.Image.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::Raylib.Image.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }

        public int Width
        {
            get
            {
                return ((global::Raylib.Image.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::Raylib.Image.__Internal*)__Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((global::Raylib.Image.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::Raylib.Image.__Internal*)__Instance)->height = value;
            }
        }

        public int Mipmaps
        {
            get
            {
                return ((global::Raylib.Image.__Internal*) __Instance)->mipmaps;
            }

            set
            {
                ((global::Raylib.Image.__Internal*)__Instance)->mipmaps = value;
            }
        }

        public int Format
        {
            get
            {
                return ((global::Raylib.Image.__Internal*) __Instance)->format;
            }

            set
            {
                ((global::Raylib.Image.__Internal*)__Instance)->format = value;
            }
        }

        public global::Raylib.Image Copy
        {
            get
            {
                var __ret = __Internal.Copy((__Instance + __PointerAdjustment));
                return global::Raylib.Image.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class Texture2D : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint id;

            [FieldOffset(4)]
            internal int width;

            [FieldOffset(8)]
            internal int height;

            [FieldOffset(12)]
            internal int mipmaps;

            [FieldOffset(16)]
            internal int format;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Texture2D@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Texture2D> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Texture2D>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Texture2D __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Texture2D(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Texture2D __CreateInstance(global::Raylib.Texture2D.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Texture2D(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Texture2D.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Texture2D.__Internal));
            *(global::Raylib.Texture2D.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Texture2D(global::Raylib.Texture2D.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Texture2D(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Texture2D()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Texture2D.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Texture2D(global::Raylib.Texture2D _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Texture2D.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Texture2D.__Internal*) __Instance) = *((global::Raylib.Texture2D.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Texture2D __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((global::Raylib.Texture2D.__Internal*) __Instance)->id;
            }

            set
            {
                ((global::Raylib.Texture2D.__Internal*)__Instance)->id = value;
            }
        }

        public int Width
        {
            get
            {
                return ((global::Raylib.Texture2D.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::Raylib.Texture2D.__Internal*)__Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((global::Raylib.Texture2D.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::Raylib.Texture2D.__Internal*)__Instance)->height = value;
            }
        }

        public int Mipmaps
        {
            get
            {
                return ((global::Raylib.Texture2D.__Internal*) __Instance)->mipmaps;
            }

            set
            {
                ((global::Raylib.Texture2D.__Internal*)__Instance)->mipmaps = value;
            }
        }

        public int Format
        {
            get
            {
                return ((global::Raylib.Texture2D.__Internal*) __Instance)->format;
            }

            set
            {
                ((global::Raylib.Texture2D.__Internal*)__Instance)->format = value;
            }
        }
    }

    public unsafe partial class RenderTexture2D : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint id;

            [FieldOffset(4)]
            internal global::Raylib.Texture2D.__Internal texture;

            [FieldOffset(24)]
            internal global::Raylib.Texture2D.__Internal depth;

            [FieldOffset(44)]
            internal byte depthTexture;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RenderTexture2D@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.RenderTexture2D> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.RenderTexture2D>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.RenderTexture2D __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.RenderTexture2D(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.RenderTexture2D __CreateInstance(global::Raylib.RenderTexture2D.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.RenderTexture2D(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.RenderTexture2D.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.RenderTexture2D.__Internal));
            *(global::Raylib.RenderTexture2D.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RenderTexture2D(global::Raylib.RenderTexture2D.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RenderTexture2D(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RenderTexture2D()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.RenderTexture2D.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RenderTexture2D(global::Raylib.RenderTexture2D _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.RenderTexture2D.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.RenderTexture2D.__Internal*) __Instance) = *((global::Raylib.RenderTexture2D.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.RenderTexture2D __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((global::Raylib.RenderTexture2D.__Internal*) __Instance)->id;
            }

            set
            {
                ((global::Raylib.RenderTexture2D.__Internal*)__Instance)->id = value;
            }
        }

        public global::Raylib.Texture2D Texture
        {
            get
            {
                return global::Raylib.Texture2D.__CreateInstance(new global::System.IntPtr(&((global::Raylib.RenderTexture2D.__Internal*) __Instance)->texture));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.RenderTexture2D.__Internal*)__Instance)->texture = *(global::Raylib.Texture2D.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Texture2D Depth
        {
            get
            {
                return global::Raylib.Texture2D.__CreateInstance(new global::System.IntPtr(&((global::Raylib.RenderTexture2D.__Internal*) __Instance)->depth));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.RenderTexture2D.__Internal*)__Instance)->depth = *(global::Raylib.Texture2D.__Internal*) value.__Instance;
            }
        }

        public bool DepthTexture
        {
            get
            {
                return ((global::Raylib.RenderTexture2D.__Internal*) __Instance)->depthTexture != 0;
            }

            set
            {
                ((global::Raylib.RenderTexture2D.__Internal*)__Instance)->depthTexture = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class NPatchInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.Rectangle.__Internal sourceRec;

            [FieldOffset(16)]
            internal int left;

            [FieldOffset(20)]
            internal int top;

            [FieldOffset(24)]
            internal int right;

            [FieldOffset(28)]
            internal int bottom;

            [FieldOffset(32)]
            internal int type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0NPatchInfo@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.NPatchInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.NPatchInfo>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.NPatchInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.NPatchInfo(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.NPatchInfo __CreateInstance(global::Raylib.NPatchInfo.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.NPatchInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.NPatchInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.NPatchInfo.__Internal));
            *(global::Raylib.NPatchInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private NPatchInfo(global::Raylib.NPatchInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected NPatchInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public NPatchInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.NPatchInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public NPatchInfo(global::Raylib.NPatchInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.NPatchInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.NPatchInfo.__Internal*) __Instance) = *((global::Raylib.NPatchInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.NPatchInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Rectangle SourceRec
        {
            get
            {
                return global::Raylib.Rectangle.__CreateInstance(new global::System.IntPtr(&((global::Raylib.NPatchInfo.__Internal*) __Instance)->sourceRec));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.NPatchInfo.__Internal*)__Instance)->sourceRec = *(global::Raylib.Rectangle.__Internal*) value.__Instance;
            }
        }

        public int Left
        {
            get
            {
                return ((global::Raylib.NPatchInfo.__Internal*) __Instance)->left;
            }

            set
            {
                ((global::Raylib.NPatchInfo.__Internal*)__Instance)->left = value;
            }
        }

        public int Top
        {
            get
            {
                return ((global::Raylib.NPatchInfo.__Internal*) __Instance)->top;
            }

            set
            {
                ((global::Raylib.NPatchInfo.__Internal*)__Instance)->top = value;
            }
        }

        public int Right
        {
            get
            {
                return ((global::Raylib.NPatchInfo.__Internal*) __Instance)->right;
            }

            set
            {
                ((global::Raylib.NPatchInfo.__Internal*)__Instance)->right = value;
            }
        }

        public int Bottom
        {
            get
            {
                return ((global::Raylib.NPatchInfo.__Internal*) __Instance)->bottom;
            }

            set
            {
                ((global::Raylib.NPatchInfo.__Internal*)__Instance)->bottom = value;
            }
        }

        public int Type
        {
            get
            {
                return ((global::Raylib.NPatchInfo.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::Raylib.NPatchInfo.__Internal*)__Instance)->type = value;
            }
        }
    }

    public unsafe partial class CharInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int value;

            [FieldOffset(4)]
            internal int offsetX;

            [FieldOffset(8)]
            internal int offsetY;

            [FieldOffset(12)]
            internal int advanceX;

            [FieldOffset(16)]
            internal global::Raylib.Image.__Internal image;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CharInfo@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.CharInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.CharInfo>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.CharInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.CharInfo(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.CharInfo __CreateInstance(global::Raylib.CharInfo.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.CharInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.CharInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.CharInfo.__Internal));
            *(global::Raylib.CharInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CharInfo(global::Raylib.CharInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CharInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CharInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.CharInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public CharInfo(global::Raylib.CharInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.CharInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.CharInfo.__Internal*) __Instance) = *((global::Raylib.CharInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.CharInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Value
        {
            get
            {
                return ((global::Raylib.CharInfo.__Internal*) __Instance)->value;
            }

            set
            {
                ((global::Raylib.CharInfo.__Internal*)__Instance)->value = value;
            }
        }

        public int OffsetX
        {
            get
            {
                return ((global::Raylib.CharInfo.__Internal*) __Instance)->offsetX;
            }

            set
            {
                ((global::Raylib.CharInfo.__Internal*)__Instance)->offsetX = value;
            }
        }

        public int OffsetY
        {
            get
            {
                return ((global::Raylib.CharInfo.__Internal*) __Instance)->offsetY;
            }

            set
            {
                ((global::Raylib.CharInfo.__Internal*)__Instance)->offsetY = value;
            }
        }

        public int AdvanceX
        {
            get
            {
                return ((global::Raylib.CharInfo.__Internal*) __Instance)->advanceX;
            }

            set
            {
                ((global::Raylib.CharInfo.__Internal*)__Instance)->advanceX = value;
            }
        }

        public global::Raylib.Image Image
        {
            get
            {
                return global::Raylib.Image.__CreateInstance(new global::System.IntPtr(&((global::Raylib.CharInfo.__Internal*) __Instance)->image));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.CharInfo.__Internal*)__Instance)->image = *(global::Raylib.Image.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class Font : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int baseSize;

            [FieldOffset(4)]
            internal int charsCount;

            [FieldOffset(8)]
            internal global::Raylib.Texture2D.__Internal texture;

            [FieldOffset(32)]
            internal global::System.IntPtr recs;

            [FieldOffset(40)]
            internal global::System.IntPtr chars;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Font@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Font> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Font>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Font __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Font(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Font __CreateInstance(global::Raylib.Font.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Font(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Font.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Font.__Internal));
            *(global::Raylib.Font.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Font(global::Raylib.Font.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Font(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Font()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Font.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Font(global::Raylib.Font _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Font.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Font.__Internal*) __Instance) = *((global::Raylib.Font.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Font __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int BaseSize
        {
            get
            {
                return ((global::Raylib.Font.__Internal*) __Instance)->baseSize;
            }

            set
            {
                ((global::Raylib.Font.__Internal*)__Instance)->baseSize = value;
            }
        }

        public int CharsCount
        {
            get
            {
                return ((global::Raylib.Font.__Internal*) __Instance)->charsCount;
            }

            set
            {
                ((global::Raylib.Font.__Internal*)__Instance)->charsCount = value;
            }
        }

        public global::Raylib.Texture2D Texture
        {
            get
            {
                return global::Raylib.Texture2D.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Font.__Internal*) __Instance)->texture));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Font.__Internal*)__Instance)->texture = *(global::Raylib.Texture2D.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Rectangle Recs
        {
            get
            {
                global::Raylib.Rectangle __result0;
                if (((global::Raylib.Font.__Internal*) __Instance)->recs == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.Rectangle.NativeToManagedMap.ContainsKey(((global::Raylib.Font.__Internal*) __Instance)->recs))
                    __result0 = (global::Raylib.Rectangle) global::Raylib.Rectangle.NativeToManagedMap[((global::Raylib.Font.__Internal*) __Instance)->recs];
                else __result0 = global::Raylib.Rectangle.__CreateInstance(((global::Raylib.Font.__Internal*) __Instance)->recs);
                return __result0;
            }

            set
            {
                ((global::Raylib.Font.__Internal*)__Instance)->recs = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::Raylib.CharInfo Chars
        {
            get
            {
                global::Raylib.CharInfo __result0;
                if (((global::Raylib.Font.__Internal*) __Instance)->chars == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.CharInfo.NativeToManagedMap.ContainsKey(((global::Raylib.Font.__Internal*) __Instance)->chars))
                    __result0 = (global::Raylib.CharInfo) global::Raylib.CharInfo.NativeToManagedMap[((global::Raylib.Font.__Internal*) __Instance)->chars];
                else __result0 = global::Raylib.CharInfo.__CreateInstance(((global::Raylib.Font.__Internal*) __Instance)->chars);
                return __result0;
            }

            set
            {
                ((global::Raylib.Font.__Internal*)__Instance)->chars = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class Camera3D : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 44)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.Vector3.__Internal position;

            [FieldOffset(12)]
            internal global::Raylib.Vector3.__Internal target;

            [FieldOffset(24)]
            internal global::Raylib.Vector3.__Internal up;

            [FieldOffset(36)]
            internal float fovy;

            [FieldOffset(40)]
            internal int type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Camera3D@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Camera3D> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Camera3D>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Camera3D __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Camera3D(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Camera3D __CreateInstance(global::Raylib.Camera3D.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Camera3D(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Camera3D.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Camera3D.__Internal));
            *(global::Raylib.Camera3D.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Camera3D(global::Raylib.Camera3D.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Camera3D(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Camera3D()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Camera3D.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Camera3D(global::Raylib.Camera3D _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Camera3D.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Camera3D.__Internal*) __Instance) = *((global::Raylib.Camera3D.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Camera3D __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Vector3 Position
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Camera3D.__Internal*) __Instance)->position));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Camera3D.__Internal*)__Instance)->position = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector3 Target
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Camera3D.__Internal*) __Instance)->target));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Camera3D.__Internal*)__Instance)->target = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector3 Up
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Camera3D.__Internal*) __Instance)->up));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Camera3D.__Internal*)__Instance)->up = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }

        public float Fovy
        {
            get
            {
                return ((global::Raylib.Camera3D.__Internal*) __Instance)->fovy;
            }

            set
            {
                ((global::Raylib.Camera3D.__Internal*)__Instance)->fovy = value;
            }
        }

        public int Type
        {
            get
            {
                return ((global::Raylib.Camera3D.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::Raylib.Camera3D.__Internal*)__Instance)->type = value;
            }
        }
    }

    public unsafe partial class Camera2D : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.Vector2.__Internal offset;

            [FieldOffset(8)]
            internal global::Raylib.Vector2.__Internal target;

            [FieldOffset(16)]
            internal float rotation;

            [FieldOffset(20)]
            internal float zoom;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Camera2D@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Camera2D> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Camera2D>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Camera2D __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Camera2D(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Camera2D __CreateInstance(global::Raylib.Camera2D.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Camera2D(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Camera2D.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Camera2D.__Internal));
            *(global::Raylib.Camera2D.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Camera2D(global::Raylib.Camera2D.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Camera2D(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Camera2D()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Camera2D.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Camera2D(global::Raylib.Camera2D _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Camera2D.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Camera2D.__Internal*) __Instance) = *((global::Raylib.Camera2D.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Camera2D __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Vector2 Offset
        {
            get
            {
                return global::Raylib.Vector2.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Camera2D.__Internal*) __Instance)->offset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Camera2D.__Internal*)__Instance)->offset = *(global::Raylib.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector2 Target
        {
            get
            {
                return global::Raylib.Vector2.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Camera2D.__Internal*) __Instance)->target));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Camera2D.__Internal*)__Instance)->target = *(global::Raylib.Vector2.__Internal*) value.__Instance;
            }
        }

        public float Rotation
        {
            get
            {
                return ((global::Raylib.Camera2D.__Internal*) __Instance)->rotation;
            }

            set
            {
                ((global::Raylib.Camera2D.__Internal*)__Instance)->rotation = value;
            }
        }

        public float Zoom
        {
            get
            {
                return ((global::Raylib.Camera2D.__Internal*) __Instance)->zoom;
            }

            set
            {
                ((global::Raylib.Camera2D.__Internal*)__Instance)->zoom = value;
            }
        }
    }

    public unsafe partial class Mesh : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int vertexCount;

            [FieldOffset(4)]
            internal int triangleCount;

            [FieldOffset(8)]
            internal global::System.IntPtr vertices;

            [FieldOffset(16)]
            internal global::System.IntPtr texcoords;

            [FieldOffset(24)]
            internal global::System.IntPtr texcoords2;

            [FieldOffset(32)]
            internal global::System.IntPtr normals;

            [FieldOffset(40)]
            internal global::System.IntPtr tangents;

            [FieldOffset(48)]
            internal global::System.IntPtr colors;

            [FieldOffset(56)]
            internal global::System.IntPtr indices;

            [FieldOffset(64)]
            internal global::System.IntPtr animVertices;

            [FieldOffset(72)]
            internal global::System.IntPtr animNormals;

            [FieldOffset(80)]
            internal global::System.IntPtr boneIds;

            [FieldOffset(88)]
            internal global::System.IntPtr boneWeights;

            [FieldOffset(96)]
            internal uint vaoId;

            [FieldOffset(104)]
            internal global::System.IntPtr vboId;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mesh@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="MeshBoundingBox")]
            internal static extern global::Raylib.BoundingBox.__Internal BoundingBox(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Mesh> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Mesh>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Mesh __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Mesh(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Mesh __CreateInstance(global::Raylib.Mesh.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Mesh(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Mesh.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Mesh.__Internal));
            *(global::Raylib.Mesh.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Mesh(global::Raylib.Mesh.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Mesh(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Mesh()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Mesh.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Mesh(global::Raylib.Mesh _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Mesh.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Mesh.__Internal*) __Instance) = *((global::Raylib.Mesh.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Mesh __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int VertexCount
        {
            get
            {
                return ((global::Raylib.Mesh.__Internal*) __Instance)->vertexCount;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->vertexCount = value;
            }
        }

        public int TriangleCount
        {
            get
            {
                return ((global::Raylib.Mesh.__Internal*) __Instance)->triangleCount;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->triangleCount = value;
            }
        }

        public float* Vertices
        {
            get
            {
                return (float*) ((global::Raylib.Mesh.__Internal*) __Instance)->vertices;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->vertices = (global::System.IntPtr) value;
            }
        }

        public float* Texcoords
        {
            get
            {
                return (float*) ((global::Raylib.Mesh.__Internal*) __Instance)->texcoords;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->texcoords = (global::System.IntPtr) value;
            }
        }

        public float* Texcoords2
        {
            get
            {
                return (float*) ((global::Raylib.Mesh.__Internal*) __Instance)->texcoords2;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->texcoords2 = (global::System.IntPtr) value;
            }
        }

        public float* Normals
        {
            get
            {
                return (float*) ((global::Raylib.Mesh.__Internal*) __Instance)->normals;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->normals = (global::System.IntPtr) value;
            }
        }

        public float* Tangents
        {
            get
            {
                return (float*) ((global::Raylib.Mesh.__Internal*) __Instance)->tangents;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->tangents = (global::System.IntPtr) value;
            }
        }

        public byte* Colors
        {
            get
            {
                return (byte*) ((global::Raylib.Mesh.__Internal*) __Instance)->colors;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->colors = (global::System.IntPtr) value;
            }
        }

        public ushort* Indices
        {
            get
            {
                return (ushort*) ((global::Raylib.Mesh.__Internal*) __Instance)->indices;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->indices = (global::System.IntPtr) value;
            }
        }

        public float* AnimVertices
        {
            get
            {
                return (float*) ((global::Raylib.Mesh.__Internal*) __Instance)->animVertices;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->animVertices = (global::System.IntPtr) value;
            }
        }

        public float* AnimNormals
        {
            get
            {
                return (float*) ((global::Raylib.Mesh.__Internal*) __Instance)->animNormals;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->animNormals = (global::System.IntPtr) value;
            }
        }

        public int* BoneIds
        {
            get
            {
                return (int*) ((global::Raylib.Mesh.__Internal*) __Instance)->boneIds;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->boneIds = (global::System.IntPtr) value;
            }
        }

        public float* BoneWeights
        {
            get
            {
                return (float*) ((global::Raylib.Mesh.__Internal*) __Instance)->boneWeights;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->boneWeights = (global::System.IntPtr) value;
            }
        }

        public uint VaoId
        {
            get
            {
                return ((global::Raylib.Mesh.__Internal*) __Instance)->vaoId;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->vaoId = value;
            }
        }

        public uint* VboId
        {
            get
            {
                return (uint*) ((global::Raylib.Mesh.__Internal*) __Instance)->vboId;
            }

            set
            {
                ((global::Raylib.Mesh.__Internal*)__Instance)->vboId = (global::System.IntPtr) value;
            }
        }

        public global::Raylib.BoundingBox BoundingBox
        {
            get
            {
                var __ret = __Internal.BoundingBox((__Instance + __PointerAdjustment));
                return global::Raylib.BoundingBox.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class Shader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint id;

            [FieldOffset(8)]
            internal global::System.IntPtr locs;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Shader@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Shader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Shader>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Shader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Shader(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Shader __CreateInstance(global::Raylib.Shader.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Shader(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Shader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Shader.__Internal));
            *(global::Raylib.Shader.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Shader(global::Raylib.Shader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Shader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Shader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Shader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Shader(global::Raylib.Shader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Shader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Shader.__Internal*) __Instance) = *((global::Raylib.Shader.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Shader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((global::Raylib.Shader.__Internal*) __Instance)->id;
            }

            set
            {
                ((global::Raylib.Shader.__Internal*)__Instance)->id = value;
            }
        }

        public int* Locs
        {
            get
            {
                return (int*) ((global::Raylib.Shader.__Internal*) __Instance)->locs;
            }

            set
            {
                ((global::Raylib.Shader.__Internal*)__Instance)->locs = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class MaterialMap : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.Texture2D.__Internal texture;

            [FieldOffset(20)]
            internal global::Raylib.Color.__Internal color;

            [FieldOffset(24)]
            internal float value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialMap@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.MaterialMap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.MaterialMap>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.MaterialMap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.MaterialMap(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.MaterialMap __CreateInstance(global::Raylib.MaterialMap.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.MaterialMap(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.MaterialMap.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.MaterialMap.__Internal));
            *(global::Raylib.MaterialMap.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MaterialMap(global::Raylib.MaterialMap.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MaterialMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MaterialMap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.MaterialMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MaterialMap(global::Raylib.MaterialMap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.MaterialMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.MaterialMap.__Internal*) __Instance) = *((global::Raylib.MaterialMap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.MaterialMap __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Texture2D Texture
        {
            get
            {
                return global::Raylib.Texture2D.__CreateInstance(new global::System.IntPtr(&((global::Raylib.MaterialMap.__Internal*) __Instance)->texture));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.MaterialMap.__Internal*)__Instance)->texture = *(global::Raylib.Texture2D.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Color Color
        {
            get
            {
                return global::Raylib.Color.__CreateInstance(new global::System.IntPtr(&((global::Raylib.MaterialMap.__Internal*) __Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.MaterialMap.__Internal*)__Instance)->color = *(global::Raylib.Color.__Internal*) value.__Instance;
            }
        }

        public float Value
        {
            get
            {
                return ((global::Raylib.MaterialMap.__Internal*) __Instance)->value;
            }

            set
            {
                ((global::Raylib.MaterialMap.__Internal*)__Instance)->value = value;
            }
        }
    }

    public unsafe partial class Material : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.Shader.__Internal shader;

            [FieldOffset(16)]
            internal global::System.IntPtr maps;

            [FieldOffset(24)]
            internal global::System.IntPtr @params;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Material@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Material> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Material>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Material __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Material(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Material __CreateInstance(global::Raylib.Material.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Material(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Material.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Material.__Internal));
            *(global::Raylib.Material.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Material(global::Raylib.Material.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Material(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Material()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Material.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Material(global::Raylib.Material _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Material.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Material.__Internal*) __Instance) = *((global::Raylib.Material.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Material __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Shader Shader
        {
            get
            {
                return global::Raylib.Shader.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Material.__Internal*) __Instance)->shader));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Material.__Internal*)__Instance)->shader = *(global::Raylib.Shader.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.MaterialMap Maps
        {
            get
            {
                global::Raylib.MaterialMap __result0;
                if (((global::Raylib.Material.__Internal*) __Instance)->maps == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.MaterialMap.NativeToManagedMap.ContainsKey(((global::Raylib.Material.__Internal*) __Instance)->maps))
                    __result0 = (global::Raylib.MaterialMap) global::Raylib.MaterialMap.NativeToManagedMap[((global::Raylib.Material.__Internal*) __Instance)->maps];
                else __result0 = global::Raylib.MaterialMap.__CreateInstance(((global::Raylib.Material.__Internal*) __Instance)->maps);
                return __result0;
            }

            set
            {
                ((global::Raylib.Material.__Internal*)__Instance)->maps = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public float* Params
        {
            get
            {
                return (float*) ((global::Raylib.Material.__Internal*) __Instance)->@params;
            }

            set
            {
                ((global::Raylib.Material.__Internal*)__Instance)->@params = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class Transform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.Vector3.__Internal translation;

            [FieldOffset(12)]
            internal global::Raylib.Vector4.__Internal rotation;

            [FieldOffset(28)]
            internal global::Raylib.Vector3.__Internal scale;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Transform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Transform>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Transform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Transform(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Transform __CreateInstance(global::Raylib.Transform.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Transform(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Transform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Transform.__Internal));
            *(global::Raylib.Transform.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Transform(global::Raylib.Transform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Transform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Transform()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Transform(global::Raylib.Transform _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Transform.__Internal*) __Instance) = *((global::Raylib.Transform.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Transform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Vector3 Translation
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Transform.__Internal*) __Instance)->translation));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Transform.__Internal*)__Instance)->translation = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector4 Rotation
        {
            get
            {
                return global::Raylib.Vector4.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Transform.__Internal*) __Instance)->rotation));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Transform.__Internal*)__Instance)->rotation = *(global::Raylib.Vector4.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector3 Scale
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Transform.__Internal*) __Instance)->scale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Transform.__Internal*)__Instance)->scale = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class BoneInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed sbyte name[32];

            [FieldOffset(32)]
            internal int parent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0BoneInfo@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.BoneInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.BoneInfo>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.BoneInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.BoneInfo(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.BoneInfo __CreateInstance(global::Raylib.BoneInfo.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.BoneInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.BoneInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.BoneInfo.__Internal));
            *(global::Raylib.BoneInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BoneInfo(global::Raylib.BoneInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BoneInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public BoneInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.BoneInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BoneInfo(global::Raylib.BoneInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.BoneInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.BoneInfo.__Internal*) __Instance) = *((global::Raylib.BoneInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.BoneInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Name
        {
            get
            {
                sbyte[] __value = null;
                if (((global::Raylib.BoneInfo.__Internal*) __Instance)->name != null)
                {
                    __value = new sbyte[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = ((global::Raylib.BoneInfo.__Internal*) __Instance)->name[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((global::Raylib.BoneInfo.__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public int Parent
        {
            get
            {
                return ((global::Raylib.BoneInfo.__Internal*) __Instance)->parent;
            }

            set
            {
                ((global::Raylib.BoneInfo.__Internal*)__Instance)->parent = value;
            }
        }
    }

    public unsafe partial class Model : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.Matrix.__Internal transform;

            [FieldOffset(64)]
            internal int meshCount;

            [FieldOffset(72)]
            internal global::System.IntPtr meshes;

            [FieldOffset(80)]
            internal int materialCount;

            [FieldOffset(88)]
            internal global::System.IntPtr materials;

            [FieldOffset(96)]
            internal global::System.IntPtr meshMaterial;

            [FieldOffset(104)]
            internal int boneCount;

            [FieldOffset(112)]
            internal global::System.IntPtr bones;

            [FieldOffset(120)]
            internal global::System.IntPtr bindPose;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Model@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Model> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Model>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Model __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Model(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Model __CreateInstance(global::Raylib.Model.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Model(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Model.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Model.__Internal));
            *(global::Raylib.Model.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Model(global::Raylib.Model.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Model(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Model()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Model.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Model(global::Raylib.Model _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Model.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Model.__Internal*) __Instance) = *((global::Raylib.Model.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Model __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Matrix Transform
        {
            get
            {
                return global::Raylib.Matrix.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Model.__Internal*) __Instance)->transform));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Model.__Internal*)__Instance)->transform = *(global::Raylib.Matrix.__Internal*) value.__Instance;
            }
        }

        public int MeshCount
        {
            get
            {
                return ((global::Raylib.Model.__Internal*) __Instance)->meshCount;
            }

            set
            {
                ((global::Raylib.Model.__Internal*)__Instance)->meshCount = value;
            }
        }

        public global::Raylib.Mesh Meshes
        {
            get
            {
                global::Raylib.Mesh __result0;
                if (((global::Raylib.Model.__Internal*) __Instance)->meshes == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.Mesh.NativeToManagedMap.ContainsKey(((global::Raylib.Model.__Internal*) __Instance)->meshes))
                    __result0 = (global::Raylib.Mesh) global::Raylib.Mesh.NativeToManagedMap[((global::Raylib.Model.__Internal*) __Instance)->meshes];
                else __result0 = global::Raylib.Mesh.__CreateInstance(((global::Raylib.Model.__Internal*) __Instance)->meshes);
                return __result0;
            }

            set
            {
                ((global::Raylib.Model.__Internal*)__Instance)->meshes = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int MaterialCount
        {
            get
            {
                return ((global::Raylib.Model.__Internal*) __Instance)->materialCount;
            }

            set
            {
                ((global::Raylib.Model.__Internal*)__Instance)->materialCount = value;
            }
        }

        public global::Raylib.Material Materials
        {
            get
            {
                global::Raylib.Material __result0;
                if (((global::Raylib.Model.__Internal*) __Instance)->materials == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.Material.NativeToManagedMap.ContainsKey(((global::Raylib.Model.__Internal*) __Instance)->materials))
                    __result0 = (global::Raylib.Material) global::Raylib.Material.NativeToManagedMap[((global::Raylib.Model.__Internal*) __Instance)->materials];
                else __result0 = global::Raylib.Material.__CreateInstance(((global::Raylib.Model.__Internal*) __Instance)->materials);
                return __result0;
            }

            set
            {
                ((global::Raylib.Model.__Internal*)__Instance)->materials = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int* MeshMaterial
        {
            get
            {
                return (int*) ((global::Raylib.Model.__Internal*) __Instance)->meshMaterial;
            }

            set
            {
                ((global::Raylib.Model.__Internal*)__Instance)->meshMaterial = (global::System.IntPtr) value;
            }
        }

        public int BoneCount
        {
            get
            {
                return ((global::Raylib.Model.__Internal*) __Instance)->boneCount;
            }

            set
            {
                ((global::Raylib.Model.__Internal*)__Instance)->boneCount = value;
            }
        }

        public global::Raylib.BoneInfo Bones
        {
            get
            {
                global::Raylib.BoneInfo __result0;
                if (((global::Raylib.Model.__Internal*) __Instance)->bones == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.BoneInfo.NativeToManagedMap.ContainsKey(((global::Raylib.Model.__Internal*) __Instance)->bones))
                    __result0 = (global::Raylib.BoneInfo) global::Raylib.BoneInfo.NativeToManagedMap[((global::Raylib.Model.__Internal*) __Instance)->bones];
                else __result0 = global::Raylib.BoneInfo.__CreateInstance(((global::Raylib.Model.__Internal*) __Instance)->bones);
                return __result0;
            }

            set
            {
                ((global::Raylib.Model.__Internal*)__Instance)->bones = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::Raylib.Transform BindPose
        {
            get
            {
                global::Raylib.Transform __result0;
                if (((global::Raylib.Model.__Internal*) __Instance)->bindPose == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.Transform.NativeToManagedMap.ContainsKey(((global::Raylib.Model.__Internal*) __Instance)->bindPose))
                    __result0 = (global::Raylib.Transform) global::Raylib.Transform.NativeToManagedMap[((global::Raylib.Model.__Internal*) __Instance)->bindPose];
                else __result0 = global::Raylib.Transform.__CreateInstance(((global::Raylib.Model.__Internal*) __Instance)->bindPose);
                return __result0;
            }

            set
            {
                ((global::Raylib.Model.__Internal*)__Instance)->bindPose = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ModelAnimation : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int boneCount;

            [FieldOffset(8)]
            internal global::System.IntPtr bones;

            [FieldOffset(16)]
            internal int frameCount;

            [FieldOffset(24)]
            internal global::System.IntPtr framePoses;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelAnimation@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.ModelAnimation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.ModelAnimation>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.ModelAnimation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.ModelAnimation(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.ModelAnimation __CreateInstance(global::Raylib.ModelAnimation.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.ModelAnimation(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.ModelAnimation.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.ModelAnimation.__Internal));
            *(global::Raylib.ModelAnimation.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModelAnimation(global::Raylib.ModelAnimation.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModelAnimation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModelAnimation()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.ModelAnimation.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ModelAnimation(global::Raylib.ModelAnimation _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.ModelAnimation.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.ModelAnimation.__Internal*) __Instance) = *((global::Raylib.ModelAnimation.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.ModelAnimation __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int BoneCount
        {
            get
            {
                return ((global::Raylib.ModelAnimation.__Internal*) __Instance)->boneCount;
            }

            set
            {
                ((global::Raylib.ModelAnimation.__Internal*)__Instance)->boneCount = value;
            }
        }

        public global::Raylib.BoneInfo Bones
        {
            get
            {
                global::Raylib.BoneInfo __result0;
                if (((global::Raylib.ModelAnimation.__Internal*) __Instance)->bones == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.BoneInfo.NativeToManagedMap.ContainsKey(((global::Raylib.ModelAnimation.__Internal*) __Instance)->bones))
                    __result0 = (global::Raylib.BoneInfo) global::Raylib.BoneInfo.NativeToManagedMap[((global::Raylib.ModelAnimation.__Internal*) __Instance)->bones];
                else __result0 = global::Raylib.BoneInfo.__CreateInstance(((global::Raylib.ModelAnimation.__Internal*) __Instance)->bones);
                return __result0;
            }

            set
            {
                ((global::Raylib.ModelAnimation.__Internal*)__Instance)->bones = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int FrameCount
        {
            get
            {
                return ((global::Raylib.ModelAnimation.__Internal*) __Instance)->frameCount;
            }

            set
            {
                ((global::Raylib.ModelAnimation.__Internal*)__Instance)->frameCount = value;
            }
        }

        public global::Raylib.Transform FramePoses
        {
            get
            {
                global::Raylib.Transform __result0;
                if (((global::Raylib.ModelAnimation.__Internal*) __Instance)->framePoses == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.Transform.NativeToManagedMap.ContainsKey(((global::Raylib.ModelAnimation.__Internal*) __Instance)->framePoses))
                    __result0 = (global::Raylib.Transform) global::Raylib.Transform.NativeToManagedMap[((global::Raylib.ModelAnimation.__Internal*) __Instance)->framePoses];
                else __result0 = global::Raylib.Transform.__CreateInstance(((global::Raylib.ModelAnimation.__Internal*) __Instance)->framePoses);
                return __result0;
            }

            set
            {
                var __value = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                ((global::Raylib.ModelAnimation.__Internal*)__Instance)->framePoses = new global::System.IntPtr(&__value);
            }
        }
    }

    public unsafe partial class Ray : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.Vector3.__Internal position;

            [FieldOffset(12)]
            internal global::Raylib.Vector3.__Internal direction;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Ray@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Ray> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Ray>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Ray __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Ray(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Ray __CreateInstance(global::Raylib.Ray.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Ray(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Ray.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Ray.__Internal));
            *(global::Raylib.Ray.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Ray(global::Raylib.Ray.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Ray(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Ray()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Ray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Ray(global::Raylib.Ray _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Ray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Ray.__Internal*) __Instance) = *((global::Raylib.Ray.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Ray __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Vector3 Position
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Ray.__Internal*) __Instance)->position));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Ray.__Internal*)__Instance)->position = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector3 Direction
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Ray.__Internal*) __Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Ray.__Internal*)__Instance)->direction = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class RayHitInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte hit;

            [FieldOffset(4)]
            internal float distance;

            [FieldOffset(8)]
            internal global::Raylib.Vector3.__Internal position;

            [FieldOffset(20)]
            internal global::Raylib.Vector3.__Internal normal;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RayHitInfo@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.RayHitInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.RayHitInfo>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.RayHitInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.RayHitInfo(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.RayHitInfo __CreateInstance(global::Raylib.RayHitInfo.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.RayHitInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.RayHitInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.RayHitInfo.__Internal));
            *(global::Raylib.RayHitInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RayHitInfo(global::Raylib.RayHitInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RayHitInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RayHitInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.RayHitInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RayHitInfo(global::Raylib.RayHitInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.RayHitInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.RayHitInfo.__Internal*) __Instance) = *((global::Raylib.RayHitInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.RayHitInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Hit
        {
            get
            {
                return ((global::Raylib.RayHitInfo.__Internal*) __Instance)->hit != 0;
            }

            set
            {
                ((global::Raylib.RayHitInfo.__Internal*)__Instance)->hit = (byte) (value ? 1 : 0);
            }
        }

        public float Distance
        {
            get
            {
                return ((global::Raylib.RayHitInfo.__Internal*) __Instance)->distance;
            }

            set
            {
                ((global::Raylib.RayHitInfo.__Internal*)__Instance)->distance = value;
            }
        }

        public global::Raylib.Vector3 Position
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.RayHitInfo.__Internal*) __Instance)->position));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.RayHitInfo.__Internal*)__Instance)->position = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector3 Normal
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.RayHitInfo.__Internal*) __Instance)->normal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.RayHitInfo.__Internal*)__Instance)->normal = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class BoundingBox : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.Vector3.__Internal min;

            [FieldOffset(12)]
            internal global::Raylib.Vector3.__Internal max;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0BoundingBox@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.BoundingBox> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.BoundingBox>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.BoundingBox __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.BoundingBox(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.BoundingBox __CreateInstance(global::Raylib.BoundingBox.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.BoundingBox(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.BoundingBox.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.BoundingBox.__Internal));
            *(global::Raylib.BoundingBox.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BoundingBox(global::Raylib.BoundingBox.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BoundingBox(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public BoundingBox()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.BoundingBox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BoundingBox(global::Raylib.BoundingBox _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.BoundingBox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.BoundingBox.__Internal*) __Instance) = *((global::Raylib.BoundingBox.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.BoundingBox __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.Vector3 min
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.BoundingBox.__Internal*) __Instance)->min));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.BoundingBox.__Internal*)__Instance)->min = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector3 max
        {
            get
            {
                return global::Raylib.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Raylib.BoundingBox.__Internal*) __Instance)->max));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.BoundingBox.__Internal*)__Instance)->max = *(global::Raylib.Vector3.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class Wave : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint sampleCount;

            [FieldOffset(4)]
            internal uint sampleRate;

            [FieldOffset(8)]
            internal uint sampleSize;

            [FieldOffset(12)]
            internal uint channels;

            [FieldOffset(16)]
            internal global::System.IntPtr data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Wave@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="WaveCopy")]
            internal static extern global::Raylib.Wave.__Internal Copy(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Wave> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Wave>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Wave __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Wave(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Wave __CreateInstance(global::Raylib.Wave.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Wave(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Wave.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Wave.__Internal));
            *(global::Raylib.Wave.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Wave(global::Raylib.Wave.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Wave(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Wave()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Wave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Wave(global::Raylib.Wave _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Wave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Wave.__Internal*) __Instance) = *((global::Raylib.Wave.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Wave __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint SampleCount
        {
            get
            {
                return ((global::Raylib.Wave.__Internal*) __Instance)->sampleCount;
            }

            set
            {
                ((global::Raylib.Wave.__Internal*)__Instance)->sampleCount = value;
            }
        }

        public uint SampleRate
        {
            get
            {
                return ((global::Raylib.Wave.__Internal*) __Instance)->sampleRate;
            }

            set
            {
                ((global::Raylib.Wave.__Internal*)__Instance)->sampleRate = value;
            }
        }

        public uint SampleSize
        {
            get
            {
                return ((global::Raylib.Wave.__Internal*) __Instance)->sampleSize;
            }

            set
            {
                ((global::Raylib.Wave.__Internal*)__Instance)->sampleSize = value;
            }
        }

        public uint Channels
        {
            get
            {
                return ((global::Raylib.Wave.__Internal*) __Instance)->channels;
            }

            set
            {
                ((global::Raylib.Wave.__Internal*)__Instance)->channels = value;
            }
        }

        public global::System.IntPtr Data
        {
            get
            {
                return ((global::Raylib.Wave.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::Raylib.Wave.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }

        public global::Raylib.Wave Copy
        {
            get
            {
                var __ret = __Internal.Copy((__Instance + __PointerAdjustment));
                return global::Raylib.Wave.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class AudioStream : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint sampleRate;

            [FieldOffset(4)]
            internal uint sampleSize;

            [FieldOffset(8)]
            internal uint channels;

            [FieldOffset(16)]
            internal global::System.IntPtr buffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AudioStream@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.AudioStream> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.AudioStream>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.AudioStream __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.AudioStream(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.AudioStream __CreateInstance(global::Raylib.AudioStream.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.AudioStream(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.AudioStream.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.AudioStream.__Internal));
            *(global::Raylib.AudioStream.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioStream(global::Raylib.AudioStream.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AudioStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AudioStream()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.AudioStream.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public AudioStream(global::Raylib.AudioStream _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.AudioStream.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.AudioStream.__Internal*) __Instance) = *((global::Raylib.AudioStream.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.AudioStream __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint SampleRate
        {
            get
            {
                return ((global::Raylib.AudioStream.__Internal*) __Instance)->sampleRate;
            }

            set
            {
                ((global::Raylib.AudioStream.__Internal*)__Instance)->sampleRate = value;
            }
        }

        public uint SampleSize
        {
            get
            {
                return ((global::Raylib.AudioStream.__Internal*) __Instance)->sampleSize;
            }

            set
            {
                ((global::Raylib.AudioStream.__Internal*)__Instance)->sampleSize = value;
            }
        }

        public uint Channels
        {
            get
            {
                return ((global::Raylib.AudioStream.__Internal*) __Instance)->channels;
            }

            set
            {
                ((global::Raylib.AudioStream.__Internal*)__Instance)->channels = value;
            }
        }

        public global::Raylib.RAudioBuffer Buffer
        {
            get
            {
                global::Raylib.RAudioBuffer __result0;
                if (((global::Raylib.AudioStream.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.RAudioBuffer.NativeToManagedMap.ContainsKey(((global::Raylib.AudioStream.__Internal*) __Instance)->buffer))
                    __result0 = (global::Raylib.RAudioBuffer) global::Raylib.RAudioBuffer.NativeToManagedMap[((global::Raylib.AudioStream.__Internal*) __Instance)->buffer];
                else __result0 = global::Raylib.RAudioBuffer.__CreateInstance(((global::Raylib.AudioStream.__Internal*) __Instance)->buffer);
                return __result0;
            }

            set
            {
                ((global::Raylib.AudioStream.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class Sound : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint sampleCount;

            [FieldOffset(8)]
            internal global::Raylib.AudioStream.__Internal stream;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Sound@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Sound> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Sound>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Sound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Sound(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Sound __CreateInstance(global::Raylib.Sound.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Sound(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Sound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Sound.__Internal));
            *(global::Raylib.Sound.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sound(global::Raylib.Sound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sound(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Sound()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Sound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Sound(global::Raylib.Sound _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Sound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Sound.__Internal*) __Instance) = *((global::Raylib.Sound.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Sound __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint SampleCount
        {
            get
            {
                return ((global::Raylib.Sound.__Internal*) __Instance)->sampleCount;
            }

            set
            {
                ((global::Raylib.Sound.__Internal*)__Instance)->sampleCount = value;
            }
        }

        public global::Raylib.AudioStream Stream
        {
            get
            {
                return global::Raylib.AudioStream.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Sound.__Internal*) __Instance)->stream));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Sound.__Internal*)__Instance)->stream = *(global::Raylib.AudioStream.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class Music : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int ctxType;

            [FieldOffset(8)]
            internal global::System.IntPtr ctxData;

            [FieldOffset(16)]
            internal uint sampleCount;

            [FieldOffset(20)]
            internal uint loopCount;

            [FieldOffset(24)]
            internal global::Raylib.AudioStream.__Internal stream;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Music@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Music> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Music>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Music __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Music(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Music __CreateInstance(global::Raylib.Music.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Music(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Music.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Music.__Internal));
            *(global::Raylib.Music.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Music(global::Raylib.Music.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Music(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Music()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Music.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Music(global::Raylib.Music _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Music.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Music.__Internal*) __Instance) = *((global::Raylib.Music.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Music __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int CtxType
        {
            get
            {
                return ((global::Raylib.Music.__Internal*) __Instance)->ctxType;
            }

            set
            {
                ((global::Raylib.Music.__Internal*)__Instance)->ctxType = value;
            }
        }

        public global::System.IntPtr CtxData
        {
            get
            {
                return ((global::Raylib.Music.__Internal*) __Instance)->ctxData;
            }

            set
            {
                ((global::Raylib.Music.__Internal*)__Instance)->ctxData = (global::System.IntPtr) value;
            }
        }

        public uint SampleCount
        {
            get
            {
                return ((global::Raylib.Music.__Internal*) __Instance)->sampleCount;
            }

            set
            {
                ((global::Raylib.Music.__Internal*)__Instance)->sampleCount = value;
            }
        }

        public uint LoopCount
        {
            get
            {
                return ((global::Raylib.Music.__Internal*) __Instance)->loopCount;
            }

            set
            {
                ((global::Raylib.Music.__Internal*)__Instance)->loopCount = value;
            }
        }

        public global::Raylib.AudioStream Stream
        {
            get
            {
                return global::Raylib.AudioStream.__CreateInstance(new global::System.IntPtr(&((global::Raylib.Music.__Internal*) __Instance)->stream));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.Music.__Internal*)__Instance)->stream = *(global::Raylib.AudioStream.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class VrDeviceInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int hResolution;

            [FieldOffset(4)]
            internal int vResolution;

            [FieldOffset(8)]
            internal float hScreenSize;

            [FieldOffset(12)]
            internal float vScreenSize;

            [FieldOffset(16)]
            internal float vScreenCenter;

            [FieldOffset(20)]
            internal float eyeToScreenDistance;

            [FieldOffset(24)]
            internal float lensSeparationDistance;

            [FieldOffset(28)]
            internal float interpupillaryDistance;

            [FieldOffset(32)]
            internal fixed float lensDistortionValues[4];

            [FieldOffset(48)]
            internal fixed float chromaAbCorrection[4];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VrDeviceInfo@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.VrDeviceInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.VrDeviceInfo>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.VrDeviceInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.VrDeviceInfo(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.VrDeviceInfo __CreateInstance(global::Raylib.VrDeviceInfo.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.VrDeviceInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.VrDeviceInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.VrDeviceInfo.__Internal));
            *(global::Raylib.VrDeviceInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VrDeviceInfo(global::Raylib.VrDeviceInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VrDeviceInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VrDeviceInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.VrDeviceInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VrDeviceInfo(global::Raylib.VrDeviceInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.VrDeviceInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.VrDeviceInfo.__Internal*) __Instance) = *((global::Raylib.VrDeviceInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.VrDeviceInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int HResolution
        {
            get
            {
                return ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->hResolution;
            }

            set
            {
                ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->hResolution = value;
            }
        }

        public int VResolution
        {
            get
            {
                return ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->vResolution;
            }

            set
            {
                ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->vResolution = value;
            }
        }

        public float HScreenSize
        {
            get
            {
                return ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->hScreenSize;
            }

            set
            {
                ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->hScreenSize = value;
            }
        }

        public float VScreenSize
        {
            get
            {
                return ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->vScreenSize;
            }

            set
            {
                ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->vScreenSize = value;
            }
        }

        public float VScreenCenter
        {
            get
            {
                return ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->vScreenCenter;
            }

            set
            {
                ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->vScreenCenter = value;
            }
        }

        public float EyeToScreenDistance
        {
            get
            {
                return ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->eyeToScreenDistance;
            }

            set
            {
                ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->eyeToScreenDistance = value;
            }
        }

        public float LensSeparationDistance
        {
            get
            {
                return ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->lensSeparationDistance;
            }

            set
            {
                ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->lensSeparationDistance = value;
            }
        }

        public float InterpupillaryDistance
        {
            get
            {
                return ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->interpupillaryDistance;
            }

            set
            {
                ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->interpupillaryDistance = value;
            }
        }

        public float[] LensDistortionValues
        {
            get
            {
                float[] __value = null;
                if (((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->lensDistortionValues != null)
                {
                    __value = new float[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->lensDistortionValues[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->lensDistortionValues[i] = value[i];
                }
            }
        }

        public float[] ChromaAbCorrection
        {
            get
            {
                float[] __value = null;
                if (((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->chromaAbCorrection != null)
                {
                    __value = new float[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = ((global::Raylib.VrDeviceInfo.__Internal*) __Instance)->chromaAbCorrection[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((global::Raylib.VrDeviceInfo.__Internal*)__Instance)->chromaAbCorrection[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class Raylib
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="InitWindow")]
            internal static extern void InitWindow(int width, int height, [MarshalAs(UnmanagedType.LPStr)] string title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="WindowShouldClose")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool WindowShouldClose();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CloseWindow")]
            internal static extern void CloseWindow();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsWindowReady")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowReady();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsWindowMinimized")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowMinimized();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsWindowResized")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowResized();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsWindowHidden")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowHidden();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ToggleFullscreen")]
            internal static extern void ToggleFullscreen();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnhideWindow")]
            internal static extern void UnhideWindow();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="HideWindow")]
            internal static extern void HideWindow();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetWindowIcon")]
            internal static extern void SetWindowIcon(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetWindowTitle")]
            internal static extern void SetWindowTitle([MarshalAs(UnmanagedType.LPStr)] string title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetWindowPosition")]
            internal static extern void SetWindowPosition(int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetWindowMonitor")]
            internal static extern void SetWindowMonitor(int monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetWindowMinSize")]
            internal static extern void SetWindowMinSize(int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetWindowSize")]
            internal static extern void SetWindowSize(int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetWindowHandle")]
            internal static extern global::System.IntPtr GetWindowHandle();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetScreenWidth")]
            internal static extern int GetScreenWidth();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetScreenHeight")]
            internal static extern int GetScreenHeight();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMonitorCount")]
            internal static extern int GetMonitorCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMonitorWidth")]
            internal static extern int GetMonitorWidth(int monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMonitorHeight")]
            internal static extern int GetMonitorHeight(int monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMonitorPhysicalWidth")]
            internal static extern int GetMonitorPhysicalWidth(int monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMonitorPhysicalHeight")]
            internal static extern int GetMonitorPhysicalHeight(int monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetWindowPosition")]
            internal static extern global::Raylib.Vector2.__Internal GetWindowPosition();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMonitorName")]
            internal static extern global::System.IntPtr GetMonitorName(int monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetClipboardText")]
            internal static extern global::System.IntPtr GetClipboardText();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetClipboardText")]
            internal static extern void SetClipboardText([MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ShowCursor")]
            internal static extern void ShowCursor();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="HideCursor")]
            internal static extern void HideCursor();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsCursorHidden")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsCursorHidden();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="EnableCursor")]
            internal static extern void EnableCursor();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DisableCursor")]
            internal static extern void DisableCursor();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ClearBackground")]
            internal static extern void ClearBackground(global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="BeginDrawing")]
            internal static extern void BeginDrawing();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="EndDrawing")]
            internal static extern void EndDrawing();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="BeginMode2D")]
            internal static extern void BeginMode2D(global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="EndMode2D")]
            internal static extern void EndMode2D();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="BeginMode3D")]
            internal static extern void BeginMode3D(global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="EndMode3D")]
            internal static extern void EndMode3D();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="BeginTextureMode")]
            internal static extern void BeginTextureMode(global::System.IntPtr target);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="EndTextureMode")]
            internal static extern void EndTextureMode();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="BeginScissorMode")]
            internal static extern void BeginScissorMode(int x, int y, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="EndScissorMode")]
            internal static extern void EndScissorMode();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMouseRay")]
            internal static extern void GetMouseRay(global::System.IntPtr @return, global::Raylib.Vector2.__Internal mousePosition, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetCameraMatrix")]
            internal static extern void GetCameraMatrix(global::System.IntPtr @return, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetCameraMatrix2D")]
            internal static extern void GetCameraMatrix2D(global::System.IntPtr @return, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetWorldToScreen")]
            internal static extern global::Raylib.Vector2.__Internal GetWorldToScreen(global::System.IntPtr position, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetWorldToScreen2D")]
            internal static extern global::Raylib.Vector2.__Internal GetWorldToScreen2D(global::Raylib.Vector2.__Internal position, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetScreenToWorld2D")]
            internal static extern global::Raylib.Vector2.__Internal GetScreenToWorld2D(global::Raylib.Vector2.__Internal position, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetTargetFPS")]
            internal static extern void SetTargetFPS(int fps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetFPS")]
            internal static extern int GetFPS();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetFrameTime")]
            internal static extern float GetFrameTime();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetTime")]
            internal static extern double GetTime();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ColorFromHSV")]
            internal static extern global::Raylib.Color.__Internal ColorFromHSV(global::System.IntPtr hsv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetColor")]
            internal static extern global::Raylib.Color.__Internal GetColor(int hexValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="Fade")]
            internal static extern global::Raylib.Color.__Internal Fade(global::Raylib.Color.__Internal color, float alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetConfigFlags")]
            internal static extern void SetConfigFlags(uint flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetTraceLogLevel")]
            internal static extern void SetTraceLogLevel(int logType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetTraceLogExit")]
            internal static extern void SetTraceLogExit(int logType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TraceLog")]
            internal static extern void TraceLog(int logType, [MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TakeScreenshot")]
            internal static extern void TakeScreenshot([MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetRandomValue")]
            internal static extern int GetRandomValue(int min, int max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FileExists")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool FileExists([MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsFileExtension")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFileExtension([MarshalAs(UnmanagedType.LPStr)] string fileName, [MarshalAs(UnmanagedType.LPStr)] string ext);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DirectoryExists")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DirectoryExists([MarshalAs(UnmanagedType.LPStr)] string dirPath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetExtension")]
            internal static extern global::System.IntPtr GetExtension([MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetFileName")]
            internal static extern global::System.IntPtr GetFileName([MarshalAs(UnmanagedType.LPStr)] string filePath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetFileNameWithoutExt")]
            internal static extern global::System.IntPtr GetFileNameWithoutExt([MarshalAs(UnmanagedType.LPStr)] string filePath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetDirectoryPath")]
            internal static extern global::System.IntPtr GetDirectoryPath([MarshalAs(UnmanagedType.LPStr)] string filePath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetPrevDirectoryPath")]
            internal static extern global::System.IntPtr GetPrevDirectoryPath([MarshalAs(UnmanagedType.LPStr)] string dirPath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetWorkingDirectory")]
            internal static extern global::System.IntPtr GetWorkingDirectory();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetDirectoryFiles")]
            internal static extern sbyte** GetDirectoryFiles([MarshalAs(UnmanagedType.LPStr)] string dirPath, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ClearDirectoryFiles")]
            internal static extern void ClearDirectoryFiles();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ChangeDirectory")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ChangeDirectory([MarshalAs(UnmanagedType.LPStr)] string dir);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsFileDropped")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFileDropped();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetDroppedFiles")]
            internal static extern sbyte** GetDroppedFiles(int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ClearDroppedFiles")]
            internal static extern void ClearDroppedFiles();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetFileModTime")]
            internal static extern int GetFileModTime([MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CompressData")]
            internal static extern byte* CompressData(byte* data, int dataLength, int* compDataLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DecompressData")]
            internal static extern byte* DecompressData(byte* compData, int compDataLength, int* dataLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="StorageSaveValue")]
            internal static extern void StorageSaveValue(int position, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="StorageLoadValue")]
            internal static extern int StorageLoadValue(int position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="OpenURL")]
            internal static extern void OpenURL([MarshalAs(UnmanagedType.LPStr)] string url);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsKeyPressed")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsKeyPressed(int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsKeyDown")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsKeyDown(int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsKeyReleased")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsKeyReleased(int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsKeyUp")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsKeyUp(int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetKeyPressed")]
            internal static extern int GetKeyPressed();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetExitKey")]
            internal static extern void SetExitKey(int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsGamepadAvailable")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGamepadAvailable(int gamepad);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsGamepadName")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGamepadName(int gamepad, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGamepadName")]
            internal static extern global::System.IntPtr GetGamepadName(int gamepad);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsGamepadButtonPressed")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGamepadButtonPressed(int gamepad, int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsGamepadButtonDown")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGamepadButtonDown(int gamepad, int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsGamepadButtonReleased")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGamepadButtonReleased(int gamepad, int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsGamepadButtonUp")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGamepadButtonUp(int gamepad, int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGamepadButtonPressed")]
            internal static extern int GetGamepadButtonPressed();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGamepadAxisCount")]
            internal static extern int GetGamepadAxisCount(int gamepad);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGamepadAxisMovement")]
            internal static extern float GetGamepadAxisMovement(int gamepad, int axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsMouseButtonPressed")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseButtonPressed(int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsMouseButtonDown")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseButtonDown(int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsMouseButtonReleased")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseButtonReleased(int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsMouseButtonUp")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseButtonUp(int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMouseX")]
            internal static extern int GetMouseX();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMouseY")]
            internal static extern int GetMouseY();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMousePosition")]
            internal static extern global::Raylib.Vector2.__Internal GetMousePosition();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMousePosition")]
            internal static extern void SetMousePosition(int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMouseOffset")]
            internal static extern void SetMouseOffset(int offsetX, int offsetY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMouseScale")]
            internal static extern void SetMouseScale(float scaleX, float scaleY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMouseWheelMove")]
            internal static extern int GetMouseWheelMove();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetTouchX")]
            internal static extern int GetTouchX();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetTouchY")]
            internal static extern int GetTouchY();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetTouchPosition")]
            internal static extern global::Raylib.Vector2.__Internal GetTouchPosition(int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetGesturesEnabled")]
            internal static extern void SetGesturesEnabled(uint gestureFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsGestureDetected")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGestureDetected(int gesture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGestureDetected")]
            internal static extern int GetGestureDetected();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetTouchPointsCount")]
            internal static extern int GetTouchPointsCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGestureHoldDuration")]
            internal static extern float GetGestureHoldDuration();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGestureDragVector")]
            internal static extern global::Raylib.Vector2.__Internal GetGestureDragVector();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGestureDragAngle")]
            internal static extern float GetGestureDragAngle();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGesturePinchVector")]
            internal static extern global::Raylib.Vector2.__Internal GetGesturePinchVector();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGesturePinchAngle")]
            internal static extern float GetGesturePinchAngle();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetCameraMode")]
            internal static extern void SetCameraMode(global::System.IntPtr camera, int mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UpdateCamera")]
            internal static extern void UpdateCamera(global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetCameraPanControl")]
            internal static extern void SetCameraPanControl(int panKey);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetCameraAltControl")]
            internal static extern void SetCameraAltControl(int altKey);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetCameraSmoothZoomControl")]
            internal static extern void SetCameraSmoothZoomControl(int szKey);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetCameraMoveControls")]
            internal static extern void SetCameraMoveControls(int frontKey, int backKey, int rightKey, int leftKey, int upKey, int downKey);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawPixel")]
            internal static extern void DrawPixel(int posX, int posY, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawPixelV")]
            internal static extern void DrawPixelV(global::Raylib.Vector2.__Internal position, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawLine")]
            internal static extern void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawLineV")]
            internal static extern void DrawLineV(global::Raylib.Vector2.__Internal startPos, global::Raylib.Vector2.__Internal endPos, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawLineEx")]
            internal static extern void DrawLineEx(global::Raylib.Vector2.__Internal startPos, global::Raylib.Vector2.__Internal endPos, float thick, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawLineBezier")]
            internal static extern void DrawLineBezier(global::Raylib.Vector2.__Internal startPos, global::Raylib.Vector2.__Internal endPos, float thick, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawLineStrip")]
            internal static extern void DrawLineStrip(global::System.IntPtr points, int numPoints, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCircle")]
            internal static extern void DrawCircle(int centerX, int centerY, float radius, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCircleSector")]
            internal static extern void DrawCircleSector(global::Raylib.Vector2.__Internal center, float radius, int startAngle, int endAngle, int segments, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCircleSectorLines")]
            internal static extern void DrawCircleSectorLines(global::Raylib.Vector2.__Internal center, float radius, int startAngle, int endAngle, int segments, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCircleGradient")]
            internal static extern void DrawCircleGradient(int centerX, int centerY, float radius, global::Raylib.Color.__Internal color1, global::Raylib.Color.__Internal color2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCircleV")]
            internal static extern void DrawCircleV(global::Raylib.Vector2.__Internal center, float radius, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCircleLines")]
            internal static extern void DrawCircleLines(int centerX, int centerY, float radius, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRing")]
            internal static extern void DrawRing(global::Raylib.Vector2.__Internal center, float innerRadius, float outerRadius, int startAngle, int endAngle, int segments, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRingLines")]
            internal static extern void DrawRingLines(global::Raylib.Vector2.__Internal center, float innerRadius, float outerRadius, int startAngle, int endAngle, int segments, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangle")]
            internal static extern void DrawRectangle(int posX, int posY, int width, int height, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangleV")]
            internal static extern void DrawRectangleV(global::Raylib.Vector2.__Internal position, global::Raylib.Vector2.__Internal size, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangleRec")]
            internal static extern void DrawRectangleRec(global::System.IntPtr rec, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectanglePro")]
            internal static extern void DrawRectanglePro(global::System.IntPtr rec, global::Raylib.Vector2.__Internal origin, float rotation, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangleGradientV")]
            internal static extern void DrawRectangleGradientV(int posX, int posY, int width, int height, global::Raylib.Color.__Internal color1, global::Raylib.Color.__Internal color2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangleGradientH")]
            internal static extern void DrawRectangleGradientH(int posX, int posY, int width, int height, global::Raylib.Color.__Internal color1, global::Raylib.Color.__Internal color2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangleGradientEx")]
            internal static extern void DrawRectangleGradientEx(global::System.IntPtr rec, global::Raylib.Color.__Internal col1, global::Raylib.Color.__Internal col2, global::Raylib.Color.__Internal col3, global::Raylib.Color.__Internal col4);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangleLines")]
            internal static extern void DrawRectangleLines(int posX, int posY, int width, int height, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangleLinesEx")]
            internal static extern void DrawRectangleLinesEx(global::System.IntPtr rec, int lineThick, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangleRounded")]
            internal static extern void DrawRectangleRounded(global::System.IntPtr rec, float roundness, int segments, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRectangleRoundedLines")]
            internal static extern void DrawRectangleRoundedLines(global::System.IntPtr rec, float roundness, int segments, int lineThick, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTriangle")]
            internal static extern void DrawTriangle(global::Raylib.Vector2.__Internal v1, global::Raylib.Vector2.__Internal v2, global::Raylib.Vector2.__Internal v3, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTriangleLines")]
            internal static extern void DrawTriangleLines(global::Raylib.Vector2.__Internal v1, global::Raylib.Vector2.__Internal v2, global::Raylib.Vector2.__Internal v3, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTriangleFan")]
            internal static extern void DrawTriangleFan(global::System.IntPtr points, int numPoints, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTriangleStrip")]
            internal static extern void DrawTriangleStrip(global::System.IntPtr points, int pointsCount, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawPoly")]
            internal static extern void DrawPoly(global::Raylib.Vector2.__Internal center, int sides, float radius, float rotation, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetShapesTexture")]
            internal static extern void SetShapesTexture(global::System.IntPtr texture, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionRecs")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionRecs(global::System.IntPtr rec1, global::System.IntPtr rec2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionCircles")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionCircles(global::Raylib.Vector2.__Internal center1, float radius1, global::Raylib.Vector2.__Internal center2, float radius2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionCircleRec")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionCircleRec(global::Raylib.Vector2.__Internal center, float radius, global::System.IntPtr rec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetCollisionRec")]
            internal static extern void GetCollisionRec(global::System.IntPtr @return, global::System.IntPtr rec1, global::System.IntPtr rec2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionPointRec")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionPointRec(global::Raylib.Vector2.__Internal point, global::System.IntPtr rec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionPointCircle")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionPointCircle(global::Raylib.Vector2.__Internal point, global::Raylib.Vector2.__Internal center, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionPointTriangle")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionPointTriangle(global::Raylib.Vector2.__Internal point, global::Raylib.Vector2.__Internal p1, global::Raylib.Vector2.__Internal p2, global::Raylib.Vector2.__Internal p3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadImage")]
            internal static extern void LoadImage(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadImageEx")]
            internal static extern void LoadImageEx(global::System.IntPtr @return, global::System.IntPtr pixels, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadImagePro")]
            internal static extern void LoadImagePro(global::System.IntPtr @return, global::System.IntPtr data, int width, int height, int format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadImageRaw")]
            internal static extern void LoadImageRaw(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string fileName, int width, int height, int format, int headerSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ExportImage")]
            internal static extern void ExportImage(global::System.IntPtr image, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ExportImageAsCode")]
            internal static extern void ExportImageAsCode(global::System.IntPtr image, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadTexture")]
            internal static extern void LoadTexture(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadTextureFromImage")]
            internal static extern void LoadTextureFromImage(global::System.IntPtr @return, global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadTextureCubemap")]
            internal static extern void LoadTextureCubemap(global::System.IntPtr @return, global::System.IntPtr image, int layoutType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadRenderTexture")]
            internal static extern void LoadRenderTexture(global::System.IntPtr @return, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadImage")]
            internal static extern void UnloadImage(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadTexture")]
            internal static extern void UnloadTexture(global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadRenderTexture")]
            internal static extern void UnloadRenderTexture(global::System.IntPtr target);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetImageData")]
            internal static extern global::System.IntPtr GetImageData(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetImageDataNormalized")]
            internal static extern global::System.IntPtr GetImageDataNormalized(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetImageAlphaBorder")]
            internal static extern void GetImageAlphaBorder(global::System.IntPtr @return, global::System.IntPtr image, float threshold);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetPixelDataSize")]
            internal static extern int GetPixelDataSize(int width, int height, int format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetTextureData")]
            internal static extern void GetTextureData(global::System.IntPtr @return, global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetScreenData")]
            internal static extern void GetScreenData(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UpdateTexture")]
            internal static extern void UpdateTexture(global::System.IntPtr texture, global::System.IntPtr pixels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageToPOT")]
            internal static extern void ImageToPOT(global::System.IntPtr image, global::Raylib.Color.__Internal fillColor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageFormat")]
            internal static extern void ImageFormat(global::System.IntPtr image, int newFormat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageAlphaMask")]
            internal static extern void ImageAlphaMask(global::System.IntPtr image, global::System.IntPtr alphaMask);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageAlphaClear")]
            internal static extern void ImageAlphaClear(global::System.IntPtr image, global::Raylib.Color.__Internal color, float threshold);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageAlphaCrop")]
            internal static extern void ImageAlphaCrop(global::System.IntPtr image, float threshold);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageAlphaPremultiply")]
            internal static extern void ImageAlphaPremultiply(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageCrop")]
            internal static extern void ImageCrop(global::System.IntPtr image, global::System.IntPtr crop);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageResize")]
            internal static extern void ImageResize(global::System.IntPtr image, int newWidth, int newHeight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageResizeNN")]
            internal static extern void ImageResizeNN(global::System.IntPtr image, int newWidth, int newHeight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageResizeCanvas")]
            internal static extern void ImageResizeCanvas(global::System.IntPtr image, int newWidth, int newHeight, int offsetX, int offsetY, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageMipmaps")]
            internal static extern void ImageMipmaps(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageDither")]
            internal static extern void ImageDither(global::System.IntPtr image, int rBpp, int gBpp, int bBpp, int aBpp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageText")]
            internal static extern void ImageText(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string text, int fontSize, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageTextEx")]
            internal static extern void ImageTextEx(global::System.IntPtr @return, global::System.IntPtr font, [MarshalAs(UnmanagedType.LPStr)] string text, float fontSize, float spacing, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageDraw")]
            internal static extern void ImageDraw(global::System.IntPtr dst, global::System.IntPtr src, global::System.IntPtr srcRec, global::System.IntPtr dstRec, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageDrawRectangle")]
            internal static extern void ImageDrawRectangle(global::System.IntPtr dst, global::System.IntPtr rec, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageDrawRectangleLines")]
            internal static extern void ImageDrawRectangleLines(global::System.IntPtr dst, global::System.IntPtr rec, int thick, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageDrawText")]
            internal static extern void ImageDrawText(global::System.IntPtr dst, global::Raylib.Vector2.__Internal position, [MarshalAs(UnmanagedType.LPStr)] string text, int fontSize, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageDrawTextEx")]
            internal static extern void ImageDrawTextEx(global::System.IntPtr dst, global::Raylib.Vector2.__Internal position, global::System.IntPtr font, [MarshalAs(UnmanagedType.LPStr)] string text, float fontSize, float spacing, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageFlipVertical")]
            internal static extern void ImageFlipVertical(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageFlipHorizontal")]
            internal static extern void ImageFlipHorizontal(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageRotateCW")]
            internal static extern void ImageRotateCW(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageRotateCCW")]
            internal static extern void ImageRotateCCW(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageColorTint")]
            internal static extern void ImageColorTint(global::System.IntPtr image, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageColorInvert")]
            internal static extern void ImageColorInvert(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageColorGrayscale")]
            internal static extern void ImageColorGrayscale(global::System.IntPtr image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageColorContrast")]
            internal static extern void ImageColorContrast(global::System.IntPtr image, float contrast);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageColorBrightness")]
            internal static extern void ImageColorBrightness(global::System.IntPtr image, int brightness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImageColorReplace")]
            internal static extern void ImageColorReplace(global::System.IntPtr image, global::Raylib.Color.__Internal color, global::Raylib.Color.__Internal replace);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenImageColor")]
            internal static extern void GenImageColor(global::System.IntPtr @return, int width, int height, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenImageGradientV")]
            internal static extern void GenImageGradientV(global::System.IntPtr @return, int width, int height, global::Raylib.Color.__Internal top, global::Raylib.Color.__Internal bottom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenImageGradientH")]
            internal static extern void GenImageGradientH(global::System.IntPtr @return, int width, int height, global::Raylib.Color.__Internal left, global::Raylib.Color.__Internal right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenImageGradientRadial")]
            internal static extern void GenImageGradientRadial(global::System.IntPtr @return, int width, int height, float density, global::Raylib.Color.__Internal inner, global::Raylib.Color.__Internal outer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenImageChecked")]
            internal static extern void GenImageChecked(global::System.IntPtr @return, int width, int height, int checksX, int checksY, global::Raylib.Color.__Internal col1, global::Raylib.Color.__Internal col2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenImageWhiteNoise")]
            internal static extern void GenImageWhiteNoise(global::System.IntPtr @return, int width, int height, float factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenImagePerlinNoise")]
            internal static extern void GenImagePerlinNoise(global::System.IntPtr @return, int width, int height, int offsetX, int offsetY, float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenImageCellular")]
            internal static extern void GenImageCellular(global::System.IntPtr @return, int width, int height, int tileSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenTextureMipmaps")]
            internal static extern void GenTextureMipmaps(global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetTextureFilter")]
            internal static extern void SetTextureFilter(global::System.IntPtr texture, int filterMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetTextureWrap")]
            internal static extern void SetTextureWrap(global::System.IntPtr texture, int wrapMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTexture")]
            internal static extern void DrawTexture(global::System.IntPtr texture, int posX, int posY, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTextureV")]
            internal static extern void DrawTextureV(global::System.IntPtr texture, global::Raylib.Vector2.__Internal position, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTextureEx")]
            internal static extern void DrawTextureEx(global::System.IntPtr texture, global::Raylib.Vector2.__Internal position, float rotation, float scale, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTextureRec")]
            internal static extern void DrawTextureRec(global::System.IntPtr texture, global::System.IntPtr sourceRec, global::Raylib.Vector2.__Internal position, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTextureQuad")]
            internal static extern void DrawTextureQuad(global::System.IntPtr texture, global::Raylib.Vector2.__Internal tiling, global::Raylib.Vector2.__Internal offset, global::System.IntPtr quad, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTexturePro")]
            internal static extern void DrawTexturePro(global::System.IntPtr texture, global::System.IntPtr sourceRec, global::System.IntPtr destRec, global::Raylib.Vector2.__Internal origin, float rotation, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTextureNPatch")]
            internal static extern void DrawTextureNPatch(global::System.IntPtr texture, global::System.IntPtr nPatchInfo, global::System.IntPtr destRec, global::Raylib.Vector2.__Internal origin, float rotation, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetFontDefault")]
            internal static extern void GetFontDefault(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadFont")]
            internal static extern void LoadFont(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadFontEx")]
            internal static extern void LoadFontEx(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string fileName, int fontSize, int* fontChars, int charsCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadFontFromImage")]
            internal static extern void LoadFontFromImage(global::System.IntPtr @return, global::System.IntPtr image, global::Raylib.Color.__Internal key, int firstChar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadFontData")]
            internal static extern global::System.IntPtr LoadFontData([MarshalAs(UnmanagedType.LPStr)] string fileName, int fontSize, int* fontChars, int charsCount, int type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenImageFontAtlas")]
            internal static extern void GenImageFontAtlas(global::System.IntPtr @return, global::System.IntPtr chars, global::System.IntPtr recs, int charsCount, int fontSize, int padding, int packMethod);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadFont")]
            internal static extern void UnloadFont(global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawFPS")]
            internal static extern void DrawFPS(int posX, int posY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawText")]
            internal static extern void DrawText([MarshalAs(UnmanagedType.LPStr)] string text, int posX, int posY, int fontSize, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTextEx")]
            internal static extern void DrawTextEx(global::System.IntPtr font, [MarshalAs(UnmanagedType.LPStr)] string text, global::Raylib.Vector2.__Internal position, float fontSize, float spacing, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTextRec")]
            internal static extern void DrawTextRec(global::System.IntPtr font, [MarshalAs(UnmanagedType.LPStr)] string text, global::System.IntPtr rec, float fontSize, float spacing, bool wordWrap, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawTextRecEx")]
            internal static extern void DrawTextRecEx(global::System.IntPtr font, [MarshalAs(UnmanagedType.LPStr)] string text, global::System.IntPtr rec, float fontSize, float spacing, bool wordWrap, global::Raylib.Color.__Internal tint, int selectStart, int selectLength, global::Raylib.Color.__Internal selectText, global::Raylib.Color.__Internal selectBack);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="MeasureText")]
            internal static extern int MeasureText([MarshalAs(UnmanagedType.LPStr)] string text, int fontSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="MeasureTextEx")]
            internal static extern global::Raylib.Vector2.__Internal MeasureTextEx(global::System.IntPtr font, [MarshalAs(UnmanagedType.LPStr)] string text, float fontSize, float spacing);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetGlyphIndex")]
            internal static extern int GetGlyphIndex(global::System.IntPtr font, int character);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetNextCodepoint")]
            internal static extern int GetNextCodepoint([MarshalAs(UnmanagedType.LPStr)] string text, int* bytesProcessed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetCodepoints")]
            internal static extern int* GetCodepoints([MarshalAs(UnmanagedType.LPStr)] string text, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextIsEqual")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TextIsEqual([MarshalAs(UnmanagedType.LPStr)] string text1, [MarshalAs(UnmanagedType.LPStr)] string text2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextLength")]
            internal static extern uint TextLength([MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextCountCodepoints")]
            internal static extern uint TextCountCodepoints([MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextFormat")]
            internal static extern global::System.IntPtr TextFormat([MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextSubtext")]
            internal static extern global::System.IntPtr TextSubtext([MarshalAs(UnmanagedType.LPStr)] string text, int position, int length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextReplace")]
            internal static extern sbyte* TextReplace(sbyte* text, [MarshalAs(UnmanagedType.LPStr)] string replace, [MarshalAs(UnmanagedType.LPStr)] string by);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextInsert")]
            internal static extern sbyte* TextInsert([MarshalAs(UnmanagedType.LPStr)] string text, [MarshalAs(UnmanagedType.LPStr)] string insert, int position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextJoin")]
            internal static extern global::System.IntPtr TextJoin(sbyte** textList, int count, [MarshalAs(UnmanagedType.LPStr)] string delimiter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextSplit")]
            internal static extern sbyte** TextSplit([MarshalAs(UnmanagedType.LPStr)] string text, sbyte delimiter, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextAppend")]
            internal static extern void TextAppend(sbyte* text, [MarshalAs(UnmanagedType.LPStr)] string append, int* position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextFindIndex")]
            internal static extern int TextFindIndex([MarshalAs(UnmanagedType.LPStr)] string text, [MarshalAs(UnmanagedType.LPStr)] string find);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextToUpper")]
            internal static extern global::System.IntPtr TextToUpper([MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextToLower")]
            internal static extern global::System.IntPtr TextToLower([MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextToPascal")]
            internal static extern global::System.IntPtr TextToPascal([MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="TextToInteger")]
            internal static extern int TextToInteger([MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawLine3D")]
            internal static extern void DrawLine3D(global::System.IntPtr startPos, global::System.IntPtr endPos, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCircle3D")]
            internal static extern void DrawCircle3D(global::System.IntPtr center, float radius, global::System.IntPtr rotationAxis, float rotationAngle, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCube")]
            internal static extern void DrawCube(global::System.IntPtr position, float width, float height, float length, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCubeV")]
            internal static extern void DrawCubeV(global::System.IntPtr position, global::System.IntPtr size, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCubeWires")]
            internal static extern void DrawCubeWires(global::System.IntPtr position, float width, float height, float length, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCubeWiresV")]
            internal static extern void DrawCubeWiresV(global::System.IntPtr position, global::System.IntPtr size, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCubeTexture")]
            internal static extern void DrawCubeTexture(global::System.IntPtr texture, global::System.IntPtr position, float width, float height, float length, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawSphere")]
            internal static extern void DrawSphere(global::System.IntPtr centerPos, float radius, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawSphereEx")]
            internal static extern void DrawSphereEx(global::System.IntPtr centerPos, float radius, int rings, int slices, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawSphereWires")]
            internal static extern void DrawSphereWires(global::System.IntPtr centerPos, float radius, int rings, int slices, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCylinder")]
            internal static extern void DrawCylinder(global::System.IntPtr position, float radiusTop, float radiusBottom, float height, int slices, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawCylinderWires")]
            internal static extern void DrawCylinderWires(global::System.IntPtr position, float radiusTop, float radiusBottom, float height, int slices, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawPlane")]
            internal static extern void DrawPlane(global::System.IntPtr centerPos, global::Raylib.Vector2.__Internal size, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawRay")]
            internal static extern void DrawRay(global::System.IntPtr ray, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawGrid")]
            internal static extern void DrawGrid(int slices, float spacing);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawGizmo")]
            internal static extern void DrawGizmo(global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadModel")]
            internal static extern void LoadModel(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadModelFromMesh")]
            internal static extern void LoadModelFromMesh(global::System.IntPtr @return, global::System.IntPtr mesh);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadModel")]
            internal static extern void UnloadModel(global::System.IntPtr model);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadMeshes")]
            internal static extern global::System.IntPtr LoadMeshes([MarshalAs(UnmanagedType.LPStr)] string fileName, int* meshCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ExportMesh")]
            internal static extern void ExportMesh(global::System.IntPtr mesh, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadMesh")]
            internal static extern void UnloadMesh(global::System.IntPtr mesh);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadMaterials")]
            internal static extern global::System.IntPtr LoadMaterials([MarshalAs(UnmanagedType.LPStr)] string fileName, int* materialCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadMaterialDefault")]
            internal static extern void LoadMaterialDefault(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadMaterial")]
            internal static extern void UnloadMaterial(global::System.IntPtr material);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMaterialTexture")]
            internal static extern void SetMaterialTexture(global::System.IntPtr material, int mapType, global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetModelMeshMaterial")]
            internal static extern void SetModelMeshMaterial(global::System.IntPtr model, int meshId, int materialId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadModelAnimations")]
            internal static extern global::System.IntPtr LoadModelAnimations([MarshalAs(UnmanagedType.LPStr)] string fileName, int* animsCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UpdateModelAnimation")]
            internal static extern void UpdateModelAnimation(global::System.IntPtr model, global::System.IntPtr anim, int frame);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadModelAnimation")]
            internal static extern void UnloadModelAnimation(global::System.IntPtr anim);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsModelAnimationValid")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsModelAnimationValid(global::System.IntPtr model, global::System.IntPtr anim);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshPoly")]
            internal static extern void GenMeshPoly(global::System.IntPtr @return, int sides, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshPlane")]
            internal static extern void GenMeshPlane(global::System.IntPtr @return, float width, float length, int resX, int resZ);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshCube")]
            internal static extern void GenMeshCube(global::System.IntPtr @return, float width, float height, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshSphere")]
            internal static extern void GenMeshSphere(global::System.IntPtr @return, float radius, int rings, int slices);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshHemiSphere")]
            internal static extern void GenMeshHemiSphere(global::System.IntPtr @return, float radius, int rings, int slices);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshCylinder")]
            internal static extern void GenMeshCylinder(global::System.IntPtr @return, float radius, float height, int slices);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshTorus")]
            internal static extern void GenMeshTorus(global::System.IntPtr @return, float radius, float size, int radSeg, int sides);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshKnot")]
            internal static extern void GenMeshKnot(global::System.IntPtr @return, float radius, float size, int radSeg, int sides);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshHeightmap")]
            internal static extern void GenMeshHeightmap(global::System.IntPtr @return, global::System.IntPtr heightmap, global::System.IntPtr size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenMeshCubicmap")]
            internal static extern void GenMeshCubicmap(global::System.IntPtr @return, global::System.IntPtr cubicmap, global::System.IntPtr cubeSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="MeshTangents")]
            internal static extern void MeshTangents(global::System.IntPtr mesh);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="MeshBinormals")]
            internal static extern void MeshBinormals(global::System.IntPtr mesh);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawModel")]
            internal static extern void DrawModel(global::System.IntPtr model, global::System.IntPtr position, float scale, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawModelEx")]
            internal static extern void DrawModelEx(global::System.IntPtr model, global::System.IntPtr position, global::System.IntPtr rotationAxis, float rotationAngle, global::System.IntPtr scale, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawModelWires")]
            internal static extern void DrawModelWires(global::System.IntPtr model, global::System.IntPtr position, float scale, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawModelWiresEx")]
            internal static extern void DrawModelWiresEx(global::System.IntPtr model, global::System.IntPtr position, global::System.IntPtr rotationAxis, float rotationAngle, global::System.IntPtr scale, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawBoundingBox")]
            internal static extern void DrawBoundingBox(global::System.IntPtr box, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawBillboard")]
            internal static extern void DrawBillboard(global::System.IntPtr camera, global::System.IntPtr texture, global::System.IntPtr center, float size, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DrawBillboardRec")]
            internal static extern void DrawBillboardRec(global::System.IntPtr camera, global::System.IntPtr texture, global::System.IntPtr sourceRec, global::System.IntPtr center, float size, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionSpheres")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionSpheres(global::System.IntPtr centerA, float radiusA, global::System.IntPtr centerB, float radiusB);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionBoxes")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionBoxes(global::System.IntPtr box1, global::System.IntPtr box2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionBoxSphere")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionBoxSphere(global::System.IntPtr box, global::System.IntPtr center, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionRaySphere")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionRaySphere(global::System.IntPtr ray, global::System.IntPtr center, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionRaySphereEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionRaySphereEx(global::System.IntPtr ray, global::System.IntPtr center, float radius, global::System.IntPtr collisionPoint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CheckCollisionRayBox")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckCollisionRayBox(global::System.IntPtr ray, global::System.IntPtr box);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetCollisionRayModel")]
            internal static extern void GetCollisionRayModel(global::System.IntPtr @return, global::System.IntPtr ray, global::System.IntPtr model);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetCollisionRayTriangle")]
            internal static extern void GetCollisionRayTriangle(global::System.IntPtr @return, global::System.IntPtr ray, global::System.IntPtr p1, global::System.IntPtr p2, global::System.IntPtr p3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetCollisionRayGround")]
            internal static extern void GetCollisionRayGround(global::System.IntPtr @return, global::System.IntPtr ray, float groundHeight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadText")]
            internal static extern sbyte* LoadText([MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadShader")]
            internal static extern void LoadShader(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string vsFileName, [MarshalAs(UnmanagedType.LPStr)] string fsFileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadShaderCode")]
            internal static extern void LoadShaderCode(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string vsCode, [MarshalAs(UnmanagedType.LPStr)] string fsCode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadShader")]
            internal static extern void UnloadShader(global::System.IntPtr shader);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetShaderDefault")]
            internal static extern void GetShaderDefault(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetTextureDefault")]
            internal static extern void GetTextureDefault(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetShaderLocation")]
            internal static extern int GetShaderLocation(global::System.IntPtr shader, [MarshalAs(UnmanagedType.LPStr)] string uniformName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetShaderValue")]
            internal static extern void SetShaderValue(global::System.IntPtr shader, int uniformLoc, global::System.IntPtr value, int uniformType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetShaderValueV")]
            internal static extern void SetShaderValueV(global::System.IntPtr shader, int uniformLoc, global::System.IntPtr value, int uniformType, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetShaderValueMatrix")]
            internal static extern void SetShaderValueMatrix(global::System.IntPtr shader, int uniformLoc, global::System.IntPtr mat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetShaderValueTexture")]
            internal static extern void SetShaderValueTexture(global::System.IntPtr shader, int uniformLoc, global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMatrixProjection")]
            internal static extern void SetMatrixProjection(global::System.IntPtr proj);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMatrixModelview")]
            internal static extern void SetMatrixModelview(global::System.IntPtr view);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMatrixModelview")]
            internal static extern void GetMatrixModelview(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenTextureCubemap")]
            internal static extern void GenTextureCubemap(global::System.IntPtr @return, global::System.IntPtr shader, global::System.IntPtr skyHDR, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenTextureIrradiance")]
            internal static extern void GenTextureIrradiance(global::System.IntPtr @return, global::System.IntPtr shader, global::System.IntPtr cubemap, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenTexturePrefilter")]
            internal static extern void GenTexturePrefilter(global::System.IntPtr @return, global::System.IntPtr shader, global::System.IntPtr cubemap, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GenTextureBRDF")]
            internal static extern void GenTextureBRDF(global::System.IntPtr @return, global::System.IntPtr shader, int size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="BeginShaderMode")]
            internal static extern void BeginShaderMode(global::System.IntPtr shader);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="EndShaderMode")]
            internal static extern void EndShaderMode();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="BeginBlendMode")]
            internal static extern void BeginBlendMode(int mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="EndBlendMode")]
            internal static extern void EndBlendMode();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="InitVrSimulator")]
            internal static extern void InitVrSimulator();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CloseVrSimulator")]
            internal static extern void CloseVrSimulator();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UpdateVrTracking")]
            internal static extern void UpdateVrTracking(global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetVrConfiguration")]
            internal static extern void SetVrConfiguration(global::System.IntPtr info, global::System.IntPtr distortion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsVrSimulatorReady")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsVrSimulatorReady();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ToggleVrMode")]
            internal static extern void ToggleVrMode();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="BeginVrDrawing")]
            internal static extern void BeginVrDrawing();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="EndVrDrawing")]
            internal static extern void EndVrDrawing();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="InitAudioDevice")]
            internal static extern void InitAudioDevice();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CloseAudioDevice")]
            internal static extern void CloseAudioDevice();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsAudioDeviceReady")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAudioDeviceReady();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMasterVolume")]
            internal static extern void SetMasterVolume(float volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadWave")]
            internal static extern void LoadWave(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadSound")]
            internal static extern void LoadSound(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadSoundFromWave")]
            internal static extern void LoadSoundFromWave(global::System.IntPtr @return, global::System.IntPtr wave);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UpdateSound")]
            internal static extern void UpdateSound(global::System.IntPtr sound, global::System.IntPtr data, int samplesCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadWave")]
            internal static extern void UnloadWave(global::System.IntPtr wave);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadSound")]
            internal static extern void UnloadSound(global::System.IntPtr sound);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ExportWave")]
            internal static extern void ExportWave(global::System.IntPtr wave, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ExportWaveAsCode")]
            internal static extern void ExportWaveAsCode(global::System.IntPtr wave, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PlaySound")]
            internal static extern void PlaySound(global::System.IntPtr sound);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="StopSound")]
            internal static extern void StopSound(global::System.IntPtr sound);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PauseSound")]
            internal static extern void PauseSound(global::System.IntPtr sound);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ResumeSound")]
            internal static extern void ResumeSound(global::System.IntPtr sound);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PlaySoundMulti")]
            internal static extern void PlaySoundMulti(global::System.IntPtr sound);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="StopSoundMulti")]
            internal static extern void StopSoundMulti();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetSoundsPlaying")]
            internal static extern int GetSoundsPlaying();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsSoundPlaying")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSoundPlaying(global::System.IntPtr sound);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetSoundVolume")]
            internal static extern void SetSoundVolume(global::System.IntPtr sound, float volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetSoundPitch")]
            internal static extern void SetSoundPitch(global::System.IntPtr sound, float pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="WaveFormat")]
            internal static extern void WaveFormat(global::System.IntPtr wave, int sampleRate, int sampleSize, int channels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="WaveCrop")]
            internal static extern void WaveCrop(global::System.IntPtr wave, int initSample, int finalSample);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetWaveData")]
            internal static extern float* GetWaveData(global::System.IntPtr wave);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LoadMusicStream")]
            internal static extern void LoadMusicStream(global::System.IntPtr @return, [MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UnloadMusicStream")]
            internal static extern void UnloadMusicStream(global::System.IntPtr music);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PlayMusicStream")]
            internal static extern void PlayMusicStream(global::System.IntPtr music);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UpdateMusicStream")]
            internal static extern void UpdateMusicStream(global::System.IntPtr music);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="StopMusicStream")]
            internal static extern void StopMusicStream(global::System.IntPtr music);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PauseMusicStream")]
            internal static extern void PauseMusicStream(global::System.IntPtr music);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ResumeMusicStream")]
            internal static extern void ResumeMusicStream(global::System.IntPtr music);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsMusicPlaying")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMusicPlaying(global::System.IntPtr music);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMusicVolume")]
            internal static extern void SetMusicVolume(global::System.IntPtr music, float volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMusicPitch")]
            internal static extern void SetMusicPitch(global::System.IntPtr music, float pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetMusicLoopCount")]
            internal static extern void SetMusicLoopCount(global::System.IntPtr music, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMusicTimeLength")]
            internal static extern float GetMusicTimeLength(global::System.IntPtr music);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetMusicTimePlayed")]
            internal static extern float GetMusicTimePlayed(global::System.IntPtr music);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="InitAudioStream")]
            internal static extern void InitAudioStream(global::System.IntPtr @return, uint sampleRate, uint sampleSize, uint channels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="UpdateAudioStream")]
            internal static extern void UpdateAudioStream(global::System.IntPtr stream, global::System.IntPtr data, int samplesCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CloseAudioStream")]
            internal static extern void CloseAudioStream(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsAudioStreamProcessed")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAudioStreamProcessed(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PlayAudioStream")]
            internal static extern void PlayAudioStream(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PauseAudioStream")]
            internal static extern void PauseAudioStream(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ResumeAudioStream")]
            internal static extern void ResumeAudioStream(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsAudioStreamPlaying")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAudioStreamPlaying(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="StopAudioStream")]
            internal static extern void StopAudioStream(global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetAudioStreamVolume")]
            internal static extern void SetAudioStreamVolume(global::System.IntPtr stream, float volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetAudioStreamPitch")]
            internal static extern void SetAudioStreamPitch(global::System.IntPtr stream, float pitch);
        }

        public static void InitWindow(int width, int height, string title)
        {
            __Internal.InitWindow(width, height, title);
        }

        public static bool WindowShouldClose()
        {
            var __ret = __Internal.WindowShouldClose();
            return __ret;
        }

        public static void CloseWindow()
        {
            __Internal.CloseWindow();
        }

        public static bool IsWindowReady()
        {
            var __ret = __Internal.IsWindowReady();
            return __ret;
        }

        public static bool IsWindowMinimized()
        {
            var __ret = __Internal.IsWindowMinimized();
            return __ret;
        }

        public static bool IsWindowResized()
        {
            var __ret = __Internal.IsWindowResized();
            return __ret;
        }

        public static bool IsWindowHidden()
        {
            var __ret = __Internal.IsWindowHidden();
            return __ret;
        }

        public static void ToggleFullscreen()
        {
            __Internal.ToggleFullscreen();
        }

        public static void UnhideWindow()
        {
            __Internal.UnhideWindow();
        }

        public static void HideWindow()
        {
            __Internal.HideWindow();
        }

        public static void SetWindowIcon(global::Raylib.Image image)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            __Internal.SetWindowIcon(__arg0);
        }

        public static void SetWindowTitle(string title)
        {
            __Internal.SetWindowTitle(title);
        }

        public static void SetWindowPosition(int x, int y)
        {
            __Internal.SetWindowPosition(x, y);
        }

        public static void SetWindowMonitor(int monitor)
        {
            __Internal.SetWindowMonitor(monitor);
        }

        public static void SetWindowMinSize(int width, int height)
        {
            __Internal.SetWindowMinSize(width, height);
        }

        public static void SetWindowSize(int width, int height)
        {
            __Internal.SetWindowSize(width, height);
        }

        public static global::System.IntPtr GetWindowHandle()
        {
            var __ret = __Internal.GetWindowHandle();
            return __ret;
        }

        public static int GetScreenWidth()
        {
            var __ret = __Internal.GetScreenWidth();
            return __ret;
        }

        public static int GetScreenHeight()
        {
            var __ret = __Internal.GetScreenHeight();
            return __ret;
        }

        public static int GetMonitorCount()
        {
            var __ret = __Internal.GetMonitorCount();
            return __ret;
        }

        public static int GetMonitorWidth(int monitor)
        {
            var __ret = __Internal.GetMonitorWidth(monitor);
            return __ret;
        }

        public static int GetMonitorHeight(int monitor)
        {
            var __ret = __Internal.GetMonitorHeight(monitor);
            return __ret;
        }

        public static int GetMonitorPhysicalWidth(int monitor)
        {
            var __ret = __Internal.GetMonitorPhysicalWidth(monitor);
            return __ret;
        }

        public static int GetMonitorPhysicalHeight(int monitor)
        {
            var __ret = __Internal.GetMonitorPhysicalHeight(monitor);
            return __ret;
        }

        public static global::Raylib.Vector2 GetWindowPosition()
        {
            var __ret = __Internal.GetWindowPosition();
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static string GetMonitorName(int monitor)
        {
            var __ret = __Internal.GetMonitorName(monitor);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string GetClipboardText()
        {
            var __ret = __Internal.GetClipboardText();
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static void SetClipboardText(string text)
        {
            __Internal.SetClipboardText(text);
        }

        public static void ShowCursor()
        {
            __Internal.ShowCursor();
        }

        public static void HideCursor()
        {
            __Internal.HideCursor();
        }

        public static bool IsCursorHidden()
        {
            var __ret = __Internal.IsCursorHidden();
            return __ret;
        }

        public static void EnableCursor()
        {
            __Internal.EnableCursor();
        }

        public static void DisableCursor()
        {
            __Internal.DisableCursor();
        }

        public static void ClearBackground(global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg0 = color.__Instance;
            __Internal.ClearBackground(*(global::Raylib.Color.__Internal*) __arg0);
        }

        public static void BeginDrawing()
        {
            __Internal.BeginDrawing();
        }

        public static void EndDrawing()
        {
            __Internal.EndDrawing();
        }

        public static void BeginMode2D(global::Raylib.Camera2D camera)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg0 = camera.__Instance;
            __Internal.BeginMode2D(__arg0);
        }

        public static void EndMode2D()
        {
            __Internal.EndMode2D();
        }

        public static void BeginMode3D(global::Raylib.Camera3D camera)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg0 = camera.__Instance;
            __Internal.BeginMode3D(__arg0);
        }

        public static void EndMode3D()
        {
            __Internal.EndMode3D();
        }

        public static void BeginTextureMode(global::Raylib.RenderTexture2D target)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is passed by value.");
            var __arg0 = target.__Instance;
            __Internal.BeginTextureMode(__arg0);
        }

        public static void EndTextureMode()
        {
            __Internal.EndTextureMode();
        }

        public static void BeginScissorMode(int x, int y, int width, int height)
        {
            __Internal.BeginScissorMode(x, y, width, height);
        }

        public static void EndScissorMode()
        {
            __Internal.EndScissorMode();
        }

        public static global::Raylib.Ray GetMouseRay(global::Raylib.Vector2 mousePosition, global::Raylib.Camera3D camera)
        {
            if (ReferenceEquals(mousePosition, null))
                throw new global::System.ArgumentNullException("mousePosition", "Cannot be null because it is passed by value.");
            var __arg0 = mousePosition.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg1 = camera.__Instance;
            var __ret = new global::Raylib.Ray.__Internal();
            __Internal.GetMouseRay(new IntPtr(&__ret), *(global::Raylib.Vector2.__Internal*) __arg0, __arg1);
            return global::Raylib.Ray.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix GetCameraMatrix(global::Raylib.Camera3D camera)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg0 = camera.__Instance;
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.GetCameraMatrix(new IntPtr(&__ret), __arg0);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix GetCameraMatrix2D(global::Raylib.Camera2D camera)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg0 = camera.__Instance;
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.GetCameraMatrix2D(new IntPtr(&__ret), __arg0);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector2 GetWorldToScreen(global::Raylib.Vector3 position, global::Raylib.Camera3D camera)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg1 = camera.__Instance;
            var __ret = __Internal.GetWorldToScreen(__arg0, __arg1);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector2 GetWorldToScreen2D(global::Raylib.Vector2 position, global::Raylib.Camera2D camera)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg1 = camera.__Instance;
            var __ret = __Internal.GetWorldToScreen2D(*(global::Raylib.Vector2.__Internal*) __arg0, __arg1);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector2 GetScreenToWorld2D(global::Raylib.Vector2 position, global::Raylib.Camera2D camera)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg1 = camera.__Instance;
            var __ret = __Internal.GetScreenToWorld2D(*(global::Raylib.Vector2.__Internal*) __arg0, __arg1);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static void SetTargetFPS(int fps)
        {
            __Internal.SetTargetFPS(fps);
        }

        public static int GetFPS()
        {
            var __ret = __Internal.GetFPS();
            return __ret;
        }

        public static float GetFrameTime()
        {
            var __ret = __Internal.GetFrameTime();
            return __ret;
        }

        public static double GetTime()
        {
            var __ret = __Internal.GetTime();
            return __ret;
        }

        public static global::Raylib.Color ColorFromHSV(global::Raylib.Vector3 hsv)
        {
            if (ReferenceEquals(hsv, null))
                throw new global::System.ArgumentNullException("hsv", "Cannot be null because it is passed by value.");
            var __arg0 = hsv.__Instance;
            var __ret = __Internal.ColorFromHSV(__arg0);
            return global::Raylib.Color.__CreateInstance(__ret);
        }

        public static global::Raylib.Color GetColor(int hexValue)
        {
            var __ret = __Internal.GetColor(hexValue);
            return global::Raylib.Color.__CreateInstance(__ret);
        }

        public static global::Raylib.Color Fade(global::Raylib.Color color, float alpha)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg0 = color.__Instance;
            var __ret = __Internal.Fade(*(global::Raylib.Color.__Internal*) __arg0, alpha);
            return global::Raylib.Color.__CreateInstance(__ret);
        }

        public static void SetConfigFlags(uint flags)
        {
            __Internal.SetConfigFlags(flags);
        }

        public static void SetTraceLogLevel(int logType)
        {
            __Internal.SetTraceLogLevel(logType);
        }

        public static void SetTraceLogExit(int logType)
        {
            __Internal.SetTraceLogExit(logType);
        }

        public static void TraceLog(int logType, string text)
        {
            __Internal.TraceLog(logType, text);
        }

        public static void TakeScreenshot(string fileName)
        {
            __Internal.TakeScreenshot(fileName);
        }

        public static int GetRandomValue(int min, int max)
        {
            var __ret = __Internal.GetRandomValue(min, max);
            return __ret;
        }

        public static bool FileExists(string fileName)
        {
            var __ret = __Internal.FileExists(fileName);
            return __ret;
        }

        public static bool IsFileExtension(string fileName, string ext)
        {
            var __ret = __Internal.IsFileExtension(fileName, ext);
            return __ret;
        }

        public static bool DirectoryExists(string dirPath)
        {
            var __ret = __Internal.DirectoryExists(dirPath);
            return __ret;
        }

        public static string GetExtension(string fileName)
        {
            var __ret = __Internal.GetExtension(fileName);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string GetFileName(string filePath)
        {
            var __ret = __Internal.GetFileName(filePath);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string GetFileNameWithoutExt(string filePath)
        {
            var __ret = __Internal.GetFileNameWithoutExt(filePath);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string GetDirectoryPath(string filePath)
        {
            var __ret = __Internal.GetDirectoryPath(filePath);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string GetPrevDirectoryPath(string dirPath)
        {
            var __ret = __Internal.GetPrevDirectoryPath(dirPath);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string GetWorkingDirectory()
        {
            var __ret = __Internal.GetWorkingDirectory();
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static sbyte** GetDirectoryFiles(string dirPath, ref int count)
        {
            fixed (int* __count1 = &count)
            {
                var __arg1 = __count1;
                var __ret = __Internal.GetDirectoryFiles(dirPath, __arg1);
                return __ret;
            }
        }

        public static void ClearDirectoryFiles()
        {
            __Internal.ClearDirectoryFiles();
        }

        public static bool ChangeDirectory(string dir)
        {
            var __ret = __Internal.ChangeDirectory(dir);
            return __ret;
        }

        public static bool IsFileDropped()
        {
            var __ret = __Internal.IsFileDropped();
            return __ret;
        }

        public static sbyte** GetDroppedFiles(ref int count)
        {
            fixed (int* __count0 = &count)
            {
                var __arg0 = __count0;
                var __ret = __Internal.GetDroppedFiles(__arg0);
                return __ret;
            }
        }

        public static void ClearDroppedFiles()
        {
            __Internal.ClearDroppedFiles();
        }

        public static int GetFileModTime(string fileName)
        {
            var __ret = __Internal.GetFileModTime(fileName);
            return __ret;
        }

        public static byte* CompressData(byte* data, int dataLength, ref int compDataLength)
        {
            fixed (int* __compDataLength2 = &compDataLength)
            {
                var __arg2 = __compDataLength2;
                var __ret = __Internal.CompressData(data, dataLength, __arg2);
                return __ret;
            }
        }

        public static byte* DecompressData(byte* compData, int compDataLength, ref int dataLength)
        {
            fixed (int* __dataLength2 = &dataLength)
            {
                var __arg2 = __dataLength2;
                var __ret = __Internal.DecompressData(compData, compDataLength, __arg2);
                return __ret;
            }
        }

        public static void StorageSaveValue(int position, int value)
        {
            __Internal.StorageSaveValue(position, value);
        }

        public static int StorageLoadValue(int position)
        {
            var __ret = __Internal.StorageLoadValue(position);
            return __ret;
        }

        public static void OpenURL(string url)
        {
            __Internal.OpenURL(url);
        }

        public static bool IsKeyPressed(int key)
        {
            var __ret = __Internal.IsKeyPressed(key);
            return __ret;
        }

        public static bool IsKeyDown(int key)
        {
            var __ret = __Internal.IsKeyDown(key);
            return __ret;
        }

        public static bool IsKeyReleased(int key)
        {
            var __ret = __Internal.IsKeyReleased(key);
            return __ret;
        }

        public static bool IsKeyUp(int key)
        {
            var __ret = __Internal.IsKeyUp(key);
            return __ret;
        }

        public static int GetKeyPressed()
        {
            var __ret = __Internal.GetKeyPressed();
            return __ret;
        }

        public static void SetExitKey(int key)
        {
            __Internal.SetExitKey(key);
        }

        public static bool IsGamepadAvailable(int gamepad)
        {
            var __ret = __Internal.IsGamepadAvailable(gamepad);
            return __ret;
        }

        public static bool IsGamepadName(int gamepad, string name)
        {
            var __ret = __Internal.IsGamepadName(gamepad, name);
            return __ret;
        }

        public static string GetGamepadName(int gamepad)
        {
            var __ret = __Internal.GetGamepadName(gamepad);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static bool IsGamepadButtonPressed(int gamepad, int button)
        {
            var __ret = __Internal.IsGamepadButtonPressed(gamepad, button);
            return __ret;
        }

        public static bool IsGamepadButtonDown(int gamepad, int button)
        {
            var __ret = __Internal.IsGamepadButtonDown(gamepad, button);
            return __ret;
        }

        public static bool IsGamepadButtonReleased(int gamepad, int button)
        {
            var __ret = __Internal.IsGamepadButtonReleased(gamepad, button);
            return __ret;
        }

        public static bool IsGamepadButtonUp(int gamepad, int button)
        {
            var __ret = __Internal.IsGamepadButtonUp(gamepad, button);
            return __ret;
        }

        public static int GetGamepadButtonPressed()
        {
            var __ret = __Internal.GetGamepadButtonPressed();
            return __ret;
        }

        public static int GetGamepadAxisCount(int gamepad)
        {
            var __ret = __Internal.GetGamepadAxisCount(gamepad);
            return __ret;
        }

        public static float GetGamepadAxisMovement(int gamepad, int axis)
        {
            var __ret = __Internal.GetGamepadAxisMovement(gamepad, axis);
            return __ret;
        }

        public static bool IsMouseButtonPressed(int button)
        {
            var __ret = __Internal.IsMouseButtonPressed(button);
            return __ret;
        }

        public static bool IsMouseButtonDown(int button)
        {
            var __ret = __Internal.IsMouseButtonDown(button);
            return __ret;
        }

        public static bool IsMouseButtonReleased(int button)
        {
            var __ret = __Internal.IsMouseButtonReleased(button);
            return __ret;
        }

        public static bool IsMouseButtonUp(int button)
        {
            var __ret = __Internal.IsMouseButtonUp(button);
            return __ret;
        }

        public static int GetMouseX()
        {
            var __ret = __Internal.GetMouseX();
            return __ret;
        }

        public static int GetMouseY()
        {
            var __ret = __Internal.GetMouseY();
            return __ret;
        }

        public static global::Raylib.Vector2 GetMousePosition()
        {
            var __ret = __Internal.GetMousePosition();
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static void SetMousePosition(int x, int y)
        {
            __Internal.SetMousePosition(x, y);
        }

        public static void SetMouseOffset(int offsetX, int offsetY)
        {
            __Internal.SetMouseOffset(offsetX, offsetY);
        }

        public static void SetMouseScale(float scaleX, float scaleY)
        {
            __Internal.SetMouseScale(scaleX, scaleY);
        }

        public static int GetMouseWheelMove()
        {
            var __ret = __Internal.GetMouseWheelMove();
            return __ret;
        }

        public static int GetTouchX()
        {
            var __ret = __Internal.GetTouchX();
            return __ret;
        }

        public static int GetTouchY()
        {
            var __ret = __Internal.GetTouchY();
            return __ret;
        }

        public static global::Raylib.Vector2 GetTouchPosition(int index)
        {
            var __ret = __Internal.GetTouchPosition(index);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static void SetGesturesEnabled(uint gestureFlags)
        {
            __Internal.SetGesturesEnabled(gestureFlags);
        }

        public static bool IsGestureDetected(int gesture)
        {
            var __ret = __Internal.IsGestureDetected(gesture);
            return __ret;
        }

        public static int GetGestureDetected()
        {
            var __ret = __Internal.GetGestureDetected();
            return __ret;
        }

        public static int GetTouchPointsCount()
        {
            var __ret = __Internal.GetTouchPointsCount();
            return __ret;
        }

        public static float GetGestureHoldDuration()
        {
            var __ret = __Internal.GetGestureHoldDuration();
            return __ret;
        }

        public static global::Raylib.Vector2 GetGestureDragVector()
        {
            var __ret = __Internal.GetGestureDragVector();
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static float GetGestureDragAngle()
        {
            var __ret = __Internal.GetGestureDragAngle();
            return __ret;
        }

        public static global::Raylib.Vector2 GetGesturePinchVector()
        {
            var __ret = __Internal.GetGesturePinchVector();
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static float GetGesturePinchAngle()
        {
            var __ret = __Internal.GetGesturePinchAngle();
            return __ret;
        }

        public static void SetCameraMode(global::Raylib.Camera3D camera, int mode)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg0 = camera.__Instance;
            __Internal.SetCameraMode(__arg0, mode);
        }

        public static void UpdateCamera(global::Raylib.Camera3D camera)
        {
            var __arg0 = ReferenceEquals(camera, null) ? global::System.IntPtr.Zero : camera.__Instance;
            __Internal.UpdateCamera(__arg0);
        }

        public static void SetCameraPanControl(int panKey)
        {
            __Internal.SetCameraPanControl(panKey);
        }

        public static void SetCameraAltControl(int altKey)
        {
            __Internal.SetCameraAltControl(altKey);
        }

        public static void SetCameraSmoothZoomControl(int szKey)
        {
            __Internal.SetCameraSmoothZoomControl(szKey);
        }

        public static void SetCameraMoveControls(int frontKey, int backKey, int rightKey, int leftKey, int upKey, int downKey)
        {
            __Internal.SetCameraMoveControls(frontKey, backKey, rightKey, leftKey, upKey, downKey);
        }

        public static void DrawPixel(int posX, int posY, global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawPixel(posX, posY, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawPixelV(global::Raylib.Vector2 position, global::Raylib.Color color)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.DrawPixelV(*(global::Raylib.Vector2.__Internal*) __arg0, *(global::Raylib.Color.__Internal*) __arg1);
        }

        public static void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawLine(startPosX, startPosY, endPosX, endPosY, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawLineV(global::Raylib.Vector2 startPos, global::Raylib.Vector2 endPos, global::Raylib.Color color)
        {
            if (ReferenceEquals(startPos, null))
                throw new global::System.ArgumentNullException("startPos", "Cannot be null because it is passed by value.");
            var __arg0 = startPos.__Instance;
            if (ReferenceEquals(endPos, null))
                throw new global::System.ArgumentNullException("endPos", "Cannot be null because it is passed by value.");
            var __arg1 = endPos.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawLineV(*(global::Raylib.Vector2.__Internal*) __arg0, *(global::Raylib.Vector2.__Internal*) __arg1, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawLineEx(global::Raylib.Vector2 startPos, global::Raylib.Vector2 endPos, float thick, global::Raylib.Color color)
        {
            if (ReferenceEquals(startPos, null))
                throw new global::System.ArgumentNullException("startPos", "Cannot be null because it is passed by value.");
            var __arg0 = startPos.__Instance;
            if (ReferenceEquals(endPos, null))
                throw new global::System.ArgumentNullException("endPos", "Cannot be null because it is passed by value.");
            var __arg1 = endPos.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.DrawLineEx(*(global::Raylib.Vector2.__Internal*) __arg0, *(global::Raylib.Vector2.__Internal*) __arg1, thick, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawLineBezier(global::Raylib.Vector2 startPos, global::Raylib.Vector2 endPos, float thick, global::Raylib.Color color)
        {
            if (ReferenceEquals(startPos, null))
                throw new global::System.ArgumentNullException("startPos", "Cannot be null because it is passed by value.");
            var __arg0 = startPos.__Instance;
            if (ReferenceEquals(endPos, null))
                throw new global::System.ArgumentNullException("endPos", "Cannot be null because it is passed by value.");
            var __arg1 = endPos.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.DrawLineBezier(*(global::Raylib.Vector2.__Internal*) __arg0, *(global::Raylib.Vector2.__Internal*) __arg1, thick, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawLineStrip(global::Raylib.Vector2 points, int numPoints, global::Raylib.Color color)
        {
            var __arg0 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawLineStrip(__arg0, numPoints, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawCircle(int centerX, int centerY, float radius, global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.DrawCircle(centerX, centerY, radius, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawCircleSector(global::Raylib.Vector2 center, float radius, int startAngle, int endAngle, int segments, global::Raylib.Color color)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg0 = center.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg5 = color.__Instance;
            __Internal.DrawCircleSector(*(global::Raylib.Vector2.__Internal*) __arg0, radius, startAngle, endAngle, segments, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawCircleSectorLines(global::Raylib.Vector2 center, float radius, int startAngle, int endAngle, int segments, global::Raylib.Color color)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg0 = center.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg5 = color.__Instance;
            __Internal.DrawCircleSectorLines(*(global::Raylib.Vector2.__Internal*) __arg0, radius, startAngle, endAngle, segments, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawCircleGradient(int centerX, int centerY, float radius, global::Raylib.Color color1, global::Raylib.Color color2)
        {
            if (ReferenceEquals(color1, null))
                throw new global::System.ArgumentNullException("color1", "Cannot be null because it is passed by value.");
            var __arg3 = color1.__Instance;
            if (ReferenceEquals(color2, null))
                throw new global::System.ArgumentNullException("color2", "Cannot be null because it is passed by value.");
            var __arg4 = color2.__Instance;
            __Internal.DrawCircleGradient(centerX, centerY, radius, *(global::Raylib.Color.__Internal*) __arg3, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawCircleV(global::Raylib.Vector2 center, float radius, global::Raylib.Color color)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg0 = center.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawCircleV(*(global::Raylib.Vector2.__Internal*) __arg0, radius, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawCircleLines(int centerX, int centerY, float radius, global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.DrawCircleLines(centerX, centerY, radius, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawRing(global::Raylib.Vector2 center, float innerRadius, float outerRadius, int startAngle, int endAngle, int segments, global::Raylib.Color color)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg0 = center.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg6 = color.__Instance;
            __Internal.DrawRing(*(global::Raylib.Vector2.__Internal*) __arg0, innerRadius, outerRadius, startAngle, endAngle, segments, *(global::Raylib.Color.__Internal*) __arg6);
        }

        public static void DrawRingLines(global::Raylib.Vector2 center, float innerRadius, float outerRadius, int startAngle, int endAngle, int segments, global::Raylib.Color color)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg0 = center.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg6 = color.__Instance;
            __Internal.DrawRingLines(*(global::Raylib.Vector2.__Internal*) __arg0, innerRadius, outerRadius, startAngle, endAngle, segments, *(global::Raylib.Color.__Internal*) __arg6);
        }

        public static void DrawRectangle(int posX, int posY, int width, int height, global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawRectangle(posX, posY, width, height, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawRectangleV(global::Raylib.Vector2 position, global::Raylib.Vector2 size, global::Raylib.Color color)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawRectangleV(*(global::Raylib.Vector2.__Internal*) __arg0, *(global::Raylib.Vector2.__Internal*) __arg1, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawRectangleRec(global::Raylib.Rectangle rec, global::Raylib.Color color)
        {
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg0 = rec.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.DrawRectangleRec(__arg0, *(global::Raylib.Color.__Internal*) __arg1);
        }

        public static void DrawRectanglePro(global::Raylib.Rectangle rec, global::Raylib.Vector2 origin, float rotation, global::Raylib.Color color)
        {
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg0 = rec.__Instance;
            if (ReferenceEquals(origin, null))
                throw new global::System.ArgumentNullException("origin", "Cannot be null because it is passed by value.");
            var __arg1 = origin.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.DrawRectanglePro(__arg0, *(global::Raylib.Vector2.__Internal*) __arg1, rotation, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawRectangleGradientV(int posX, int posY, int width, int height, global::Raylib.Color color1, global::Raylib.Color color2)
        {
            if (ReferenceEquals(color1, null))
                throw new global::System.ArgumentNullException("color1", "Cannot be null because it is passed by value.");
            var __arg4 = color1.__Instance;
            if (ReferenceEquals(color2, null))
                throw new global::System.ArgumentNullException("color2", "Cannot be null because it is passed by value.");
            var __arg5 = color2.__Instance;
            __Internal.DrawRectangleGradientV(posX, posY, width, height, *(global::Raylib.Color.__Internal*) __arg4, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawRectangleGradientH(int posX, int posY, int width, int height, global::Raylib.Color color1, global::Raylib.Color color2)
        {
            if (ReferenceEquals(color1, null))
                throw new global::System.ArgumentNullException("color1", "Cannot be null because it is passed by value.");
            var __arg4 = color1.__Instance;
            if (ReferenceEquals(color2, null))
                throw new global::System.ArgumentNullException("color2", "Cannot be null because it is passed by value.");
            var __arg5 = color2.__Instance;
            __Internal.DrawRectangleGradientH(posX, posY, width, height, *(global::Raylib.Color.__Internal*) __arg4, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawRectangleGradientEx(global::Raylib.Rectangle rec, global::Raylib.Color col1, global::Raylib.Color col2, global::Raylib.Color col3, global::Raylib.Color col4)
        {
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg0 = rec.__Instance;
            if (ReferenceEquals(col1, null))
                throw new global::System.ArgumentNullException("col1", "Cannot be null because it is passed by value.");
            var __arg1 = col1.__Instance;
            if (ReferenceEquals(col2, null))
                throw new global::System.ArgumentNullException("col2", "Cannot be null because it is passed by value.");
            var __arg2 = col2.__Instance;
            if (ReferenceEquals(col3, null))
                throw new global::System.ArgumentNullException("col3", "Cannot be null because it is passed by value.");
            var __arg3 = col3.__Instance;
            if (ReferenceEquals(col4, null))
                throw new global::System.ArgumentNullException("col4", "Cannot be null because it is passed by value.");
            var __arg4 = col4.__Instance;
            __Internal.DrawRectangleGradientEx(__arg0, *(global::Raylib.Color.__Internal*) __arg1, *(global::Raylib.Color.__Internal*) __arg2, *(global::Raylib.Color.__Internal*) __arg3, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawRectangleLines(int posX, int posY, int width, int height, global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawRectangleLines(posX, posY, width, height, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawRectangleLinesEx(global::Raylib.Rectangle rec, int lineThick, global::Raylib.Color color)
        {
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg0 = rec.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawRectangleLinesEx(__arg0, lineThick, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawRectangleRounded(global::Raylib.Rectangle rec, float roundness, int segments, global::Raylib.Color color)
        {
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg0 = rec.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.DrawRectangleRounded(__arg0, roundness, segments, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawRectangleRoundedLines(global::Raylib.Rectangle rec, float roundness, int segments, int lineThick, global::Raylib.Color color)
        {
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg0 = rec.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawRectangleRoundedLines(__arg0, roundness, segments, lineThick, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawTriangle(global::Raylib.Vector2 v1, global::Raylib.Vector2 v2, global::Raylib.Vector2 v3, global::Raylib.Color color)
        {
            if (ReferenceEquals(v1, null))
                throw new global::System.ArgumentNullException("v1", "Cannot be null because it is passed by value.");
            var __arg0 = v1.__Instance;
            if (ReferenceEquals(v2, null))
                throw new global::System.ArgumentNullException("v2", "Cannot be null because it is passed by value.");
            var __arg1 = v2.__Instance;
            if (ReferenceEquals(v3, null))
                throw new global::System.ArgumentNullException("v3", "Cannot be null because it is passed by value.");
            var __arg2 = v3.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.DrawTriangle(*(global::Raylib.Vector2.__Internal*) __arg0, *(global::Raylib.Vector2.__Internal*) __arg1, *(global::Raylib.Vector2.__Internal*) __arg2, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawTriangleLines(global::Raylib.Vector2 v1, global::Raylib.Vector2 v2, global::Raylib.Vector2 v3, global::Raylib.Color color)
        {
            if (ReferenceEquals(v1, null))
                throw new global::System.ArgumentNullException("v1", "Cannot be null because it is passed by value.");
            var __arg0 = v1.__Instance;
            if (ReferenceEquals(v2, null))
                throw new global::System.ArgumentNullException("v2", "Cannot be null because it is passed by value.");
            var __arg1 = v2.__Instance;
            if (ReferenceEquals(v3, null))
                throw new global::System.ArgumentNullException("v3", "Cannot be null because it is passed by value.");
            var __arg2 = v3.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.DrawTriangleLines(*(global::Raylib.Vector2.__Internal*) __arg0, *(global::Raylib.Vector2.__Internal*) __arg1, *(global::Raylib.Vector2.__Internal*) __arg2, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawTriangleFan(global::Raylib.Vector2 points, int numPoints, global::Raylib.Color color)
        {
            var __arg0 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawTriangleFan(__arg0, numPoints, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawTriangleStrip(global::Raylib.Vector2 points, int pointsCount, global::Raylib.Color color)
        {
            var __arg0 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawTriangleStrip(__arg0, pointsCount, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawPoly(global::Raylib.Vector2 center, int sides, float radius, float rotation, global::Raylib.Color color)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg0 = center.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawPoly(*(global::Raylib.Vector2.__Internal*) __arg0, sides, radius, rotation, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void SetShapesTexture(global::Raylib.Texture2D texture, global::Raylib.Rectangle source)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is passed by value.");
            var __arg1 = source.__Instance;
            __Internal.SetShapesTexture(__arg0, __arg1);
        }

        public static bool CheckCollisionRecs(global::Raylib.Rectangle rec1, global::Raylib.Rectangle rec2)
        {
            if (ReferenceEquals(rec1, null))
                throw new global::System.ArgumentNullException("rec1", "Cannot be null because it is passed by value.");
            var __arg0 = rec1.__Instance;
            if (ReferenceEquals(rec2, null))
                throw new global::System.ArgumentNullException("rec2", "Cannot be null because it is passed by value.");
            var __arg1 = rec2.__Instance;
            var __ret = __Internal.CheckCollisionRecs(__arg0, __arg1);
            return __ret;
        }

        public static bool CheckCollisionCircles(global::Raylib.Vector2 center1, float radius1, global::Raylib.Vector2 center2, float radius2)
        {
            if (ReferenceEquals(center1, null))
                throw new global::System.ArgumentNullException("center1", "Cannot be null because it is passed by value.");
            var __arg0 = center1.__Instance;
            if (ReferenceEquals(center2, null))
                throw new global::System.ArgumentNullException("center2", "Cannot be null because it is passed by value.");
            var __arg2 = center2.__Instance;
            var __ret = __Internal.CheckCollisionCircles(*(global::Raylib.Vector2.__Internal*) __arg0, radius1, *(global::Raylib.Vector2.__Internal*) __arg2, radius2);
            return __ret;
        }

        public static bool CheckCollisionCircleRec(global::Raylib.Vector2 center, float radius, global::Raylib.Rectangle rec)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg0 = center.__Instance;
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg2 = rec.__Instance;
            var __ret = __Internal.CheckCollisionCircleRec(*(global::Raylib.Vector2.__Internal*) __arg0, radius, __arg2);
            return __ret;
        }

        public static global::Raylib.Rectangle GetCollisionRec(global::Raylib.Rectangle rec1, global::Raylib.Rectangle rec2)
        {
            if (ReferenceEquals(rec1, null))
                throw new global::System.ArgumentNullException("rec1", "Cannot be null because it is passed by value.");
            var __arg0 = rec1.__Instance;
            if (ReferenceEquals(rec2, null))
                throw new global::System.ArgumentNullException("rec2", "Cannot be null because it is passed by value.");
            var __arg1 = rec2.__Instance;
            var __ret = new global::Raylib.Rectangle.__Internal();
            __Internal.GetCollisionRec(new IntPtr(&__ret), __arg0, __arg1);
            return global::Raylib.Rectangle.__CreateInstance(__ret);
        }

        public static bool CheckCollisionPointRec(global::Raylib.Vector2 point, global::Raylib.Rectangle rec)
        {
            if (ReferenceEquals(point, null))
                throw new global::System.ArgumentNullException("point", "Cannot be null because it is passed by value.");
            var __arg0 = point.__Instance;
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg1 = rec.__Instance;
            var __ret = __Internal.CheckCollisionPointRec(*(global::Raylib.Vector2.__Internal*) __arg0, __arg1);
            return __ret;
        }

        public static bool CheckCollisionPointCircle(global::Raylib.Vector2 point, global::Raylib.Vector2 center, float radius)
        {
            if (ReferenceEquals(point, null))
                throw new global::System.ArgumentNullException("point", "Cannot be null because it is passed by value.");
            var __arg0 = point.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            var __ret = __Internal.CheckCollisionPointCircle(*(global::Raylib.Vector2.__Internal*) __arg0, *(global::Raylib.Vector2.__Internal*) __arg1, radius);
            return __ret;
        }

        public static bool CheckCollisionPointTriangle(global::Raylib.Vector2 point, global::Raylib.Vector2 p1, global::Raylib.Vector2 p2, global::Raylib.Vector2 p3)
        {
            if (ReferenceEquals(point, null))
                throw new global::System.ArgumentNullException("point", "Cannot be null because it is passed by value.");
            var __arg0 = point.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            var __ret = __Internal.CheckCollisionPointTriangle(*(global::Raylib.Vector2.__Internal*) __arg0, *(global::Raylib.Vector2.__Internal*) __arg1, *(global::Raylib.Vector2.__Internal*) __arg2, *(global::Raylib.Vector2.__Internal*) __arg3);
            return __ret;
        }

        public static global::Raylib.Image LoadImage(string fileName)
        {
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.LoadImage(new IntPtr(&__ret), fileName);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image LoadImageEx(global::Raylib.Color pixels, int width, int height)
        {
            var __arg0 = ReferenceEquals(pixels, null) ? global::System.IntPtr.Zero : pixels.__Instance;
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.LoadImageEx(new IntPtr(&__ret), __arg0, width, height);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image LoadImagePro(global::System.IntPtr data, int width, int height, int format)
        {
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.LoadImagePro(new IntPtr(&__ret), data, width, height, format);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image LoadImageRaw(string fileName, int width, int height, int format, int headerSize)
        {
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.LoadImageRaw(new IntPtr(&__ret), fileName, width, height, format, headerSize);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static void ExportImage(global::Raylib.Image image, string fileName)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            __Internal.ExportImage(__arg0, fileName);
        }

        public static void ExportImageAsCode(global::Raylib.Image image, string fileName)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            __Internal.ExportImageAsCode(__arg0, fileName);
        }

        public static global::Raylib.Texture2D LoadTexture(string fileName)
        {
            var __ret = new global::Raylib.Texture2D.__Internal();
            __Internal.LoadTexture(new IntPtr(&__ret), fileName);
            return global::Raylib.Texture2D.__CreateInstance(__ret);
        }

        public static global::Raylib.Texture2D LoadTextureFromImage(global::Raylib.Image image)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            var __ret = new global::Raylib.Texture2D.__Internal();
            __Internal.LoadTextureFromImage(new IntPtr(&__ret), __arg0);
            return global::Raylib.Texture2D.__CreateInstance(__ret);
        }

        public static global::Raylib.Texture2D LoadTextureCubemap(global::Raylib.Image image, int layoutType)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            var __ret = new global::Raylib.Texture2D.__Internal();
            __Internal.LoadTextureCubemap(new IntPtr(&__ret), __arg0, layoutType);
            return global::Raylib.Texture2D.__CreateInstance(__ret);
        }

        public static global::Raylib.RenderTexture2D LoadRenderTexture(int width, int height)
        {
            var __ret = new global::Raylib.RenderTexture2D.__Internal();
            __Internal.LoadRenderTexture(new IntPtr(&__ret), width, height);
            return global::Raylib.RenderTexture2D.__CreateInstance(__ret);
        }

        public static void UnloadImage(global::Raylib.Image image)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            __Internal.UnloadImage(__arg0);
        }

        public static void UnloadTexture(global::Raylib.Texture2D texture)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            __Internal.UnloadTexture(__arg0);
        }

        public static void UnloadRenderTexture(global::Raylib.RenderTexture2D target)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is passed by value.");
            var __arg0 = target.__Instance;
            __Internal.UnloadRenderTexture(__arg0);
        }

        public static global::Raylib.Color GetImageData(global::Raylib.Image image)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            var __ret = __Internal.GetImageData(__arg0);
            global::Raylib.Color __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Raylib.Color.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Raylib.Color) global::Raylib.Color.NativeToManagedMap[__ret];
            else __result0 = global::Raylib.Color.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Raylib.Vector4 GetImageDataNormalized(global::Raylib.Image image)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            var __ret = __Internal.GetImageDataNormalized(__arg0);
            global::Raylib.Vector4 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Raylib.Vector4.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Raylib.Vector4) global::Raylib.Vector4.NativeToManagedMap[__ret];
            else __result0 = global::Raylib.Vector4.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Raylib.Rectangle GetImageAlphaBorder(global::Raylib.Image image, float threshold)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            var __ret = new global::Raylib.Rectangle.__Internal();
            __Internal.GetImageAlphaBorder(new IntPtr(&__ret), __arg0, threshold);
            return global::Raylib.Rectangle.__CreateInstance(__ret);
        }

        public static int GetPixelDataSize(int width, int height, int format)
        {
            var __ret = __Internal.GetPixelDataSize(width, height, format);
            return __ret;
        }

        public static global::Raylib.Image GetTextureData(global::Raylib.Texture2D texture)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GetTextureData(new IntPtr(&__ret), __arg0);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image GetScreenData()
        {
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GetScreenData(new IntPtr(&__ret));
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static void UpdateTexture(global::Raylib.Texture2D texture, global::System.IntPtr pixels)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            __Internal.UpdateTexture(__arg0, pixels);
        }

        public static void ImageToPOT(global::Raylib.Image image, global::Raylib.Color fillColor)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            if (ReferenceEquals(fillColor, null))
                throw new global::System.ArgumentNullException("fillColor", "Cannot be null because it is passed by value.");
            var __arg1 = fillColor.__Instance;
            __Internal.ImageToPOT(__arg0, *(global::Raylib.Color.__Internal*) __arg1);
        }

        public static void ImageFormat(global::Raylib.Image image, int newFormat)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageFormat(__arg0, newFormat);
        }

        public static void ImageAlphaMask(global::Raylib.Image image, global::Raylib.Image alphaMask)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            if (ReferenceEquals(alphaMask, null))
                throw new global::System.ArgumentNullException("alphaMask", "Cannot be null because it is passed by value.");
            var __arg1 = alphaMask.__Instance;
            __Internal.ImageAlphaMask(__arg0, __arg1);
        }

        public static void ImageAlphaClear(global::Raylib.Image image, global::Raylib.Color color, float threshold)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.ImageAlphaClear(__arg0, *(global::Raylib.Color.__Internal*) __arg1, threshold);
        }

        public static void ImageAlphaCrop(global::Raylib.Image image, float threshold)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageAlphaCrop(__arg0, threshold);
        }

        public static void ImageAlphaPremultiply(global::Raylib.Image image)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageAlphaPremultiply(__arg0);
        }

        public static void ImageCrop(global::Raylib.Image image, global::Raylib.Rectangle crop)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            if (ReferenceEquals(crop, null))
                throw new global::System.ArgumentNullException("crop", "Cannot be null because it is passed by value.");
            var __arg1 = crop.__Instance;
            __Internal.ImageCrop(__arg0, __arg1);
        }

        public static void ImageResize(global::Raylib.Image image, int newWidth, int newHeight)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageResize(__arg0, newWidth, newHeight);
        }

        public static void ImageResizeNN(global::Raylib.Image image, int newWidth, int newHeight)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageResizeNN(__arg0, newWidth, newHeight);
        }

        public static void ImageResizeCanvas(global::Raylib.Image image, int newWidth, int newHeight, int offsetX, int offsetY, global::Raylib.Color color)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg5 = color.__Instance;
            __Internal.ImageResizeCanvas(__arg0, newWidth, newHeight, offsetX, offsetY, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void ImageMipmaps(global::Raylib.Image image)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageMipmaps(__arg0);
        }

        public static void ImageDither(global::Raylib.Image image, int rBpp, int gBpp, int bBpp, int aBpp)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageDither(__arg0, rBpp, gBpp, bBpp, aBpp);
        }

        public static global::Raylib.Image ImageText(string text, int fontSize, global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.ImageText(new IntPtr(&__ret), text, fontSize, *(global::Raylib.Color.__Internal*) __arg2);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image ImageTextEx(global::Raylib.Font font, string text, float fontSize, float spacing, global::Raylib.Color tint)
        {
            if (ReferenceEquals(font, null))
                throw new global::System.ArgumentNullException("font", "Cannot be null because it is passed by value.");
            var __arg0 = font.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg4 = tint.__Instance;
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.ImageTextEx(new IntPtr(&__ret), __arg0, text, fontSize, spacing, *(global::Raylib.Color.__Internal*) __arg4);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static void ImageDraw(global::Raylib.Image dst, global::Raylib.Image src, global::Raylib.Rectangle srcRec, global::Raylib.Rectangle dstRec, global::Raylib.Color tint)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            if (ReferenceEquals(src, null))
                throw new global::System.ArgumentNullException("src", "Cannot be null because it is passed by value.");
            var __arg1 = src.__Instance;
            if (ReferenceEquals(srcRec, null))
                throw new global::System.ArgumentNullException("srcRec", "Cannot be null because it is passed by value.");
            var __arg2 = srcRec.__Instance;
            if (ReferenceEquals(dstRec, null))
                throw new global::System.ArgumentNullException("dstRec", "Cannot be null because it is passed by value.");
            var __arg3 = dstRec.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg4 = tint.__Instance;
            __Internal.ImageDraw(__arg0, __arg1, __arg2, __arg3, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void ImageDrawRectangle(global::Raylib.Image dst, global::Raylib.Rectangle rec, global::Raylib.Color color)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg1 = rec.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.ImageDrawRectangle(__arg0, __arg1, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void ImageDrawRectangleLines(global::Raylib.Image dst, global::Raylib.Rectangle rec, int thick, global::Raylib.Color color)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg1 = rec.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.ImageDrawRectangleLines(__arg0, __arg1, thick, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void ImageDrawText(global::Raylib.Image dst, global::Raylib.Vector2 position, string text, int fontSize, global::Raylib.Color color)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.ImageDrawText(__arg0, *(global::Raylib.Vector2.__Internal*) __arg1, text, fontSize, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void ImageDrawTextEx(global::Raylib.Image dst, global::Raylib.Vector2 position, global::Raylib.Font font, string text, float fontSize, float spacing, global::Raylib.Color color)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(font, null))
                throw new global::System.ArgumentNullException("font", "Cannot be null because it is passed by value.");
            var __arg2 = font.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg6 = color.__Instance;
            __Internal.ImageDrawTextEx(__arg0, *(global::Raylib.Vector2.__Internal*) __arg1, __arg2, text, fontSize, spacing, *(global::Raylib.Color.__Internal*) __arg6);
        }

        public static void ImageFlipVertical(global::Raylib.Image image)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageFlipVertical(__arg0);
        }

        public static void ImageFlipHorizontal(global::Raylib.Image image)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageFlipHorizontal(__arg0);
        }

        public static void ImageRotateCW(global::Raylib.Image image)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageRotateCW(__arg0);
        }

        public static void ImageRotateCCW(global::Raylib.Image image)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageRotateCCW(__arg0);
        }

        public static void ImageColorTint(global::Raylib.Image image, global::Raylib.Color color)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.ImageColorTint(__arg0, *(global::Raylib.Color.__Internal*) __arg1);
        }

        public static void ImageColorInvert(global::Raylib.Image image)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageColorInvert(__arg0);
        }

        public static void ImageColorGrayscale(global::Raylib.Image image)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageColorGrayscale(__arg0);
        }

        public static void ImageColorContrast(global::Raylib.Image image, float contrast)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageColorContrast(__arg0, contrast);
        }

        public static void ImageColorBrightness(global::Raylib.Image image, int brightness)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.ImageColorBrightness(__arg0, brightness);
        }

        public static void ImageColorReplace(global::Raylib.Image image, global::Raylib.Color color, global::Raylib.Color replace)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            if (ReferenceEquals(replace, null))
                throw new global::System.ArgumentNullException("replace", "Cannot be null because it is passed by value.");
            var __arg2 = replace.__Instance;
            __Internal.ImageColorReplace(__arg0, *(global::Raylib.Color.__Internal*) __arg1, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static global::Raylib.Image GenImageColor(int width, int height, global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GenImageColor(new IntPtr(&__ret), width, height, *(global::Raylib.Color.__Internal*) __arg2);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image GenImageGradientV(int width, int height, global::Raylib.Color top, global::Raylib.Color bottom)
        {
            if (ReferenceEquals(top, null))
                throw new global::System.ArgumentNullException("top", "Cannot be null because it is passed by value.");
            var __arg2 = top.__Instance;
            if (ReferenceEquals(bottom, null))
                throw new global::System.ArgumentNullException("bottom", "Cannot be null because it is passed by value.");
            var __arg3 = bottom.__Instance;
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GenImageGradientV(new IntPtr(&__ret), width, height, *(global::Raylib.Color.__Internal*) __arg2, *(global::Raylib.Color.__Internal*) __arg3);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image GenImageGradientH(int width, int height, global::Raylib.Color left, global::Raylib.Color right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is passed by value.");
            var __arg2 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is passed by value.");
            var __arg3 = right.__Instance;
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GenImageGradientH(new IntPtr(&__ret), width, height, *(global::Raylib.Color.__Internal*) __arg2, *(global::Raylib.Color.__Internal*) __arg3);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image GenImageGradientRadial(int width, int height, float density, global::Raylib.Color inner, global::Raylib.Color outer)
        {
            if (ReferenceEquals(inner, null))
                throw new global::System.ArgumentNullException("inner", "Cannot be null because it is passed by value.");
            var __arg3 = inner.__Instance;
            if (ReferenceEquals(outer, null))
                throw new global::System.ArgumentNullException("outer", "Cannot be null because it is passed by value.");
            var __arg4 = outer.__Instance;
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GenImageGradientRadial(new IntPtr(&__ret), width, height, density, *(global::Raylib.Color.__Internal*) __arg3, *(global::Raylib.Color.__Internal*) __arg4);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image GenImageChecked(int width, int height, int checksX, int checksY, global::Raylib.Color col1, global::Raylib.Color col2)
        {
            if (ReferenceEquals(col1, null))
                throw new global::System.ArgumentNullException("col1", "Cannot be null because it is passed by value.");
            var __arg4 = col1.__Instance;
            if (ReferenceEquals(col2, null))
                throw new global::System.ArgumentNullException("col2", "Cannot be null because it is passed by value.");
            var __arg5 = col2.__Instance;
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GenImageChecked(new IntPtr(&__ret), width, height, checksX, checksY, *(global::Raylib.Color.__Internal*) __arg4, *(global::Raylib.Color.__Internal*) __arg5);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image GenImageWhiteNoise(int width, int height, float factor)
        {
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GenImageWhiteNoise(new IntPtr(&__ret), width, height, factor);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale)
        {
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GenImagePerlinNoise(new IntPtr(&__ret), width, height, offsetX, offsetY, scale);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static global::Raylib.Image GenImageCellular(int width, int height, int tileSize)
        {
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GenImageCellular(new IntPtr(&__ret), width, height, tileSize);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static void GenTextureMipmaps(global::Raylib.Texture2D texture)
        {
            var __arg0 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            __Internal.GenTextureMipmaps(__arg0);
        }

        public static void SetTextureFilter(global::Raylib.Texture2D texture, int filterMode)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            __Internal.SetTextureFilter(__arg0, filterMode);
        }

        public static void SetTextureWrap(global::Raylib.Texture2D texture, int wrapMode)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            __Internal.SetTextureWrap(__arg0, wrapMode);
        }

        public static void DrawTexture(global::Raylib.Texture2D texture, int posX, int posY, global::Raylib.Color tint)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg3 = tint.__Instance;
            __Internal.DrawTexture(__arg0, posX, posY, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawTextureV(global::Raylib.Texture2D texture, global::Raylib.Vector2 position, global::Raylib.Color tint)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg2 = tint.__Instance;
            __Internal.DrawTextureV(__arg0, *(global::Raylib.Vector2.__Internal*) __arg1, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawTextureEx(global::Raylib.Texture2D texture, global::Raylib.Vector2 position, float rotation, float scale, global::Raylib.Color tint)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg4 = tint.__Instance;
            __Internal.DrawTextureEx(__arg0, *(global::Raylib.Vector2.__Internal*) __arg1, rotation, scale, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawTextureRec(global::Raylib.Texture2D texture, global::Raylib.Rectangle sourceRec, global::Raylib.Vector2 position, global::Raylib.Color tint)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            if (ReferenceEquals(sourceRec, null))
                throw new global::System.ArgumentNullException("sourceRec", "Cannot be null because it is passed by value.");
            var __arg1 = sourceRec.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg2 = position.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg3 = tint.__Instance;
            __Internal.DrawTextureRec(__arg0, __arg1, *(global::Raylib.Vector2.__Internal*) __arg2, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawTextureQuad(global::Raylib.Texture2D texture, global::Raylib.Vector2 tiling, global::Raylib.Vector2 offset, global::Raylib.Rectangle quad, global::Raylib.Color tint)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            if (ReferenceEquals(tiling, null))
                throw new global::System.ArgumentNullException("tiling", "Cannot be null because it is passed by value.");
            var __arg1 = tiling.__Instance;
            if (ReferenceEquals(offset, null))
                throw new global::System.ArgumentNullException("offset", "Cannot be null because it is passed by value.");
            var __arg2 = offset.__Instance;
            if (ReferenceEquals(quad, null))
                throw new global::System.ArgumentNullException("quad", "Cannot be null because it is passed by value.");
            var __arg3 = quad.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg4 = tint.__Instance;
            __Internal.DrawTextureQuad(__arg0, *(global::Raylib.Vector2.__Internal*) __arg1, *(global::Raylib.Vector2.__Internal*) __arg2, __arg3, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawTexturePro(global::Raylib.Texture2D texture, global::Raylib.Rectangle sourceRec, global::Raylib.Rectangle destRec, global::Raylib.Vector2 origin, float rotation, global::Raylib.Color tint)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            if (ReferenceEquals(sourceRec, null))
                throw new global::System.ArgumentNullException("sourceRec", "Cannot be null because it is passed by value.");
            var __arg1 = sourceRec.__Instance;
            if (ReferenceEquals(destRec, null))
                throw new global::System.ArgumentNullException("destRec", "Cannot be null because it is passed by value.");
            var __arg2 = destRec.__Instance;
            if (ReferenceEquals(origin, null))
                throw new global::System.ArgumentNullException("origin", "Cannot be null because it is passed by value.");
            var __arg3 = origin.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg5 = tint.__Instance;
            __Internal.DrawTexturePro(__arg0, __arg1, __arg2, *(global::Raylib.Vector2.__Internal*) __arg3, rotation, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawTextureNPatch(global::Raylib.Texture2D texture, global::Raylib.NPatchInfo nPatchInfo, global::Raylib.Rectangle destRec, global::Raylib.Vector2 origin, float rotation, global::Raylib.Color tint)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            if (ReferenceEquals(nPatchInfo, null))
                throw new global::System.ArgumentNullException("nPatchInfo", "Cannot be null because it is passed by value.");
            var __arg1 = nPatchInfo.__Instance;
            if (ReferenceEquals(destRec, null))
                throw new global::System.ArgumentNullException("destRec", "Cannot be null because it is passed by value.");
            var __arg2 = destRec.__Instance;
            if (ReferenceEquals(origin, null))
                throw new global::System.ArgumentNullException("origin", "Cannot be null because it is passed by value.");
            var __arg3 = origin.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg5 = tint.__Instance;
            __Internal.DrawTextureNPatch(__arg0, __arg1, __arg2, *(global::Raylib.Vector2.__Internal*) __arg3, rotation, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static global::Raylib.Font GetFontDefault()
        {
            var __ret = new global::Raylib.Font.__Internal();
            __Internal.GetFontDefault(new IntPtr(&__ret));
            return global::Raylib.Font.__CreateInstance(__ret);
        }

        public static global::Raylib.Font LoadFont(string fileName)
        {
            var __ret = new global::Raylib.Font.__Internal();
            __Internal.LoadFont(new IntPtr(&__ret), fileName);
            return global::Raylib.Font.__CreateInstance(__ret);
        }

        public static global::Raylib.Font LoadFontEx(string fileName, int fontSize, ref int fontChars, int charsCount)
        {
            fixed (int* __fontChars2 = &fontChars)
            {
                var __arg2 = __fontChars2;
                var __ret = new global::Raylib.Font.__Internal();
                __Internal.LoadFontEx(new IntPtr(&__ret), fileName, fontSize, __arg2, charsCount);
                return global::Raylib.Font.__CreateInstance(__ret);
            }
        }

        public static global::Raylib.Font LoadFontFromImage(global::Raylib.Image image, global::Raylib.Color key, int firstChar)
        {
            if (ReferenceEquals(image, null))
                throw new global::System.ArgumentNullException("image", "Cannot be null because it is passed by value.");
            var __arg0 = image.__Instance;
            if (ReferenceEquals(key, null))
                throw new global::System.ArgumentNullException("key", "Cannot be null because it is passed by value.");
            var __arg1 = key.__Instance;
            var __ret = new global::Raylib.Font.__Internal();
            __Internal.LoadFontFromImage(new IntPtr(&__ret), __arg0, *(global::Raylib.Color.__Internal*) __arg1, firstChar);
            return global::Raylib.Font.__CreateInstance(__ret);
        }

        public static global::Raylib.CharInfo LoadFontData(string fileName, int fontSize, ref int fontChars, int charsCount, int type)
        {
            fixed (int* __fontChars2 = &fontChars)
            {
                var __arg2 = __fontChars2;
                var __ret = __Internal.LoadFontData(fileName, fontSize, __arg2, charsCount, type);
                global::Raylib.CharInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.CharInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Raylib.CharInfo) global::Raylib.CharInfo.NativeToManagedMap[__ret];
                else __result0 = global::Raylib.CharInfo.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static global::Raylib.Image GenImageFontAtlas(global::Raylib.CharInfo chars, global::Raylib.Rectangle recs, int charsCount, int fontSize, int padding, int packMethod)
        {
            var __arg0 = ReferenceEquals(chars, null) ? global::System.IntPtr.Zero : chars.__Instance;
            var ____arg1 = ReferenceEquals(recs, null) ? global::System.IntPtr.Zero : recs.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = new global::Raylib.Image.__Internal();
            __Internal.GenImageFontAtlas(new IntPtr(&__ret), __arg0, __arg1, charsCount, fontSize, padding, packMethod);
            return global::Raylib.Image.__CreateInstance(__ret);
        }

        public static void UnloadFont(global::Raylib.Font font)
        {
            if (ReferenceEquals(font, null))
                throw new global::System.ArgumentNullException("font", "Cannot be null because it is passed by value.");
            var __arg0 = font.__Instance;
            __Internal.UnloadFont(__arg0);
        }

        public static void DrawFPS(int posX, int posY)
        {
            __Internal.DrawFPS(posX, posY);
        }

        public static void DrawText(string text, int posX, int posY, int fontSize, global::Raylib.Color color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawText(text, posX, posY, fontSize, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawTextEx(global::Raylib.Font font, string text, global::Raylib.Vector2 position, float fontSize, float spacing, global::Raylib.Color tint)
        {
            if (ReferenceEquals(font, null))
                throw new global::System.ArgumentNullException("font", "Cannot be null because it is passed by value.");
            var __arg0 = font.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg2 = position.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg5 = tint.__Instance;
            __Internal.DrawTextEx(__arg0, text, *(global::Raylib.Vector2.__Internal*) __arg2, fontSize, spacing, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawTextRec(global::Raylib.Font font, string text, global::Raylib.Rectangle rec, float fontSize, float spacing, bool wordWrap, global::Raylib.Color tint)
        {
            if (ReferenceEquals(font, null))
                throw new global::System.ArgumentNullException("font", "Cannot be null because it is passed by value.");
            var __arg0 = font.__Instance;
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg2 = rec.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg6 = tint.__Instance;
            __Internal.DrawTextRec(__arg0, text, __arg2, fontSize, spacing, wordWrap, *(global::Raylib.Color.__Internal*) __arg6);
        }

        public static void DrawTextRecEx(global::Raylib.Font font, string text, global::Raylib.Rectangle rec, float fontSize, float spacing, bool wordWrap, global::Raylib.Color tint, int selectStart, int selectLength, global::Raylib.Color selectText, global::Raylib.Color selectBack)
        {
            if (ReferenceEquals(font, null))
                throw new global::System.ArgumentNullException("font", "Cannot be null because it is passed by value.");
            var __arg0 = font.__Instance;
            if (ReferenceEquals(rec, null))
                throw new global::System.ArgumentNullException("rec", "Cannot be null because it is passed by value.");
            var __arg2 = rec.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg6 = tint.__Instance;
            if (ReferenceEquals(selectText, null))
                throw new global::System.ArgumentNullException("selectText", "Cannot be null because it is passed by value.");
            var __arg9 = selectText.__Instance;
            if (ReferenceEquals(selectBack, null))
                throw new global::System.ArgumentNullException("selectBack", "Cannot be null because it is passed by value.");
            var __arg10 = selectBack.__Instance;
            __Internal.DrawTextRecEx(__arg0, text, __arg2, fontSize, spacing, wordWrap, *(global::Raylib.Color.__Internal*) __arg6, selectStart, selectLength, *(global::Raylib.Color.__Internal*) __arg9, *(global::Raylib.Color.__Internal*) __arg10);
        }

        public static int MeasureText(string text, int fontSize)
        {
            var __ret = __Internal.MeasureText(text, fontSize);
            return __ret;
        }

        public static global::Raylib.Vector2 MeasureTextEx(global::Raylib.Font font, string text, float fontSize, float spacing)
        {
            if (ReferenceEquals(font, null))
                throw new global::System.ArgumentNullException("font", "Cannot be null because it is passed by value.");
            var __arg0 = font.__Instance;
            var __ret = __Internal.MeasureTextEx(__arg0, text, fontSize, spacing);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static int GetGlyphIndex(global::Raylib.Font font, int character)
        {
            if (ReferenceEquals(font, null))
                throw new global::System.ArgumentNullException("font", "Cannot be null because it is passed by value.");
            var __arg0 = font.__Instance;
            var __ret = __Internal.GetGlyphIndex(__arg0, character);
            return __ret;
        }

        public static int GetNextCodepoint(string text, ref int bytesProcessed)
        {
            fixed (int* __bytesProcessed1 = &bytesProcessed)
            {
                var __arg1 = __bytesProcessed1;
                var __ret = __Internal.GetNextCodepoint(text, __arg1);
                return __ret;
            }
        }

        public static int* GetCodepoints(string text, ref int count)
        {
            fixed (int* __count1 = &count)
            {
                var __arg1 = __count1;
                var __ret = __Internal.GetCodepoints(text, __arg1);
                return __ret;
            }
        }

        public static bool TextIsEqual(string text1, string text2)
        {
            var __ret = __Internal.TextIsEqual(text1, text2);
            return __ret;
        }

        public static uint TextLength(string text)
        {
            var __ret = __Internal.TextLength(text);
            return __ret;
        }

        public static uint TextCountCodepoints(string text)
        {
            var __ret = __Internal.TextCountCodepoints(text);
            return __ret;
        }

        public static string TextFormat(string text)
        {
            var __ret = __Internal.TextFormat(text);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string TextSubtext(string text, int position, int length)
        {
            var __ret = __Internal.TextSubtext(text, position, length);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static sbyte* TextReplace(sbyte* text, string replace, string by)
        {
            var __ret = __Internal.TextReplace(text, replace, by);
            return __ret;
        }

        public static sbyte* TextInsert(string text, string insert, int position)
        {
            var __ret = __Internal.TextInsert(text, insert, position);
            return __ret;
        }

        public static string TextJoin(sbyte** textList, int count, string delimiter)
        {
            var __ret = __Internal.TextJoin(textList, count, delimiter);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static sbyte** TextSplit(string text, sbyte delimiter, ref int count)
        {
            fixed (int* __count2 = &count)
            {
                var __arg2 = __count2;
                var __ret = __Internal.TextSplit(text, delimiter, __arg2);
                return __ret;
            }
        }

        public static void TextAppend(sbyte* text, string append, ref int position)
        {
            fixed (int* __position2 = &position)
            {
                var __arg2 = __position2;
                __Internal.TextAppend(text, append, __arg2);
            }
        }

        public static int TextFindIndex(string text, string find)
        {
            var __ret = __Internal.TextFindIndex(text, find);
            return __ret;
        }

        public static string TextToUpper(string text)
        {
            var __ret = __Internal.TextToUpper(text);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string TextToLower(string text)
        {
            var __ret = __Internal.TextToLower(text);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static string TextToPascal(string text)
        {
            var __ret = __Internal.TextToPascal(text);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static int TextToInteger(string text)
        {
            var __ret = __Internal.TextToInteger(text);
            return __ret;
        }

        public static void DrawLine3D(global::Raylib.Vector3 startPos, global::Raylib.Vector3 endPos, global::Raylib.Color color)
        {
            if (ReferenceEquals(startPos, null))
                throw new global::System.ArgumentNullException("startPos", "Cannot be null because it is passed by value.");
            var __arg0 = startPos.__Instance;
            if (ReferenceEquals(endPos, null))
                throw new global::System.ArgumentNullException("endPos", "Cannot be null because it is passed by value.");
            var __arg1 = endPos.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawLine3D(__arg0, __arg1, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawCircle3D(global::Raylib.Vector3 center, float radius, global::Raylib.Vector3 rotationAxis, float rotationAngle, global::Raylib.Color color)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg0 = center.__Instance;
            if (ReferenceEquals(rotationAxis, null))
                throw new global::System.ArgumentNullException("rotationAxis", "Cannot be null because it is passed by value.");
            var __arg2 = rotationAxis.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawCircle3D(__arg0, radius, __arg2, rotationAngle, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawCube(global::Raylib.Vector3 position, float width, float height, float length, global::Raylib.Color color)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawCube(__arg0, width, height, length, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawCubeV(global::Raylib.Vector3 position, global::Raylib.Vector3 size, global::Raylib.Color color)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawCubeV(__arg0, __arg1, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawCubeWires(global::Raylib.Vector3 position, float width, float height, float length, global::Raylib.Color color)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawCubeWires(__arg0, width, height, length, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawCubeWiresV(global::Raylib.Vector3 position, global::Raylib.Vector3 size, global::Raylib.Color color)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawCubeWiresV(__arg0, __arg1, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawCubeTexture(global::Raylib.Texture2D texture, global::Raylib.Vector3 position, float width, float height, float length, global::Raylib.Color color)
        {
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg0 = texture.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg5 = color.__Instance;
            __Internal.DrawCubeTexture(__arg0, __arg1, width, height, length, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawSphere(global::Raylib.Vector3 centerPos, float radius, global::Raylib.Color color)
        {
            if (ReferenceEquals(centerPos, null))
                throw new global::System.ArgumentNullException("centerPos", "Cannot be null because it is passed by value.");
            var __arg0 = centerPos.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawSphere(__arg0, radius, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawSphereEx(global::Raylib.Vector3 centerPos, float radius, int rings, int slices, global::Raylib.Color color)
        {
            if (ReferenceEquals(centerPos, null))
                throw new global::System.ArgumentNullException("centerPos", "Cannot be null because it is passed by value.");
            var __arg0 = centerPos.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawSphereEx(__arg0, radius, rings, slices, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawSphereWires(global::Raylib.Vector3 centerPos, float radius, int rings, int slices, global::Raylib.Color color)
        {
            if (ReferenceEquals(centerPos, null))
                throw new global::System.ArgumentNullException("centerPos", "Cannot be null because it is passed by value.");
            var __arg0 = centerPos.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg4 = color.__Instance;
            __Internal.DrawSphereWires(__arg0, radius, rings, slices, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawCylinder(global::Raylib.Vector3 position, float radiusTop, float radiusBottom, float height, int slices, global::Raylib.Color color)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg5 = color.__Instance;
            __Internal.DrawCylinder(__arg0, radiusTop, radiusBottom, height, slices, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawCylinderWires(global::Raylib.Vector3 position, float radiusTop, float radiusBottom, float height, int slices, global::Raylib.Color color)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg5 = color.__Instance;
            __Internal.DrawCylinderWires(__arg0, radiusTop, radiusBottom, height, slices, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawPlane(global::Raylib.Vector3 centerPos, global::Raylib.Vector2 size, global::Raylib.Color color)
        {
            if (ReferenceEquals(centerPos, null))
                throw new global::System.ArgumentNullException("centerPos", "Cannot be null because it is passed by value.");
            var __arg0 = centerPos.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.DrawPlane(__arg0, *(global::Raylib.Vector2.__Internal*) __arg1, *(global::Raylib.Color.__Internal*) __arg2);
        }

        public static void DrawRay(global::Raylib.Ray ray, global::Raylib.Color color)
        {
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is passed by value.");
            var __arg0 = ray.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.DrawRay(__arg0, *(global::Raylib.Color.__Internal*) __arg1);
        }

        public static void DrawGrid(int slices, float spacing)
        {
            __Internal.DrawGrid(slices, spacing);
        }

        public static void DrawGizmo(global::Raylib.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg0 = position.__Instance;
            __Internal.DrawGizmo(__arg0);
        }

        public static global::Raylib.Model LoadModel(string fileName)
        {
            var __ret = new global::Raylib.Model.__Internal();
            __Internal.LoadModel(new IntPtr(&__ret), fileName);
            return global::Raylib.Model.__CreateInstance(__ret);
        }

        public static global::Raylib.Model LoadModelFromMesh(global::Raylib.Mesh mesh)
        {
            if (ReferenceEquals(mesh, null))
                throw new global::System.ArgumentNullException("mesh", "Cannot be null because it is passed by value.");
            var __arg0 = mesh.__Instance;
            var __ret = new global::Raylib.Model.__Internal();
            __Internal.LoadModelFromMesh(new IntPtr(&__ret), __arg0);
            return global::Raylib.Model.__CreateInstance(__ret);
        }

        public static void UnloadModel(global::Raylib.Model model)
        {
            if (ReferenceEquals(model, null))
                throw new global::System.ArgumentNullException("model", "Cannot be null because it is passed by value.");
            var __arg0 = model.__Instance;
            __Internal.UnloadModel(__arg0);
        }

        public static global::Raylib.Mesh LoadMeshes(string fileName, ref int meshCount)
        {
            fixed (int* __meshCount1 = &meshCount)
            {
                var __arg1 = __meshCount1;
                var __ret = __Internal.LoadMeshes(fileName, __arg1);
                global::Raylib.Mesh __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.Mesh.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Raylib.Mesh) global::Raylib.Mesh.NativeToManagedMap[__ret];
                else __result0 = global::Raylib.Mesh.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static void ExportMesh(global::Raylib.Mesh mesh, string fileName)
        {
            if (ReferenceEquals(mesh, null))
                throw new global::System.ArgumentNullException("mesh", "Cannot be null because it is passed by value.");
            var __arg0 = mesh.__Instance;
            __Internal.ExportMesh(__arg0, fileName);
        }

        public static void UnloadMesh(global::Raylib.Mesh mesh)
        {
            if (ReferenceEquals(mesh, null))
                throw new global::System.ArgumentNullException("mesh", "Cannot be null because it is passed by value.");
            var __arg0 = mesh.__Instance;
            __Internal.UnloadMesh(__arg0);
        }

        public static global::Raylib.Material LoadMaterials(string fileName, ref int materialCount)
        {
            fixed (int* __materialCount1 = &materialCount)
            {
                var __arg1 = __materialCount1;
                var __ret = __Internal.LoadMaterials(fileName, __arg1);
                global::Raylib.Material __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.Material.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Raylib.Material) global::Raylib.Material.NativeToManagedMap[__ret];
                else __result0 = global::Raylib.Material.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static global::Raylib.Material LoadMaterialDefault()
        {
            var __ret = new global::Raylib.Material.__Internal();
            __Internal.LoadMaterialDefault(new IntPtr(&__ret));
            return global::Raylib.Material.__CreateInstance(__ret);
        }

        public static void UnloadMaterial(global::Raylib.Material material)
        {
            if (ReferenceEquals(material, null))
                throw new global::System.ArgumentNullException("material", "Cannot be null because it is passed by value.");
            var __arg0 = material.__Instance;
            __Internal.UnloadMaterial(__arg0);
        }

        public static void SetMaterialTexture(global::Raylib.Material material, int mapType, global::Raylib.Texture2D texture)
        {
            var __arg0 = ReferenceEquals(material, null) ? global::System.IntPtr.Zero : material.__Instance;
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg2 = texture.__Instance;
            __Internal.SetMaterialTexture(__arg0, mapType, __arg2);
        }

        public static void SetModelMeshMaterial(global::Raylib.Model model, int meshId, int materialId)
        {
            var __arg0 = ReferenceEquals(model, null) ? global::System.IntPtr.Zero : model.__Instance;
            __Internal.SetModelMeshMaterial(__arg0, meshId, materialId);
        }

        public static global::Raylib.ModelAnimation LoadModelAnimations(string fileName, ref int animsCount)
        {
            fixed (int* __animsCount1 = &animsCount)
            {
                var __arg1 = __animsCount1;
                var __ret = __Internal.LoadModelAnimations(fileName, __arg1);
                global::Raylib.ModelAnimation __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.ModelAnimation.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Raylib.ModelAnimation) global::Raylib.ModelAnimation.NativeToManagedMap[__ret];
                else __result0 = global::Raylib.ModelAnimation.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static void UpdateModelAnimation(global::Raylib.Model model, global::Raylib.ModelAnimation anim, int frame)
        {
            if (ReferenceEquals(model, null))
                throw new global::System.ArgumentNullException("model", "Cannot be null because it is passed by value.");
            var __arg0 = model.__Instance;
            if (ReferenceEquals(anim, null))
                throw new global::System.ArgumentNullException("anim", "Cannot be null because it is passed by value.");
            var __arg1 = anim.__Instance;
            __Internal.UpdateModelAnimation(__arg0, __arg1, frame);
        }

        public static void UnloadModelAnimation(global::Raylib.ModelAnimation anim)
        {
            if (ReferenceEquals(anim, null))
                throw new global::System.ArgumentNullException("anim", "Cannot be null because it is passed by value.");
            var __arg0 = anim.__Instance;
            __Internal.UnloadModelAnimation(__arg0);
        }

        public static bool IsModelAnimationValid(global::Raylib.Model model, global::Raylib.ModelAnimation anim)
        {
            if (ReferenceEquals(model, null))
                throw new global::System.ArgumentNullException("model", "Cannot be null because it is passed by value.");
            var __arg0 = model.__Instance;
            if (ReferenceEquals(anim, null))
                throw new global::System.ArgumentNullException("anim", "Cannot be null because it is passed by value.");
            var __arg1 = anim.__Instance;
            var __ret = __Internal.IsModelAnimationValid(__arg0, __arg1);
            return __ret;
        }

        public static global::Raylib.Mesh GenMeshPoly(int sides, float radius)
        {
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshPoly(new IntPtr(&__ret), sides, radius);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static global::Raylib.Mesh GenMeshPlane(float width, float length, int resX, int resZ)
        {
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshPlane(new IntPtr(&__ret), width, length, resX, resZ);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static global::Raylib.Mesh GenMeshCube(float width, float height, float length)
        {
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshCube(new IntPtr(&__ret), width, height, length);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static global::Raylib.Mesh GenMeshSphere(float radius, int rings, int slices)
        {
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshSphere(new IntPtr(&__ret), radius, rings, slices);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static global::Raylib.Mesh GenMeshHemiSphere(float radius, int rings, int slices)
        {
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshHemiSphere(new IntPtr(&__ret), radius, rings, slices);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static global::Raylib.Mesh GenMeshCylinder(float radius, float height, int slices)
        {
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshCylinder(new IntPtr(&__ret), radius, height, slices);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static global::Raylib.Mesh GenMeshTorus(float radius, float size, int radSeg, int sides)
        {
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshTorus(new IntPtr(&__ret), radius, size, radSeg, sides);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static global::Raylib.Mesh GenMeshKnot(float radius, float size, int radSeg, int sides)
        {
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshKnot(new IntPtr(&__ret), radius, size, radSeg, sides);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static global::Raylib.Mesh GenMeshHeightmap(global::Raylib.Image heightmap, global::Raylib.Vector3 size)
        {
            if (ReferenceEquals(heightmap, null))
                throw new global::System.ArgumentNullException("heightmap", "Cannot be null because it is passed by value.");
            var __arg0 = heightmap.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshHeightmap(new IntPtr(&__ret), __arg0, __arg1);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static global::Raylib.Mesh GenMeshCubicmap(global::Raylib.Image cubicmap, global::Raylib.Vector3 cubeSize)
        {
            if (ReferenceEquals(cubicmap, null))
                throw new global::System.ArgumentNullException("cubicmap", "Cannot be null because it is passed by value.");
            var __arg0 = cubicmap.__Instance;
            if (ReferenceEquals(cubeSize, null))
                throw new global::System.ArgumentNullException("cubeSize", "Cannot be null because it is passed by value.");
            var __arg1 = cubeSize.__Instance;
            var __ret = new global::Raylib.Mesh.__Internal();
            __Internal.GenMeshCubicmap(new IntPtr(&__ret), __arg0, __arg1);
            return global::Raylib.Mesh.__CreateInstance(__ret);
        }

        public static void MeshTangents(global::Raylib.Mesh mesh)
        {
            var __arg0 = ReferenceEquals(mesh, null) ? global::System.IntPtr.Zero : mesh.__Instance;
            __Internal.MeshTangents(__arg0);
        }

        public static void MeshBinormals(global::Raylib.Mesh mesh)
        {
            var __arg0 = ReferenceEquals(mesh, null) ? global::System.IntPtr.Zero : mesh.__Instance;
            __Internal.MeshBinormals(__arg0);
        }

        public static void DrawModel(global::Raylib.Model model, global::Raylib.Vector3 position, float scale, global::Raylib.Color tint)
        {
            if (ReferenceEquals(model, null))
                throw new global::System.ArgumentNullException("model", "Cannot be null because it is passed by value.");
            var __arg0 = model.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg3 = tint.__Instance;
            __Internal.DrawModel(__arg0, __arg1, scale, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawModelEx(global::Raylib.Model model, global::Raylib.Vector3 position, global::Raylib.Vector3 rotationAxis, float rotationAngle, global::Raylib.Vector3 scale, global::Raylib.Color tint)
        {
            if (ReferenceEquals(model, null))
                throw new global::System.ArgumentNullException("model", "Cannot be null because it is passed by value.");
            var __arg0 = model.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(rotationAxis, null))
                throw new global::System.ArgumentNullException("rotationAxis", "Cannot be null because it is passed by value.");
            var __arg2 = rotationAxis.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is passed by value.");
            var __arg4 = scale.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg5 = tint.__Instance;
            __Internal.DrawModelEx(__arg0, __arg1, __arg2, rotationAngle, __arg4, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawModelWires(global::Raylib.Model model, global::Raylib.Vector3 position, float scale, global::Raylib.Color tint)
        {
            if (ReferenceEquals(model, null))
                throw new global::System.ArgumentNullException("model", "Cannot be null because it is passed by value.");
            var __arg0 = model.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg3 = tint.__Instance;
            __Internal.DrawModelWires(__arg0, __arg1, scale, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static void DrawModelWiresEx(global::Raylib.Model model, global::Raylib.Vector3 position, global::Raylib.Vector3 rotationAxis, float rotationAngle, global::Raylib.Vector3 scale, global::Raylib.Color tint)
        {
            if (ReferenceEquals(model, null))
                throw new global::System.ArgumentNullException("model", "Cannot be null because it is passed by value.");
            var __arg0 = model.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(rotationAxis, null))
                throw new global::System.ArgumentNullException("rotationAxis", "Cannot be null because it is passed by value.");
            var __arg2 = rotationAxis.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is passed by value.");
            var __arg4 = scale.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg5 = tint.__Instance;
            __Internal.DrawModelWiresEx(__arg0, __arg1, __arg2, rotationAngle, __arg4, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static void DrawBoundingBox(global::Raylib.BoundingBox box, global::Raylib.Color color)
        {
            if (ReferenceEquals(box, null))
                throw new global::System.ArgumentNullException("box", "Cannot be null because it is passed by value.");
            var __arg0 = box.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.DrawBoundingBox(__arg0, *(global::Raylib.Color.__Internal*) __arg1);
        }

        public static void DrawBillboard(global::Raylib.Camera3D camera, global::Raylib.Texture2D texture, global::Raylib.Vector3 center, float size, global::Raylib.Color tint)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg0 = camera.__Instance;
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg1 = texture.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg2 = center.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg4 = tint.__Instance;
            __Internal.DrawBillboard(__arg0, __arg1, __arg2, size, *(global::Raylib.Color.__Internal*) __arg4);
        }

        public static void DrawBillboardRec(global::Raylib.Camera3D camera, global::Raylib.Texture2D texture, global::Raylib.Rectangle sourceRec, global::Raylib.Vector3 center, float size, global::Raylib.Color tint)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is passed by value.");
            var __arg0 = camera.__Instance;
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg1 = texture.__Instance;
            if (ReferenceEquals(sourceRec, null))
                throw new global::System.ArgumentNullException("sourceRec", "Cannot be null because it is passed by value.");
            var __arg2 = sourceRec.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg3 = center.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg5 = tint.__Instance;
            __Internal.DrawBillboardRec(__arg0, __arg1, __arg2, __arg3, size, *(global::Raylib.Color.__Internal*) __arg5);
        }

        public static bool CheckCollisionSpheres(global::Raylib.Vector3 centerA, float radiusA, global::Raylib.Vector3 centerB, float radiusB)
        {
            if (ReferenceEquals(centerA, null))
                throw new global::System.ArgumentNullException("centerA", "Cannot be null because it is passed by value.");
            var __arg0 = centerA.__Instance;
            if (ReferenceEquals(centerB, null))
                throw new global::System.ArgumentNullException("centerB", "Cannot be null because it is passed by value.");
            var __arg2 = centerB.__Instance;
            var __ret = __Internal.CheckCollisionSpheres(__arg0, radiusA, __arg2, radiusB);
            return __ret;
        }

        public static bool CheckCollisionBoxes(global::Raylib.BoundingBox box1, global::Raylib.BoundingBox box2)
        {
            if (ReferenceEquals(box1, null))
                throw new global::System.ArgumentNullException("box1", "Cannot be null because it is passed by value.");
            var __arg0 = box1.__Instance;
            if (ReferenceEquals(box2, null))
                throw new global::System.ArgumentNullException("box2", "Cannot be null because it is passed by value.");
            var __arg1 = box2.__Instance;
            var __ret = __Internal.CheckCollisionBoxes(__arg0, __arg1);
            return __ret;
        }

        public static bool CheckCollisionBoxSphere(global::Raylib.BoundingBox box, global::Raylib.Vector3 center, float radius)
        {
            if (ReferenceEquals(box, null))
                throw new global::System.ArgumentNullException("box", "Cannot be null because it is passed by value.");
            var __arg0 = box.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            var __ret = __Internal.CheckCollisionBoxSphere(__arg0, __arg1, radius);
            return __ret;
        }

        public static bool CheckCollisionRaySphere(global::Raylib.Ray ray, global::Raylib.Vector3 center, float radius)
        {
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is passed by value.");
            var __arg0 = ray.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            var __ret = __Internal.CheckCollisionRaySphere(__arg0, __arg1, radius);
            return __ret;
        }

        public static bool CheckCollisionRaySphereEx(global::Raylib.Ray ray, global::Raylib.Vector3 center, float radius, global::Raylib.Vector3 collisionPoint)
        {
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is passed by value.");
            var __arg0 = ray.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            var __arg3 = ReferenceEquals(collisionPoint, null) ? global::System.IntPtr.Zero : collisionPoint.__Instance;
            var __ret = __Internal.CheckCollisionRaySphereEx(__arg0, __arg1, radius, __arg3);
            return __ret;
        }

        public static bool CheckCollisionRayBox(global::Raylib.Ray ray, global::Raylib.BoundingBox box)
        {
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is passed by value.");
            var __arg0 = ray.__Instance;
            if (ReferenceEquals(box, null))
                throw new global::System.ArgumentNullException("box", "Cannot be null because it is passed by value.");
            var __arg1 = box.__Instance;
            var __ret = __Internal.CheckCollisionRayBox(__arg0, __arg1);
            return __ret;
        }

        public static global::Raylib.RayHitInfo GetCollisionRayModel(global::Raylib.Ray ray, global::Raylib.Model model)
        {
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is passed by value.");
            var __arg0 = ray.__Instance;
            if (ReferenceEquals(model, null))
                throw new global::System.ArgumentNullException("model", "Cannot be null because it is passed by value.");
            var __arg1 = model.__Instance;
            var __ret = new global::Raylib.RayHitInfo.__Internal();
            __Internal.GetCollisionRayModel(new IntPtr(&__ret), __arg0, __arg1);
            return global::Raylib.RayHitInfo.__CreateInstance(__ret);
        }

        public static global::Raylib.RayHitInfo GetCollisionRayTriangle(global::Raylib.Ray ray, global::Raylib.Vector3 p1, global::Raylib.Vector3 p2, global::Raylib.Vector3 p3)
        {
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is passed by value.");
            var __arg0 = ray.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            var __ret = new global::Raylib.RayHitInfo.__Internal();
            __Internal.GetCollisionRayTriangle(new IntPtr(&__ret), __arg0, __arg1, __arg2, __arg3);
            return global::Raylib.RayHitInfo.__CreateInstance(__ret);
        }

        public static global::Raylib.RayHitInfo GetCollisionRayGround(global::Raylib.Ray ray, float groundHeight)
        {
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is passed by value.");
            var __arg0 = ray.__Instance;
            var __ret = new global::Raylib.RayHitInfo.__Internal();
            __Internal.GetCollisionRayGround(new IntPtr(&__ret), __arg0, groundHeight);
            return global::Raylib.RayHitInfo.__CreateInstance(__ret);
        }

        public static sbyte* LoadText(string fileName)
        {
            var __ret = __Internal.LoadText(fileName);
            return __ret;
        }

        public static global::Raylib.Shader LoadShader(string vsFileName, string fsFileName)
        {
            var __ret = new global::Raylib.Shader.__Internal();
            __Internal.LoadShader(new IntPtr(&__ret), vsFileName, fsFileName);
            return global::Raylib.Shader.__CreateInstance(__ret);
        }

        public static global::Raylib.Shader LoadShaderCode(string vsCode, string fsCode)
        {
            var __ret = new global::Raylib.Shader.__Internal();
            __Internal.LoadShaderCode(new IntPtr(&__ret), vsCode, fsCode);
            return global::Raylib.Shader.__CreateInstance(__ret);
        }

        public static void UnloadShader(global::Raylib.Shader shader)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            __Internal.UnloadShader(__arg0);
        }

        public static global::Raylib.Shader GetShaderDefault()
        {
            var __ret = new global::Raylib.Shader.__Internal();
            __Internal.GetShaderDefault(new IntPtr(&__ret));
            return global::Raylib.Shader.__CreateInstance(__ret);
        }

        public static global::Raylib.Texture2D GetTextureDefault()
        {
            var __ret = new global::Raylib.Texture2D.__Internal();
            __Internal.GetTextureDefault(new IntPtr(&__ret));
            return global::Raylib.Texture2D.__CreateInstance(__ret);
        }

        public static int GetShaderLocation(global::Raylib.Shader shader, string uniformName)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            var __ret = __Internal.GetShaderLocation(__arg0, uniformName);
            return __ret;
        }

        public static void SetShaderValue(global::Raylib.Shader shader, int uniformLoc, global::System.IntPtr value, int uniformType)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            __Internal.SetShaderValue(__arg0, uniformLoc, value, uniformType);
        }

        public static void SetShaderValueV(global::Raylib.Shader shader, int uniformLoc, global::System.IntPtr value, int uniformType, int count)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            __Internal.SetShaderValueV(__arg0, uniformLoc, value, uniformType, count);
        }

        public static void SetShaderValueMatrix(global::Raylib.Shader shader, int uniformLoc, global::Raylib.Matrix mat)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            if (ReferenceEquals(mat, null))
                throw new global::System.ArgumentNullException("mat", "Cannot be null because it is passed by value.");
            var __arg2 = mat.__Instance;
            __Internal.SetShaderValueMatrix(__arg0, uniformLoc, __arg2);
        }

        public static void SetShaderValueTexture(global::Raylib.Shader shader, int uniformLoc, global::Raylib.Texture2D texture)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg2 = texture.__Instance;
            __Internal.SetShaderValueTexture(__arg0, uniformLoc, __arg2);
        }

        public static void SetMatrixProjection(global::Raylib.Matrix proj)
        {
            if (ReferenceEquals(proj, null))
                throw new global::System.ArgumentNullException("proj", "Cannot be null because it is passed by value.");
            var __arg0 = proj.__Instance;
            __Internal.SetMatrixProjection(__arg0);
        }

        public static void SetMatrixModelview(global::Raylib.Matrix view)
        {
            if (ReferenceEquals(view, null))
                throw new global::System.ArgumentNullException("view", "Cannot be null because it is passed by value.");
            var __arg0 = view.__Instance;
            __Internal.SetMatrixModelview(__arg0);
        }

        public static global::Raylib.Matrix GetMatrixModelview()
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.GetMatrixModelview(new IntPtr(&__ret));
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Texture2D GenTextureCubemap(global::Raylib.Shader shader, global::Raylib.Texture2D skyHDR, int size)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            if (ReferenceEquals(skyHDR, null))
                throw new global::System.ArgumentNullException("skyHDR", "Cannot be null because it is passed by value.");
            var __arg1 = skyHDR.__Instance;
            var __ret = new global::Raylib.Texture2D.__Internal();
            __Internal.GenTextureCubemap(new IntPtr(&__ret), __arg0, __arg1, size);
            return global::Raylib.Texture2D.__CreateInstance(__ret);
        }

        public static global::Raylib.Texture2D GenTextureIrradiance(global::Raylib.Shader shader, global::Raylib.Texture2D cubemap, int size)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            if (ReferenceEquals(cubemap, null))
                throw new global::System.ArgumentNullException("cubemap", "Cannot be null because it is passed by value.");
            var __arg1 = cubemap.__Instance;
            var __ret = new global::Raylib.Texture2D.__Internal();
            __Internal.GenTextureIrradiance(new IntPtr(&__ret), __arg0, __arg1, size);
            return global::Raylib.Texture2D.__CreateInstance(__ret);
        }

        public static global::Raylib.Texture2D GenTexturePrefilter(global::Raylib.Shader shader, global::Raylib.Texture2D cubemap, int size)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            if (ReferenceEquals(cubemap, null))
                throw new global::System.ArgumentNullException("cubemap", "Cannot be null because it is passed by value.");
            var __arg1 = cubemap.__Instance;
            var __ret = new global::Raylib.Texture2D.__Internal();
            __Internal.GenTexturePrefilter(new IntPtr(&__ret), __arg0, __arg1, size);
            return global::Raylib.Texture2D.__CreateInstance(__ret);
        }

        public static global::Raylib.Texture2D GenTextureBRDF(global::Raylib.Shader shader, int size)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            var __ret = new global::Raylib.Texture2D.__Internal();
            __Internal.GenTextureBRDF(new IntPtr(&__ret), __arg0, size);
            return global::Raylib.Texture2D.__CreateInstance(__ret);
        }

        public static void BeginShaderMode(global::Raylib.Shader shader)
        {
            if (ReferenceEquals(shader, null))
                throw new global::System.ArgumentNullException("shader", "Cannot be null because it is passed by value.");
            var __arg0 = shader.__Instance;
            __Internal.BeginShaderMode(__arg0);
        }

        public static void EndShaderMode()
        {
            __Internal.EndShaderMode();
        }

        public static void BeginBlendMode(int mode)
        {
            __Internal.BeginBlendMode(mode);
        }

        public static void EndBlendMode()
        {
            __Internal.EndBlendMode();
        }

        public static void InitVrSimulator()
        {
            __Internal.InitVrSimulator();
        }

        public static void CloseVrSimulator()
        {
            __Internal.CloseVrSimulator();
        }

        public static void UpdateVrTracking(global::Raylib.Camera3D camera)
        {
            var __arg0 = ReferenceEquals(camera, null) ? global::System.IntPtr.Zero : camera.__Instance;
            __Internal.UpdateVrTracking(__arg0);
        }

        public static void SetVrConfiguration(global::Raylib.VrDeviceInfo info, global::Raylib.Shader distortion)
        {
            if (ReferenceEquals(info, null))
                throw new global::System.ArgumentNullException("info", "Cannot be null because it is passed by value.");
            var __arg0 = info.__Instance;
            if (ReferenceEquals(distortion, null))
                throw new global::System.ArgumentNullException("distortion", "Cannot be null because it is passed by value.");
            var __arg1 = distortion.__Instance;
            __Internal.SetVrConfiguration(__arg0, __arg1);
        }

        public static bool IsVrSimulatorReady()
        {
            var __ret = __Internal.IsVrSimulatorReady();
            return __ret;
        }

        public static void ToggleVrMode()
        {
            __Internal.ToggleVrMode();
        }

        public static void BeginVrDrawing()
        {
            __Internal.BeginVrDrawing();
        }

        public static void EndVrDrawing()
        {
            __Internal.EndVrDrawing();
        }

        public static void InitAudioDevice()
        {
            __Internal.InitAudioDevice();
        }

        public static void CloseAudioDevice()
        {
            __Internal.CloseAudioDevice();
        }

        public static bool IsAudioDeviceReady()
        {
            var __ret = __Internal.IsAudioDeviceReady();
            return __ret;
        }

        public static void SetMasterVolume(float volume)
        {
            __Internal.SetMasterVolume(volume);
        }

        public static global::Raylib.Wave LoadWave(string fileName)
        {
            var __ret = new global::Raylib.Wave.__Internal();
            __Internal.LoadWave(new IntPtr(&__ret), fileName);
            return global::Raylib.Wave.__CreateInstance(__ret);
        }

        public static global::Raylib.Sound LoadSound(string fileName)
        {
            var __ret = new global::Raylib.Sound.__Internal();
            __Internal.LoadSound(new IntPtr(&__ret), fileName);
            return global::Raylib.Sound.__CreateInstance(__ret);
        }

        public static global::Raylib.Sound LoadSoundFromWave(global::Raylib.Wave wave)
        {
            if (ReferenceEquals(wave, null))
                throw new global::System.ArgumentNullException("wave", "Cannot be null because it is passed by value.");
            var __arg0 = wave.__Instance;
            var __ret = new global::Raylib.Sound.__Internal();
            __Internal.LoadSoundFromWave(new IntPtr(&__ret), __arg0);
            return global::Raylib.Sound.__CreateInstance(__ret);
        }

        public static void UpdateSound(global::Raylib.Sound sound, global::System.IntPtr data, int samplesCount)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            __Internal.UpdateSound(__arg0, data, samplesCount);
        }

        public static void UnloadWave(global::Raylib.Wave wave)
        {
            if (ReferenceEquals(wave, null))
                throw new global::System.ArgumentNullException("wave", "Cannot be null because it is passed by value.");
            var __arg0 = wave.__Instance;
            __Internal.UnloadWave(__arg0);
        }

        public static void UnloadSound(global::Raylib.Sound sound)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            __Internal.UnloadSound(__arg0);
        }

        public static void ExportWave(global::Raylib.Wave wave, string fileName)
        {
            if (ReferenceEquals(wave, null))
                throw new global::System.ArgumentNullException("wave", "Cannot be null because it is passed by value.");
            var __arg0 = wave.__Instance;
            __Internal.ExportWave(__arg0, fileName);
        }

        public static void ExportWaveAsCode(global::Raylib.Wave wave, string fileName)
        {
            if (ReferenceEquals(wave, null))
                throw new global::System.ArgumentNullException("wave", "Cannot be null because it is passed by value.");
            var __arg0 = wave.__Instance;
            __Internal.ExportWaveAsCode(__arg0, fileName);
        }

        public static void PlaySound(global::Raylib.Sound sound)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            __Internal.PlaySound(__arg0);
        }

        public static void StopSound(global::Raylib.Sound sound)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            __Internal.StopSound(__arg0);
        }

        public static void PauseSound(global::Raylib.Sound sound)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            __Internal.PauseSound(__arg0);
        }

        public static void ResumeSound(global::Raylib.Sound sound)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            __Internal.ResumeSound(__arg0);
        }

        public static void PlaySoundMulti(global::Raylib.Sound sound)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            __Internal.PlaySoundMulti(__arg0);
        }

        public static void StopSoundMulti()
        {
            __Internal.StopSoundMulti();
        }

        public static int GetSoundsPlaying()
        {
            var __ret = __Internal.GetSoundsPlaying();
            return __ret;
        }

        public static bool IsSoundPlaying(global::Raylib.Sound sound)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            var __ret = __Internal.IsSoundPlaying(__arg0);
            return __ret;
        }

        public static void SetSoundVolume(global::Raylib.Sound sound, float volume)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            __Internal.SetSoundVolume(__arg0, volume);
        }

        public static void SetSoundPitch(global::Raylib.Sound sound, float pitch)
        {
            if (ReferenceEquals(sound, null))
                throw new global::System.ArgumentNullException("sound", "Cannot be null because it is passed by value.");
            var __arg0 = sound.__Instance;
            __Internal.SetSoundPitch(__arg0, pitch);
        }

        public static void WaveFormat(global::Raylib.Wave wave, int sampleRate, int sampleSize, int channels)
        {
            var __arg0 = ReferenceEquals(wave, null) ? global::System.IntPtr.Zero : wave.__Instance;
            __Internal.WaveFormat(__arg0, sampleRate, sampleSize, channels);
        }

        public static void WaveCrop(global::Raylib.Wave wave, int initSample, int finalSample)
        {
            var __arg0 = ReferenceEquals(wave, null) ? global::System.IntPtr.Zero : wave.__Instance;
            __Internal.WaveCrop(__arg0, initSample, finalSample);
        }

        public static float* GetWaveData(global::Raylib.Wave wave)
        {
            if (ReferenceEquals(wave, null))
                throw new global::System.ArgumentNullException("wave", "Cannot be null because it is passed by value.");
            var __arg0 = wave.__Instance;
            var __ret = __Internal.GetWaveData(__arg0);
            return __ret;
        }

        public static global::Raylib.Music LoadMusicStream(string fileName)
        {
            var __ret = new global::Raylib.Music.__Internal();
            __Internal.LoadMusicStream(new IntPtr(&__ret), fileName);
            return global::Raylib.Music.__CreateInstance(__ret);
        }

        public static void UnloadMusicStream(global::Raylib.Music music)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            __Internal.UnloadMusicStream(__arg0);
        }

        public static void PlayMusicStream(global::Raylib.Music music)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            __Internal.PlayMusicStream(__arg0);
        }

        public static void UpdateMusicStream(global::Raylib.Music music)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            __Internal.UpdateMusicStream(__arg0);
        }

        public static void StopMusicStream(global::Raylib.Music music)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            __Internal.StopMusicStream(__arg0);
        }

        public static void PauseMusicStream(global::Raylib.Music music)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            __Internal.PauseMusicStream(__arg0);
        }

        public static void ResumeMusicStream(global::Raylib.Music music)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            __Internal.ResumeMusicStream(__arg0);
        }

        public static bool IsMusicPlaying(global::Raylib.Music music)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            var __ret = __Internal.IsMusicPlaying(__arg0);
            return __ret;
        }

        public static void SetMusicVolume(global::Raylib.Music music, float volume)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            __Internal.SetMusicVolume(__arg0, volume);
        }

        public static void SetMusicPitch(global::Raylib.Music music, float pitch)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            __Internal.SetMusicPitch(__arg0, pitch);
        }

        public static void SetMusicLoopCount(global::Raylib.Music music, int count)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            __Internal.SetMusicLoopCount(__arg0, count);
        }

        public static float GetMusicTimeLength(global::Raylib.Music music)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            var __ret = __Internal.GetMusicTimeLength(__arg0);
            return __ret;
        }

        public static float GetMusicTimePlayed(global::Raylib.Music music)
        {
            if (ReferenceEquals(music, null))
                throw new global::System.ArgumentNullException("music", "Cannot be null because it is passed by value.");
            var __arg0 = music.__Instance;
            var __ret = __Internal.GetMusicTimePlayed(__arg0);
            return __ret;
        }

        public static global::Raylib.AudioStream InitAudioStream(uint sampleRate, uint sampleSize, uint channels)
        {
            var __ret = new global::Raylib.AudioStream.__Internal();
            __Internal.InitAudioStream(new IntPtr(&__ret), sampleRate, sampleSize, channels);
            return global::Raylib.AudioStream.__CreateInstance(__ret);
        }

        public static void UpdateAudioStream(global::Raylib.AudioStream stream, global::System.IntPtr data, int samplesCount)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            __Internal.UpdateAudioStream(__arg0, data, samplesCount);
        }

        public static void CloseAudioStream(global::Raylib.AudioStream stream)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            __Internal.CloseAudioStream(__arg0);
        }

        public static bool IsAudioStreamProcessed(global::Raylib.AudioStream stream)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            var __ret = __Internal.IsAudioStreamProcessed(__arg0);
            return __ret;
        }

        public static void PlayAudioStream(global::Raylib.AudioStream stream)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            __Internal.PlayAudioStream(__arg0);
        }

        public static void PauseAudioStream(global::Raylib.AudioStream stream)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            __Internal.PauseAudioStream(__arg0);
        }

        public static void ResumeAudioStream(global::Raylib.AudioStream stream)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            __Internal.ResumeAudioStream(__arg0);
        }

        public static bool IsAudioStreamPlaying(global::Raylib.AudioStream stream)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            var __ret = __Internal.IsAudioStreamPlaying(__arg0);
            return __ret;
        }

        public static void StopAudioStream(global::Raylib.AudioStream stream)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            __Internal.StopAudioStream(__arg0);
        }

        public static void SetAudioStreamVolume(global::Raylib.AudioStream stream, float volume)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            __Internal.SetAudioStreamVolume(__arg0, volume);
        }

        public static void SetAudioStreamPitch(global::Raylib.AudioStream stream, float pitch)
        {
            if (ReferenceEquals(stream, null))
                throw new global::System.ArgumentNullException("stream", "Cannot be null because it is passed by value.");
            var __arg0 = stream.__Instance;
            __Internal.SetAudioStreamPitch(__arg0, pitch);
        }
    }

    public unsafe partial class Float3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed float v[3];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0float3@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Float3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Float3>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Float3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Float3(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Float3 __CreateInstance(global::Raylib.Float3.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Float3(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Float3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Float3.__Internal));
            *(global::Raylib.Float3.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Float3(global::Raylib.Float3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Float3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Float3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Float3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Float3(global::Raylib.Float3 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Float3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Float3.__Internal*) __Instance) = *((global::Raylib.Float3.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Float3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float[] V
        {
            get
            {
                float[] __value = null;
                if (((global::Raylib.Float3.__Internal*) __Instance)->v != null)
                {
                    __value = new float[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::Raylib.Float3.__Internal*) __Instance)->v[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::Raylib.Float3.__Internal*)__Instance)->v[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class Float16 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed float v[16];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0float16@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Float16> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Float16>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Float16 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Float16(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Float16 __CreateInstance(global::Raylib.Float16.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Float16(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Float16.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Float16.__Internal));
            *(global::Raylib.Float16.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Float16(global::Raylib.Float16.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Float16(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Float16()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Float16.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Float16(global::Raylib.Float16 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Float16.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Float16.__Internal*) __Instance) = *((global::Raylib.Float16.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Float16 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float[] V
        {
            get
            {
                float[] __value = null;
                if (((global::Raylib.Float16.__Internal*) __Instance)->v != null)
                {
                    __value = new float[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = ((global::Raylib.Float16.__Internal*) __Instance)->v[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((global::Raylib.Float16.__Internal*)__Instance)->v[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class raymath
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Clamp@@YAMMMM@Z")]
            internal static extern float Clamp(float value, float min, float max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Lerp@@YAMMMM@Z")]
            internal static extern float Lerp(float start, float end, float amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2Zero@@YA?AUVector2@@XZ")]
            internal static extern global::Raylib.Vector2.__Internal Vector2Zero();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector2One@@YA?AUVector2@@XZ")]
            internal static extern global::Raylib.Vector2.__Internal Vector2One();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Zero@@YA?AUVector3@@XZ")]
            internal static extern void Vector3Zero(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3One@@YA?AUVector3@@XZ")]
            internal static extern void Vector3One(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3OrthoNormalize@@YAXPEAUVector3@@0@Z")]
            internal static extern void Vector3OrthoNormalize(global::System.IntPtr v1, global::System.IntPtr v2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixIdentity@@YA?AUMatrix@@XZ")]
            internal static extern void MatrixIdentity(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixTranslate@@YA?AUMatrix@@MMM@Z")]
            internal static extern void MatrixTranslate(global::System.IntPtr @return, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixRotate@@YA?AUMatrix@@UVector3@@M@Z")]
            internal static extern void MatrixRotate(global::System.IntPtr @return, global::System.IntPtr axis, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixRotateXYZ@@YA?AUMatrix@@UVector3@@@Z")]
            internal static extern void MatrixRotateXYZ(global::System.IntPtr @return, global::System.IntPtr ang);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixRotateX@@YA?AUMatrix@@M@Z")]
            internal static extern void MatrixRotateX(global::System.IntPtr @return, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixRotateY@@YA?AUMatrix@@M@Z")]
            internal static extern void MatrixRotateY(global::System.IntPtr @return, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixRotateZ@@YA?AUMatrix@@M@Z")]
            internal static extern void MatrixRotateZ(global::System.IntPtr @return, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixScale@@YA?AUMatrix@@MMM@Z")]
            internal static extern void MatrixScale(global::System.IntPtr @return, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixFrustum@@YA?AUMatrix@@NNNNNN@Z")]
            internal static extern void MatrixFrustum(global::System.IntPtr @return, double left, double right, double bottom, double top, double near, double far);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixPerspective@@YA?AUMatrix@@NNNN@Z")]
            internal static extern void MatrixPerspective(global::System.IntPtr @return, double fovy, double aspect, double near, double far);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixOrtho@@YA?AUMatrix@@NNNNNN@Z")]
            internal static extern void MatrixOrtho(global::System.IntPtr @return, double left, double right, double bottom, double top, double near, double far);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MatrixLookAt@@YA?AUMatrix@@UVector3@@00@Z")]
            internal static extern void MatrixLookAt(global::System.IntPtr @return, global::System.IntPtr eye, global::System.IntPtr target, global::System.IntPtr up);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionIdentity@@YA?AUVector4@@XZ")]
            internal static extern void QuaternionIdentity(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionLength@@YAMUVector4@@@Z")]
            internal static extern float QuaternionLength(global::System.IntPtr q);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionNormalize@@YA?AUVector4@@U1@@Z")]
            internal static extern void QuaternionNormalize(global::System.IntPtr @return, global::System.IntPtr q);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionInvert@@YA?AUVector4@@U1@@Z")]
            internal static extern void QuaternionInvert(global::System.IntPtr @return, global::System.IntPtr q);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionMultiply@@YA?AUVector4@@U1@0@Z")]
            internal static extern void QuaternionMultiply(global::System.IntPtr @return, global::System.IntPtr q1, global::System.IntPtr q2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionLerp@@YA?AUVector4@@U1@0M@Z")]
            internal static extern void QuaternionLerp(global::System.IntPtr @return, global::System.IntPtr q1, global::System.IntPtr q2, float amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionNlerp@@YA?AUVector4@@U1@0M@Z")]
            internal static extern void QuaternionNlerp(global::System.IntPtr @return, global::System.IntPtr q1, global::System.IntPtr q2, float amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionSlerp@@YA?AUVector4@@U1@0M@Z")]
            internal static extern void QuaternionSlerp(global::System.IntPtr @return, global::System.IntPtr q1, global::System.IntPtr q2, float amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionFromVector3ToVector3@@YA?AUVector4@@UVector3@@0@Z")]
            internal static extern void QuaternionFromVector3ToVector3(global::System.IntPtr @return, global::System.IntPtr from, global::System.IntPtr to);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionFromMatrix@@YA?AUVector4@@UMatrix@@@Z")]
            internal static extern void QuaternionFromMatrix(global::System.IntPtr @return, global::System.IntPtr mat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionToMatrix@@YA?AUMatrix@@UVector4@@@Z")]
            internal static extern void QuaternionToMatrix(global::System.IntPtr @return, global::System.IntPtr q);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionFromAxisAngle@@YA?AUVector4@@UVector3@@M@Z")]
            internal static extern void QuaternionFromAxisAngle(global::System.IntPtr @return, global::System.IntPtr axis, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionToAxisAngle@@YAXUVector4@@PEAUVector3@@PEAM@Z")]
            internal static extern void QuaternionToAxisAngle(global::System.IntPtr q, global::System.IntPtr outAxis, float* outAngle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionFromEuler@@YA?AUVector4@@MMM@Z")]
            internal static extern void QuaternionFromEuler(global::System.IntPtr @return, float roll, float pitch, float yaw);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionToEuler@@YA?AUVector3@@UVector4@@@Z")]
            internal static extern void QuaternionToEuler(global::System.IntPtr @return, global::System.IntPtr q);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?QuaternionTransform@@YA?AUVector4@@U1@UMatrix@@@Z")]
            internal static extern void QuaternionTransform(global::System.IntPtr @return, global::System.IntPtr q, global::System.IntPtr mat);
        }

        public static float Clamp(float value, float min, float max)
        {
            var __ret = __Internal.Clamp(value, min, max);
            return __ret;
        }

        public static float Lerp(float start, float end, float amount)
        {
            var __ret = __Internal.Lerp(start, end, amount);
            return __ret;
        }

        public static global::Raylib.Vector2 Vector2Zero()
        {
            var __ret = __Internal.Vector2Zero();
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector2 Vector2One()
        {
            var __ret = __Internal.Vector2One();
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector3 Vector3Zero()
        {
            var __ret = new global::Raylib.Vector3.__Internal();
            __Internal.Vector3Zero(new IntPtr(&__ret));
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector3 Vector3One()
        {
            var __ret = new global::Raylib.Vector3.__Internal();
            __Internal.Vector3One(new IntPtr(&__ret));
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public static void Vector3OrthoNormalize(global::Raylib.Vector3 v1, global::Raylib.Vector3 v2)
        {
            var __arg0 = ReferenceEquals(v1, null) ? global::System.IntPtr.Zero : v1.__Instance;
            var __arg1 = ReferenceEquals(v2, null) ? global::System.IntPtr.Zero : v2.__Instance;
            __Internal.Vector3OrthoNormalize(__arg0, __arg1);
        }

        public static global::Raylib.Matrix MatrixIdentity()
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixIdentity(new IntPtr(&__ret));
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixTranslate(float x, float y, float z)
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixTranslate(new IntPtr(&__ret), x, y, z);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixRotate(global::Raylib.Vector3 axis, float angle)
        {
            if (ReferenceEquals(axis, null))
                throw new global::System.ArgumentNullException("axis", "Cannot be null because it is passed by value.");
            var __arg0 = axis.__Instance;
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixRotate(new IntPtr(&__ret), __arg0, angle);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixRotateXYZ(global::Raylib.Vector3 ang)
        {
            if (ReferenceEquals(ang, null))
                throw new global::System.ArgumentNullException("ang", "Cannot be null because it is passed by value.");
            var __arg0 = ang.__Instance;
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixRotateXYZ(new IntPtr(&__ret), __arg0);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixRotateX(float angle)
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixRotateX(new IntPtr(&__ret), angle);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixRotateY(float angle)
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixRotateY(new IntPtr(&__ret), angle);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixRotateZ(float angle)
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixRotateZ(new IntPtr(&__ret), angle);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixScale(float x, float y, float z)
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixScale(new IntPtr(&__ret), x, y, z);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixFrustum(new IntPtr(&__ret), left, right, bottom, top, near, far);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixPerspective(double fovy, double aspect, double near, double far)
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixPerspective(new IntPtr(&__ret), fovy, aspect, near, far);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixOrtho(double left, double right, double bottom, double top, double near, double far)
        {
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixOrtho(new IntPtr(&__ret), left, right, bottom, top, near, far);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix MatrixLookAt(global::Raylib.Vector3 eye, global::Raylib.Vector3 target, global::Raylib.Vector3 up)
        {
            if (ReferenceEquals(eye, null))
                throw new global::System.ArgumentNullException("eye", "Cannot be null because it is passed by value.");
            var __arg0 = eye.__Instance;
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is passed by value.");
            var __arg1 = target.__Instance;
            if (ReferenceEquals(up, null))
                throw new global::System.ArgumentNullException("up", "Cannot be null because it is passed by value.");
            var __arg2 = up.__Instance;
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.MatrixLookAt(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionIdentity()
        {
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionIdentity(new IntPtr(&__ret));
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static float QuaternionLength(global::Raylib.Vector4 q)
        {
            if (ReferenceEquals(q, null))
                throw new global::System.ArgumentNullException("q", "Cannot be null because it is passed by value.");
            var __arg0 = q.__Instance;
            var __ret = __Internal.QuaternionLength(__arg0);
            return __ret;
        }

        public static global::Raylib.Vector4 QuaternionNormalize(global::Raylib.Vector4 q)
        {
            if (ReferenceEquals(q, null))
                throw new global::System.ArgumentNullException("q", "Cannot be null because it is passed by value.");
            var __arg0 = q.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionNormalize(new IntPtr(&__ret), __arg0);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionInvert(global::Raylib.Vector4 q)
        {
            if (ReferenceEquals(q, null))
                throw new global::System.ArgumentNullException("q", "Cannot be null because it is passed by value.");
            var __arg0 = q.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionInvert(new IntPtr(&__ret), __arg0);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionMultiply(global::Raylib.Vector4 q1, global::Raylib.Vector4 q2)
        {
            if (ReferenceEquals(q1, null))
                throw new global::System.ArgumentNullException("q1", "Cannot be null because it is passed by value.");
            var __arg0 = q1.__Instance;
            if (ReferenceEquals(q2, null))
                throw new global::System.ArgumentNullException("q2", "Cannot be null because it is passed by value.");
            var __arg1 = q2.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionMultiply(new IntPtr(&__ret), __arg0, __arg1);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionLerp(global::Raylib.Vector4 q1, global::Raylib.Vector4 q2, float amount)
        {
            if (ReferenceEquals(q1, null))
                throw new global::System.ArgumentNullException("q1", "Cannot be null because it is passed by value.");
            var __arg0 = q1.__Instance;
            if (ReferenceEquals(q2, null))
                throw new global::System.ArgumentNullException("q2", "Cannot be null because it is passed by value.");
            var __arg1 = q2.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionLerp(new IntPtr(&__ret), __arg0, __arg1, amount);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionNlerp(global::Raylib.Vector4 q1, global::Raylib.Vector4 q2, float amount)
        {
            if (ReferenceEquals(q1, null))
                throw new global::System.ArgumentNullException("q1", "Cannot be null because it is passed by value.");
            var __arg0 = q1.__Instance;
            if (ReferenceEquals(q2, null))
                throw new global::System.ArgumentNullException("q2", "Cannot be null because it is passed by value.");
            var __arg1 = q2.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionNlerp(new IntPtr(&__ret), __arg0, __arg1, amount);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionSlerp(global::Raylib.Vector4 q1, global::Raylib.Vector4 q2, float amount)
        {
            if (ReferenceEquals(q1, null))
                throw new global::System.ArgumentNullException("q1", "Cannot be null because it is passed by value.");
            var __arg0 = q1.__Instance;
            if (ReferenceEquals(q2, null))
                throw new global::System.ArgumentNullException("q2", "Cannot be null because it is passed by value.");
            var __arg1 = q2.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionSlerp(new IntPtr(&__ret), __arg0, __arg1, amount);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionFromVector3ToVector3(global::Raylib.Vector3 from, global::Raylib.Vector3 to)
        {
            if (ReferenceEquals(from, null))
                throw new global::System.ArgumentNullException("from", "Cannot be null because it is passed by value.");
            var __arg0 = from.__Instance;
            if (ReferenceEquals(to, null))
                throw new global::System.ArgumentNullException("to", "Cannot be null because it is passed by value.");
            var __arg1 = to.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionFromVector3ToVector3(new IntPtr(&__ret), __arg0, __arg1);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionFromMatrix(global::Raylib.Matrix mat)
        {
            if (ReferenceEquals(mat, null))
                throw new global::System.ArgumentNullException("mat", "Cannot be null because it is passed by value.");
            var __arg0 = mat.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionFromMatrix(new IntPtr(&__ret), __arg0);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static global::Raylib.Matrix QuaternionToMatrix(global::Raylib.Vector4 q)
        {
            if (ReferenceEquals(q, null))
                throw new global::System.ArgumentNullException("q", "Cannot be null because it is passed by value.");
            var __arg0 = q.__Instance;
            var __ret = new global::Raylib.Matrix.__Internal();
            __Internal.QuaternionToMatrix(new IntPtr(&__ret), __arg0);
            return global::Raylib.Matrix.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionFromAxisAngle(global::Raylib.Vector3 axis, float angle)
        {
            if (ReferenceEquals(axis, null))
                throw new global::System.ArgumentNullException("axis", "Cannot be null because it is passed by value.");
            var __arg0 = axis.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionFromAxisAngle(new IntPtr(&__ret), __arg0, angle);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static void QuaternionToAxisAngle(global::Raylib.Vector4 q, global::Raylib.Vector3 outAxis, ref float outAngle)
        {
            if (ReferenceEquals(q, null))
                throw new global::System.ArgumentNullException("q", "Cannot be null because it is passed by value.");
            var __arg0 = q.__Instance;
            var __arg1 = ReferenceEquals(outAxis, null) ? global::System.IntPtr.Zero : outAxis.__Instance;
            fixed (float* __outAngle2 = &outAngle)
            {
                var __arg2 = __outAngle2;
                __Internal.QuaternionToAxisAngle(__arg0, __arg1, __arg2);
            }
        }

        public static global::Raylib.Vector4 QuaternionFromEuler(float roll, float pitch, float yaw)
        {
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionFromEuler(new IntPtr(&__ret), roll, pitch, yaw);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector3 QuaternionToEuler(global::Raylib.Vector4 q)
        {
            if (ReferenceEquals(q, null))
                throw new global::System.ArgumentNullException("q", "Cannot be null because it is passed by value.");
            var __arg0 = q.__Instance;
            var __ret = new global::Raylib.Vector3.__Internal();
            __Internal.QuaternionToEuler(new IntPtr(&__ret), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector4 QuaternionTransform(global::Raylib.Vector4 q, global::Raylib.Matrix mat)
        {
            if (ReferenceEquals(q, null))
                throw new global::System.ArgumentNullException("q", "Cannot be null because it is passed by value.");
            var __arg0 = q.__Instance;
            if (ReferenceEquals(mat, null))
                throw new global::System.ArgumentNullException("mat", "Cannot be null because it is passed by value.");
            var __arg1 = mat.__Instance;
            var __ret = new global::Raylib.Vector4.__Internal();
            __Internal.QuaternionTransform(new IntPtr(&__ret), __arg0, __arg1);
            return global::Raylib.Vector4.__CreateInstance(__ret);
        }
    }

    public enum PhysicsShapeType
    {
        PHYSICS_CIRCLE = 0,
        PHYSICS_POLYGON = 1
    }

    public unsafe partial class Mat2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m00;

            [FieldOffset(4)]
            internal float m01;

            [FieldOffset(8)]
            internal float m10;

            [FieldOffset(12)]
            internal float m11;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mat2@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Mat2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.Mat2>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.Mat2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.Mat2(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.Mat2 __CreateInstance(global::Raylib.Mat2.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.Mat2(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.Mat2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.Mat2.__Internal));
            *(global::Raylib.Mat2.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Mat2(global::Raylib.Mat2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Mat2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Mat2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Mat2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Mat2(global::Raylib.Mat2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.Mat2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.Mat2.__Internal*) __Instance) = *((global::Raylib.Mat2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.Mat2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float M00
        {
            get
            {
                return ((global::Raylib.Mat2.__Internal*) __Instance)->m00;
            }

            set
            {
                ((global::Raylib.Mat2.__Internal*)__Instance)->m00 = value;
            }
        }

        public float M01
        {
            get
            {
                return ((global::Raylib.Mat2.__Internal*) __Instance)->m01;
            }

            set
            {
                ((global::Raylib.Mat2.__Internal*)__Instance)->m01 = value;
            }
        }

        public float M10
        {
            get
            {
                return ((global::Raylib.Mat2.__Internal*) __Instance)->m10;
            }

            set
            {
                ((global::Raylib.Mat2.__Internal*)__Instance)->m10 = value;
            }
        }

        public float M11
        {
            get
            {
                return ((global::Raylib.Mat2.__Internal*) __Instance)->m11;
            }

            set
            {
                ((global::Raylib.Mat2.__Internal*)__Instance)->m11 = value;
            }
        }
    }

    public unsafe partial class PolygonData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 388)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint vertexCount;

            [FieldOffset(4)]
            internal fixed byte positions[192];

            [FieldOffset(196)]
            internal fixed byte normals[192];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PolygonData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.PolygonData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.PolygonData>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.PolygonData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.PolygonData(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.PolygonData __CreateInstance(global::Raylib.PolygonData.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.PolygonData(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.PolygonData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.PolygonData.__Internal));
            *(global::Raylib.PolygonData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PolygonData(global::Raylib.PolygonData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PolygonData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PolygonData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.PolygonData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PolygonData(global::Raylib.PolygonData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.PolygonData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.PolygonData.__Internal*) __Instance) = *((global::Raylib.PolygonData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.PolygonData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint VertexCount
        {
            get
            {
                return ((global::Raylib.PolygonData.__Internal*) __Instance)->vertexCount;
            }

            set
            {
                ((global::Raylib.PolygonData.__Internal*)__Instance)->vertexCount = value;
            }
        }

        public global::Raylib.Vector2[] Positions
        {
            get
            {
                global::Raylib.Vector2[] __value = null;
                if (((global::Raylib.PolygonData.__Internal*) __Instance)->positions != null)
                {
                    __value = new global::Raylib.Vector2[24];
                    for (int i = 0; i < 24; i++)
                        __value[i] = global::Raylib.Vector2.__CreateInstance(*((global::Raylib.Vector2.__Internal*)&(((global::Raylib.PolygonData.__Internal*) __Instance)->positions[i * sizeof(global::Raylib.Vector2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 24)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 24; i++)
                        *(global::Raylib.Vector2.__Internal*) &((global::Raylib.PolygonData.__Internal*)__Instance)->positions[i * sizeof(global::Raylib.Vector2.__Internal)] = *(global::Raylib.Vector2.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::Raylib.Vector2[] Normals
        {
            get
            {
                global::Raylib.Vector2[] __value = null;
                if (((global::Raylib.PolygonData.__Internal*) __Instance)->normals != null)
                {
                    __value = new global::Raylib.Vector2[24];
                    for (int i = 0; i < 24; i++)
                        __value[i] = global::Raylib.Vector2.__CreateInstance(*((global::Raylib.Vector2.__Internal*)&(((global::Raylib.PolygonData.__Internal*) __Instance)->normals[i * sizeof(global::Raylib.Vector2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 24)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 24; i++)
                        *(global::Raylib.Vector2.__Internal*) &((global::Raylib.PolygonData.__Internal*)__Instance)->normals[i * sizeof(global::Raylib.Vector2.__Internal)] = *(global::Raylib.Vector2.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class PhysicsShape : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 424)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Raylib.PhysicsShapeType type;

            [FieldOffset(8)]
            internal global::System.IntPtr body;

            [FieldOffset(16)]
            internal float radius;

            [FieldOffset(20)]
            internal global::Raylib.Mat2.__Internal transform;

            [FieldOffset(36)]
            internal global::Raylib.PolygonData.__Internal vertexData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PhysicsShape@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.PhysicsShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.PhysicsShape>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.PhysicsShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.PhysicsShape(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.PhysicsShape __CreateInstance(global::Raylib.PhysicsShape.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.PhysicsShape(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.PhysicsShape.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.PhysicsShape.__Internal));
            *(global::Raylib.PhysicsShape.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PhysicsShape(global::Raylib.PhysicsShape.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PhysicsShape(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PhysicsShape()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.PhysicsShape.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PhysicsShape(global::Raylib.PhysicsShape _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.PhysicsShape.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.PhysicsShape.__Internal*) __Instance) = *((global::Raylib.PhysicsShape.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.PhysicsShape __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Raylib.PhysicsShapeType Type
        {
            get
            {
                return ((global::Raylib.PhysicsShape.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::Raylib.PhysicsShape.__Internal*)__Instance)->type = value;
            }
        }

        public global::Raylib.PhysicsBodyData Body
        {
            get
            {
                global::Raylib.PhysicsBodyData __result0;
                if (((global::Raylib.PhysicsShape.__Internal*) __Instance)->body == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.PhysicsBodyData.NativeToManagedMap.ContainsKey(((global::Raylib.PhysicsShape.__Internal*) __Instance)->body))
                    __result0 = (global::Raylib.PhysicsBodyData) global::Raylib.PhysicsBodyData.NativeToManagedMap[((global::Raylib.PhysicsShape.__Internal*) __Instance)->body];
                else __result0 = global::Raylib.PhysicsBodyData.__CreateInstance(((global::Raylib.PhysicsShape.__Internal*) __Instance)->body);
                return __result0;
            }

            set
            {
                ((global::Raylib.PhysicsShape.__Internal*)__Instance)->body = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public float Radius
        {
            get
            {
                return ((global::Raylib.PhysicsShape.__Internal*) __Instance)->radius;
            }

            set
            {
                ((global::Raylib.PhysicsShape.__Internal*)__Instance)->radius = value;
            }
        }

        public global::Raylib.Mat2 Transform
        {
            get
            {
                return global::Raylib.Mat2.__CreateInstance(new global::System.IntPtr(&((global::Raylib.PhysicsShape.__Internal*) __Instance)->transform));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.PhysicsShape.__Internal*)__Instance)->transform = *(global::Raylib.Mat2.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.PolygonData VertexData
        {
            get
            {
                return global::Raylib.PolygonData.__CreateInstance(new global::System.IntPtr(&((global::Raylib.PhysicsShape.__Internal*) __Instance)->vertexData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.PhysicsShape.__Internal*)__Instance)->vertexData = *(global::Raylib.PolygonData.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class PhysicsBodyData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 504)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint id;

            [FieldOffset(4)]
            internal byte enabled;

            [FieldOffset(8)]
            internal global::Raylib.Vector2.__Internal position;

            [FieldOffset(16)]
            internal global::Raylib.Vector2.__Internal velocity;

            [FieldOffset(24)]
            internal global::Raylib.Vector2.__Internal force;

            [FieldOffset(32)]
            internal float angularVelocity;

            [FieldOffset(36)]
            internal float torque;

            [FieldOffset(40)]
            internal float orient;

            [FieldOffset(44)]
            internal float inertia;

            [FieldOffset(48)]
            internal float inverseInertia;

            [FieldOffset(52)]
            internal float mass;

            [FieldOffset(56)]
            internal float inverseMass;

            [FieldOffset(60)]
            internal float staticFriction;

            [FieldOffset(64)]
            internal float dynamicFriction;

            [FieldOffset(68)]
            internal float restitution;

            [FieldOffset(72)]
            internal byte useGravity;

            [FieldOffset(73)]
            internal byte isGrounded;

            [FieldOffset(74)]
            internal byte freezeOrient;

            [FieldOffset(80)]
            internal global::Raylib.PhysicsShape.__Internal shape;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PhysicsBodyData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.PhysicsBodyData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.PhysicsBodyData>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.PhysicsBodyData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.PhysicsBodyData(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.PhysicsBodyData __CreateInstance(global::Raylib.PhysicsBodyData.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.PhysicsBodyData(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.PhysicsBodyData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.PhysicsBodyData.__Internal));
            *(global::Raylib.PhysicsBodyData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PhysicsBodyData(global::Raylib.PhysicsBodyData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PhysicsBodyData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PhysicsBodyData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.PhysicsBodyData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PhysicsBodyData(global::Raylib.PhysicsBodyData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.PhysicsBodyData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.PhysicsBodyData.__Internal*) __Instance) = *((global::Raylib.PhysicsBodyData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.PhysicsBodyData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->id;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->id = value;
            }
        }

        public bool Enabled
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->enabled != 0;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->enabled = (byte) (value ? 1 : 0);
            }
        }

        public global::Raylib.Vector2 Position
        {
            get
            {
                return global::Raylib.Vector2.__CreateInstance(new global::System.IntPtr(&((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->position));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->position = *(global::Raylib.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector2 Velocity
        {
            get
            {
                return global::Raylib.Vector2.__CreateInstance(new global::System.IntPtr(&((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->velocity));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->velocity = *(global::Raylib.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector2 Force
        {
            get
            {
                return global::Raylib.Vector2.__CreateInstance(new global::System.IntPtr(&((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->force));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->force = *(global::Raylib.Vector2.__Internal*) value.__Instance;
            }
        }

        public float AngularVelocity
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->angularVelocity;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->angularVelocity = value;
            }
        }

        public float Torque
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->torque;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->torque = value;
            }
        }

        public float Orient
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->orient;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->orient = value;
            }
        }

        public float Inertia
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->inertia;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->inertia = value;
            }
        }

        public float InverseInertia
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->inverseInertia;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->inverseInertia = value;
            }
        }

        public float Mass
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->mass;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->mass = value;
            }
        }

        public float InverseMass
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->inverseMass;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->inverseMass = value;
            }
        }

        public float StaticFriction
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->staticFriction;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->staticFriction = value;
            }
        }

        public float DynamicFriction
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->dynamicFriction;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->dynamicFriction = value;
            }
        }

        public float Restitution
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->restitution;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->restitution = value;
            }
        }

        public bool UseGravity
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->useGravity != 0;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->useGravity = (byte) (value ? 1 : 0);
            }
        }

        public bool IsGrounded
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->isGrounded != 0;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->isGrounded = (byte) (value ? 1 : 0);
            }
        }

        public bool FreezeOrient
        {
            get
            {
                return ((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->freezeOrient != 0;
            }

            set
            {
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->freezeOrient = (byte) (value ? 1 : 0);
            }
        }

        public global::Raylib.PhysicsShape Shape
        {
            get
            {
                return global::Raylib.PhysicsShape.__CreateInstance(new global::System.IntPtr(&((global::Raylib.PhysicsBodyData.__Internal*) __Instance)->shape));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.PhysicsBodyData.__Internal*)__Instance)->shape = *(global::Raylib.PhysicsShape.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class PhysicsManifoldData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint id;

            [FieldOffset(8)]
            internal global::System.IntPtr bodyA;

            [FieldOffset(16)]
            internal global::System.IntPtr bodyB;

            [FieldOffset(24)]
            internal float penetration;

            [FieldOffset(28)]
            internal global::Raylib.Vector2.__Internal normal;

            [FieldOffset(36)]
            internal fixed byte contacts[16];

            [FieldOffset(52)]
            internal uint contactsCount;

            [FieldOffset(56)]
            internal float restitution;

            [FieldOffset(60)]
            internal float dynamicFriction;

            [FieldOffset(64)]
            internal float staticFriction;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PhysicsManifoldData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.PhysicsManifoldData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.PhysicsManifoldData>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.PhysicsManifoldData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.PhysicsManifoldData(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.PhysicsManifoldData __CreateInstance(global::Raylib.PhysicsManifoldData.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.PhysicsManifoldData(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.PhysicsManifoldData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.PhysicsManifoldData.__Internal));
            *(global::Raylib.PhysicsManifoldData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PhysicsManifoldData(global::Raylib.PhysicsManifoldData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PhysicsManifoldData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PhysicsManifoldData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.PhysicsManifoldData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PhysicsManifoldData(global::Raylib.PhysicsManifoldData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.PhysicsManifoldData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.PhysicsManifoldData.__Internal*) __Instance) = *((global::Raylib.PhysicsManifoldData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.PhysicsManifoldData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->id;
            }

            set
            {
                ((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->id = value;
            }
        }

        public global::Raylib.PhysicsBodyData BodyA
        {
            get
            {
                global::Raylib.PhysicsBodyData __result0;
                if (((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->bodyA == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.PhysicsBodyData.NativeToManagedMap.ContainsKey(((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->bodyA))
                    __result0 = (global::Raylib.PhysicsBodyData) global::Raylib.PhysicsBodyData.NativeToManagedMap[((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->bodyA];
                else __result0 = global::Raylib.PhysicsBodyData.__CreateInstance(((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->bodyA);
                return __result0;
            }

            set
            {
                ((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->bodyA = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::Raylib.PhysicsBodyData BodyB
        {
            get
            {
                global::Raylib.PhysicsBodyData __result0;
                if (((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->bodyB == IntPtr.Zero) __result0 = null;
                else if (global::Raylib.PhysicsBodyData.NativeToManagedMap.ContainsKey(((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->bodyB))
                    __result0 = (global::Raylib.PhysicsBodyData) global::Raylib.PhysicsBodyData.NativeToManagedMap[((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->bodyB];
                else __result0 = global::Raylib.PhysicsBodyData.__CreateInstance(((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->bodyB);
                return __result0;
            }

            set
            {
                ((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->bodyB = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public float Penetration
        {
            get
            {
                return ((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->penetration;
            }

            set
            {
                ((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->penetration = value;
            }
        }

        public global::Raylib.Vector2 Normal
        {
            get
            {
                return global::Raylib.Vector2.__CreateInstance(new global::System.IntPtr(&((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->normal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->normal = *(global::Raylib.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::Raylib.Vector2[] Contacts
        {
            get
            {
                global::Raylib.Vector2[] __value = null;
                if (((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->contacts != null)
                {
                    __value = new global::Raylib.Vector2[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::Raylib.Vector2.__CreateInstance(*((global::Raylib.Vector2.__Internal*)&(((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->contacts[i * sizeof(global::Raylib.Vector2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::Raylib.Vector2.__Internal*) &((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->contacts[i * sizeof(global::Raylib.Vector2.__Internal)] = *(global::Raylib.Vector2.__Internal*)value[i].__Instance;
                }
            }
        }

        public uint ContactsCount
        {
            get
            {
                return ((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->contactsCount;
            }

            set
            {
                ((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->contactsCount = value;
            }
        }

        public float Restitution
        {
            get
            {
                return ((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->restitution;
            }

            set
            {
                ((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->restitution = value;
            }
        }

        public float DynamicFriction
        {
            get
            {
                return ((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->dynamicFriction;
            }

            set
            {
                ((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->dynamicFriction = value;
            }
        }

        public float StaticFriction
        {
            get
            {
                return ((global::Raylib.PhysicsManifoldData.__Internal*) __Instance)->staticFriction;
            }

            set
            {
                ((global::Raylib.PhysicsManifoldData.__Internal*)__Instance)->staticFriction = value;
            }
        }
    }

    public unsafe partial class physac
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="InitPhysics")]
            internal static extern void InitPhysics();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="RunPhysicsStep")]
            internal static extern void RunPhysicsStep();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetPhysicsTimeStep")]
            internal static extern void SetPhysicsTimeStep(double delta);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="IsPhysicsEnabled")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPhysicsEnabled();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetPhysicsGravity")]
            internal static extern void SetPhysicsGravity(float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CreatePhysicsBodyCircle")]
            internal static extern global::System.IntPtr CreatePhysicsBodyCircle(global::Raylib.Vector2.__Internal pos, float radius, float density);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CreatePhysicsBodyRectangle")]
            internal static extern global::System.IntPtr CreatePhysicsBodyRectangle(global::Raylib.Vector2.__Internal pos, float width, float height, float density);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="CreatePhysicsBodyPolygon")]
            internal static extern global::System.IntPtr CreatePhysicsBodyPolygon(global::Raylib.Vector2.__Internal pos, float radius, int sides, float density);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PhysicsAddForce")]
            internal static extern void PhysicsAddForce(global::System.IntPtr body, global::Raylib.Vector2.__Internal force);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PhysicsAddTorque")]
            internal static extern void PhysicsAddTorque(global::System.IntPtr body, float amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="PhysicsShatter")]
            internal static extern void PhysicsShatter(global::System.IntPtr body, global::Raylib.Vector2.__Internal position, float force);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetPhysicsBodiesCount")]
            internal static extern int GetPhysicsBodiesCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetPhysicsBody")]
            internal static extern global::System.IntPtr GetPhysicsBody(int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetPhysicsShapeType")]
            internal static extern int GetPhysicsShapeType(int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetPhysicsShapeVerticesCount")]
            internal static extern int GetPhysicsShapeVerticesCount(int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GetPhysicsShapeVertex")]
            internal static extern global::Raylib.Vector2.__Internal GetPhysicsShapeVertex(global::System.IntPtr body, int vertex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="SetPhysicsBodyRotation")]
            internal static extern void SetPhysicsBodyRotation(global::System.IntPtr body, float radians);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="DestroyPhysicsBody")]
            internal static extern void DestroyPhysicsBody(global::System.IntPtr body);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ResetPhysics")]
            internal static extern void ResetPhysics();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ClosePhysics")]
            internal static extern void ClosePhysics();
        }

        public static void InitPhysics()
        {
            __Internal.InitPhysics();
        }

        public static void RunPhysicsStep()
        {
            __Internal.RunPhysicsStep();
        }

        public static void SetPhysicsTimeStep(double delta)
        {
            __Internal.SetPhysicsTimeStep(delta);
        }

        public static bool IsPhysicsEnabled()
        {
            var __ret = __Internal.IsPhysicsEnabled();
            return __ret;
        }

        public static void SetPhysicsGravity(float x, float y)
        {
            __Internal.SetPhysicsGravity(x, y);
        }

        public static global::Raylib.PhysicsBodyData CreatePhysicsBodyCircle(global::Raylib.Vector2 pos, float radius, float density)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            var __ret = __Internal.CreatePhysicsBodyCircle(*(global::Raylib.Vector2.__Internal*) __arg0, radius, density);
            global::Raylib.PhysicsBodyData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Raylib.PhysicsBodyData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Raylib.PhysicsBodyData) global::Raylib.PhysicsBodyData.NativeToManagedMap[__ret];
            else __result0 = global::Raylib.PhysicsBodyData.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Raylib.PhysicsBodyData CreatePhysicsBodyRectangle(global::Raylib.Vector2 pos, float width, float height, float density)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            var __ret = __Internal.CreatePhysicsBodyRectangle(*(global::Raylib.Vector2.__Internal*) __arg0, width, height, density);
            global::Raylib.PhysicsBodyData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Raylib.PhysicsBodyData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Raylib.PhysicsBodyData) global::Raylib.PhysicsBodyData.NativeToManagedMap[__ret];
            else __result0 = global::Raylib.PhysicsBodyData.__CreateInstance(__ret);
            return __result0;
        }

        public static global::Raylib.PhysicsBodyData CreatePhysicsBodyPolygon(global::Raylib.Vector2 pos, float radius, int sides, float density)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            var __ret = __Internal.CreatePhysicsBodyPolygon(*(global::Raylib.Vector2.__Internal*) __arg0, radius, sides, density);
            global::Raylib.PhysicsBodyData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Raylib.PhysicsBodyData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Raylib.PhysicsBodyData) global::Raylib.PhysicsBodyData.NativeToManagedMap[__ret];
            else __result0 = global::Raylib.PhysicsBodyData.__CreateInstance(__ret);
            return __result0;
        }

        public static void PhysicsAddForce(global::Raylib.PhysicsBodyData body, global::Raylib.Vector2 force)
        {
            var __arg0 = ReferenceEquals(body, null) ? global::System.IntPtr.Zero : body.__Instance;
            if (ReferenceEquals(force, null))
                throw new global::System.ArgumentNullException("force", "Cannot be null because it is passed by value.");
            var __arg1 = force.__Instance;
            __Internal.PhysicsAddForce(__arg0, *(global::Raylib.Vector2.__Internal*) __arg1);
        }

        public static void PhysicsAddTorque(global::Raylib.PhysicsBodyData body, float amount)
        {
            var __arg0 = ReferenceEquals(body, null) ? global::System.IntPtr.Zero : body.__Instance;
            __Internal.PhysicsAddTorque(__arg0, amount);
        }

        public static void PhysicsShatter(global::Raylib.PhysicsBodyData body, global::Raylib.Vector2 position, float force)
        {
            var __arg0 = ReferenceEquals(body, null) ? global::System.IntPtr.Zero : body.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            __Internal.PhysicsShatter(__arg0, *(global::Raylib.Vector2.__Internal*) __arg1, force);
        }

        public static int GetPhysicsBodiesCount()
        {
            var __ret = __Internal.GetPhysicsBodiesCount();
            return __ret;
        }

        public static global::Raylib.PhysicsBodyData GetPhysicsBody(int index)
        {
            var __ret = __Internal.GetPhysicsBody(index);
            global::Raylib.PhysicsBodyData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Raylib.PhysicsBodyData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Raylib.PhysicsBodyData) global::Raylib.PhysicsBodyData.NativeToManagedMap[__ret];
            else __result0 = global::Raylib.PhysicsBodyData.__CreateInstance(__ret);
            return __result0;
        }

        public static int GetPhysicsShapeType(int index)
        {
            var __ret = __Internal.GetPhysicsShapeType(index);
            return __ret;
        }

        public static int GetPhysicsShapeVerticesCount(int index)
        {
            var __ret = __Internal.GetPhysicsShapeVerticesCount(index);
            return __ret;
        }

        public static global::Raylib.Vector2 GetPhysicsShapeVertex(global::Raylib.PhysicsBodyData body, int vertex)
        {
            var __arg0 = ReferenceEquals(body, null) ? global::System.IntPtr.Zero : body.__Instance;
            var __ret = __Internal.GetPhysicsShapeVertex(__arg0, vertex);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static void SetPhysicsBodyRotation(global::Raylib.PhysicsBodyData body, float radians)
        {
            var __arg0 = ReferenceEquals(body, null) ? global::System.IntPtr.Zero : body.__Instance;
            __Internal.SetPhysicsBodyRotation(__arg0, radians);
        }

        public static void DestroyPhysicsBody(global::Raylib.PhysicsBodyData body)
        {
            var __arg0 = ReferenceEquals(body, null) ? global::System.IntPtr.Zero : body.__Instance;
            __Internal.DestroyPhysicsBody(__arg0);
        }

        public static void ResetPhysics()
        {
            __Internal.ResetPhysics();
        }

        public static void ClosePhysics()
        {
            __Internal.ClosePhysics();
        }
    }

    public unsafe partial class easings
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseLinearNone@@YAMMMMM@Z")]
            internal static extern float EaseLinearNone(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseLinearIn@@YAMMMMM@Z")]
            internal static extern float EaseLinearIn(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseLinearOut@@YAMMMMM@Z")]
            internal static extern float EaseLinearOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseLinearInOut@@YAMMMMM@Z")]
            internal static extern float EaseLinearInOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseSineIn@@YAMMMMM@Z")]
            internal static extern float EaseSineIn(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseSineOut@@YAMMMMM@Z")]
            internal static extern float EaseSineOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseSineInOut@@YAMMMMM@Z")]
            internal static extern float EaseSineInOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseCircIn@@YAMMMMM@Z")]
            internal static extern float EaseCircIn(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseCircOut@@YAMMMMM@Z")]
            internal static extern float EaseCircOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseCircInOut@@YAMMMMM@Z")]
            internal static extern float EaseCircInOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseCubicIn@@YAMMMMM@Z")]
            internal static extern float EaseCubicIn(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseCubicOut@@YAMMMMM@Z")]
            internal static extern float EaseCubicOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseCubicInOut@@YAMMMMM@Z")]
            internal static extern float EaseCubicInOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseQuadIn@@YAMMMMM@Z")]
            internal static extern float EaseQuadIn(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseQuadOut@@YAMMMMM@Z")]
            internal static extern float EaseQuadOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseQuadInOut@@YAMMMMM@Z")]
            internal static extern float EaseQuadInOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseExpoIn@@YAMMMMM@Z")]
            internal static extern float EaseExpoIn(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseExpoOut@@YAMMMMM@Z")]
            internal static extern float EaseExpoOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseExpoInOut@@YAMMMMM@Z")]
            internal static extern float EaseExpoInOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseBackIn@@YAMMMMM@Z")]
            internal static extern float EaseBackIn(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseBackOut@@YAMMMMM@Z")]
            internal static extern float EaseBackOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseBackInOut@@YAMMMMM@Z")]
            internal static extern float EaseBackInOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseBounceOut@@YAMMMMM@Z")]
            internal static extern float EaseBounceOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseBounceIn@@YAMMMMM@Z")]
            internal static extern float EaseBounceIn(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseBounceInOut@@YAMMMMM@Z")]
            internal static extern float EaseBounceInOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseElasticIn@@YAMMMMM@Z")]
            internal static extern float EaseElasticIn(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseElasticOut@@YAMMMMM@Z")]
            internal static extern float EaseElasticOut(float t, float b, float c, float d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EaseElasticInOut@@YAMMMMM@Z")]
            internal static extern float EaseElasticInOut(float t, float b, float c, float d);
        }

        public static float EaseLinearNone(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseLinearNone(t, b, c, d);
            return __ret;
        }

        public static float EaseLinearIn(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseLinearIn(t, b, c, d);
            return __ret;
        }

        public static float EaseLinearOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseLinearOut(t, b, c, d);
            return __ret;
        }

        public static float EaseLinearInOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseLinearInOut(t, b, c, d);
            return __ret;
        }

        public static float EaseSineIn(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseSineIn(t, b, c, d);
            return __ret;
        }

        public static float EaseSineOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseSineOut(t, b, c, d);
            return __ret;
        }

        public static float EaseSineInOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseSineInOut(t, b, c, d);
            return __ret;
        }

        public static float EaseCircIn(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseCircIn(t, b, c, d);
            return __ret;
        }

        public static float EaseCircOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseCircOut(t, b, c, d);
            return __ret;
        }

        public static float EaseCircInOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseCircInOut(t, b, c, d);
            return __ret;
        }

        public static float EaseCubicIn(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseCubicIn(t, b, c, d);
            return __ret;
        }

        public static float EaseCubicOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseCubicOut(t, b, c, d);
            return __ret;
        }

        public static float EaseCubicInOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseCubicInOut(t, b, c, d);
            return __ret;
        }

        public static float EaseQuadIn(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseQuadIn(t, b, c, d);
            return __ret;
        }

        public static float EaseQuadOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseQuadOut(t, b, c, d);
            return __ret;
        }

        public static float EaseQuadInOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseQuadInOut(t, b, c, d);
            return __ret;
        }

        public static float EaseExpoIn(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseExpoIn(t, b, c, d);
            return __ret;
        }

        public static float EaseExpoOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseExpoOut(t, b, c, d);
            return __ret;
        }

        public static float EaseExpoInOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseExpoInOut(t, b, c, d);
            return __ret;
        }

        public static float EaseBackIn(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseBackIn(t, b, c, d);
            return __ret;
        }

        public static float EaseBackOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseBackOut(t, b, c, d);
            return __ret;
        }

        public static float EaseBackInOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseBackInOut(t, b, c, d);
            return __ret;
        }

        public static float EaseBounceOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseBounceOut(t, b, c, d);
            return __ret;
        }

        public static float EaseBounceIn(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseBounceIn(t, b, c, d);
            return __ret;
        }

        public static float EaseBounceInOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseBounceInOut(t, b, c, d);
            return __ret;
        }

        public static float EaseElasticIn(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseElasticIn(t, b, c, d);
            return __ret;
        }

        public static float EaseElasticOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseElasticOut(t, b, c, d);
            return __ret;
        }

        public static float EaseElasticInOut(float t, float b, float c, float d)
        {
            var __ret = __Internal.EaseElasticInOut(t, b, c, d);
            return __ret;
        }
    }

    public enum GuiControlState
    {
        GUI_STATE_NORMAL = 0,
        GUI_STATE_FOCUSED = 1,
        GUI_STATE_PRESSED = 2,
        GUI_STATE_DISABLED = 3
    }

    public enum GuiTextAlignment
    {
        GUI_TEXT_ALIGN_LEFT = 0,
        GUI_TEXT_ALIGN_CENTER = 1,
        GUI_TEXT_ALIGN_RIGHT = 2
    }

    public enum GuiControl
    {
        DEFAULT = 0,
        LABEL = 1,
        BUTTON = 2,
        TOGGLE = 3,
        SLIDER = 4,
        PROGRESSBAR = 5,
        CHECKBOX = 6,
        COMBOBOX = 7,
        DROPDOWNBOX = 8,
        TEXTBOX = 9,
        VALUEBOX = 10,
        SPINNER = 11,
        LISTVIEW = 12,
        COLORPICKER = 13,
        SCROLLBAR = 14,
        STATUSBAR = 15
    }

    public enum GuiControlProperty
    {
        BORDER_COLOR_NORMAL = 0,
        BASE_COLOR_NORMAL = 1,
        TEXT_COLOR_NORMAL = 2,
        BORDER_COLOR_FOCUSED = 3,
        BASE_COLOR_FOCUSED = 4,
        TEXT_COLOR_FOCUSED = 5,
        BORDER_COLOR_PRESSED = 6,
        BASE_COLOR_PRESSED = 7,
        TEXT_COLOR_PRESSED = 8,
        BORDER_COLOR_DISABLED = 9,
        BASE_COLOR_DISABLED = 10,
        TEXT_COLOR_DISABLED = 11,
        BORDER_WIDTH = 12,
        TEXT_PADDING = 13,
        TEXT_ALIGNMENT = 14,
        RESERVED = 15
    }

    public enum GuiDefaultProperty
    {
        TEXT_SIZE = 16,
        TEXT_SPACING = 17,
        LINE_COLOR = 18,
        BACKGROUND_COLOR = 19
    }

    [Flags]
    public enum GuiToggleProperty
    {
        GROUP_PADDING = 16
    }

    public enum GuiSliderProperty
    {
        SLIDER_WIDTH = 16,
        SLIDER_PADDING = 17
    }

    [Flags]
    public enum GuiProgressBarProperty
    {
        PROGRESS_PADDING = 16
    }

    [Flags]
    public enum GuiCheckBoxProperty
    {
        CHECK_PADDING = 16
    }

    public enum GuiComboBoxProperty
    {
        COMBO_BUTTON_WIDTH = 16,
        COMBO_BUTTON_PADDING = 17
    }

    public enum GuiDropdownBoxProperty
    {
        ARROW_PADDING = 16,
        DROPDOWN_ITEMS_PADDING = 17
    }

    public enum GuiTextBoxProperty
    {
        TEXT_INNER_PADDING = 16,
        TEXT_LINES_PADDING = 17,
        COLOR_SELECTED_FG = 18,
        COLOR_SELECTED_BG = 19
    }

    public enum GuiSpinnerProperty
    {
        SPIN_BUTTON_WIDTH = 16,
        SPIN_BUTTON_PADDING = 17
    }

    public enum GuiScrollBarProperty
    {
        ARROWS_SIZE = 16,
        ARROWS_VISIBLE = 17,
        SCROLL_SLIDER_PADDING = 18,
        SCROLL_SLIDER_SIZE = 19,
        SCROLL_PADDING = 20,
        SCROLL_SPEED = 21
    }

    public enum GuiScrollBarSide
    {
        SCROLLBAR_LEFT_SIDE = 0,
        SCROLLBAR_RIGHT_SIDE = 1
    }

    public enum GuiListViewProperty
    {
        LIST_ITEMS_HEIGHT = 16,
        LIST_ITEMS_PADDING = 17,
        SCROLLBAR_WIDTH = 18,
        SCROLLBAR_SIDE = 19
    }

    public enum GuiColorPickerProperty
    {
        COLOR_SELECTOR_SIZE = 16,
        HUEBAR_WIDTH = 17,
        HUEBAR_PADDING = 18,
        HUEBAR_SELECTOR_HEIGHT = 19,
        HUEBAR_SELECTOR_OVERFLOW = 20
    }

    public enum GuiPropertyElement
    {
        BORDER = 0,
        BASE = 1,
        TEXT = 2,
        OTHER = 3
    }

    public unsafe partial class GuiStyleProp : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort controlId;

            [FieldOffset(2)]
            internal ushort propertyId;

            [FieldOffset(4)]
            internal int propertyValue;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GuiStyleProp@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.GuiStyleProp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Raylib.GuiStyleProp>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Raylib.GuiStyleProp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Raylib.GuiStyleProp(native.ToPointer(), skipVTables);
        }

        internal static global::Raylib.GuiStyleProp __CreateInstance(global::Raylib.GuiStyleProp.__Internal native, bool skipVTables = false)
        {
            return new global::Raylib.GuiStyleProp(native, skipVTables);
        }

        private static void* __CopyValue(global::Raylib.GuiStyleProp.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Raylib.GuiStyleProp.__Internal));
            *(global::Raylib.GuiStyleProp.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GuiStyleProp(global::Raylib.GuiStyleProp.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GuiStyleProp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GuiStyleProp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.GuiStyleProp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GuiStyleProp(global::Raylib.GuiStyleProp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Raylib.GuiStyleProp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Raylib.GuiStyleProp.__Internal*) __Instance) = *((global::Raylib.GuiStyleProp.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Raylib.GuiStyleProp __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort ControlId
        {
            get
            {
                return ((global::Raylib.GuiStyleProp.__Internal*) __Instance)->controlId;
            }

            set
            {
                ((global::Raylib.GuiStyleProp.__Internal*)__Instance)->controlId = value;
            }
        }

        public ushort PropertyId
        {
            get
            {
                return ((global::Raylib.GuiStyleProp.__Internal*) __Instance)->propertyId;
            }

            set
            {
                ((global::Raylib.GuiStyleProp.__Internal*)__Instance)->propertyId = value;
            }
        }

        public int PropertyValue
        {
            get
            {
                return ((global::Raylib.GuiStyleProp.__Internal*) __Instance)->propertyValue;
            }

            set
            {
                ((global::Raylib.GuiStyleProp.__Internal*)__Instance)->propertyValue = value;
            }
        }
    }

    public unsafe partial class raygui
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiEnable")]
            internal static extern void GuiEnable();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiDisable")]
            internal static extern void GuiDisable();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiLock")]
            internal static extern void GuiLock();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiUnlock")]
            internal static extern void GuiUnlock();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiFade")]
            internal static extern void GuiFade(float alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiSetState")]
            internal static extern void GuiSetState(int state);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiGetState")]
            internal static extern int GuiGetState();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiSetFont")]
            internal static extern void GuiSetFont(global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiGetFont")]
            internal static extern void GuiGetFont(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiSetStyle")]
            internal static extern void GuiSetStyle(int control, int property, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiGetStyle")]
            internal static extern int GuiGetStyle(int control, int property);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiWindowBox")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiWindowBox(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiGroupBox")]
            internal static extern void GuiGroupBox(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiLine")]
            internal static extern void GuiLine(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiPanel")]
            internal static extern void GuiPanel(global::System.IntPtr bounds);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiScrollPanel")]
            internal static extern void GuiScrollPanel(global::System.IntPtr @return, global::System.IntPtr bounds, global::System.IntPtr content, global::System.IntPtr scroll);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiLabel")]
            internal static extern void GuiLabel(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiButton(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiLabelButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiLabelButton(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiImageButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiImageButton(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiImageButtonEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiImageButtonEx(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, global::System.IntPtr texture, global::System.IntPtr texSource);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiToggle")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiToggle(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, bool active);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiToggleGroup")]
            internal static extern int GuiToggleGroup(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, int active);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiCheckBox")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiCheckBox(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, bool @checked);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiComboBox")]
            internal static extern int GuiComboBox(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, int active);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiDropdownBox")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiDropdownBox(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, int* active, bool editMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiSpinner")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiSpinner(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, int* value, int minValue, int maxValue, bool editMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiValueBox")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiValueBox(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, int* value, int minValue, int maxValue, bool editMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiTextBox")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiTextBox(global::System.IntPtr bounds, sbyte* text, int textSize, bool editMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiTextBoxMulti")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiTextBoxMulti(global::System.IntPtr bounds, sbyte* text, int textSize, bool editMode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiSlider")]
            internal static extern float GuiSlider(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string textLeft, [MarshalAs(UnmanagedType.LPStr)] string textRight, float value, float minValue, float maxValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiSliderBar")]
            internal static extern float GuiSliderBar(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string textLeft, [MarshalAs(UnmanagedType.LPStr)] string textRight, float value, float minValue, float maxValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiProgressBar")]
            internal static extern float GuiProgressBar(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string textLeft, [MarshalAs(UnmanagedType.LPStr)] string textRight, float value, float minValue, float maxValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiStatusBar")]
            internal static extern void GuiStatusBar(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiDummyRec")]
            internal static extern void GuiDummyRec(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiScrollBar")]
            internal static extern int GuiScrollBar(global::System.IntPtr bounds, int value, int minValue, int maxValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiGrid")]
            internal static extern global::Raylib.Vector2.__Internal GuiGrid(global::System.IntPtr bounds, float spacing, int subdivs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiListView")]
            internal static extern int GuiListView(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string text, int* scrollIndex, int active);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiListViewEx")]
            internal static extern int GuiListViewEx(global::System.IntPtr bounds, sbyte** text, int count, int* focus, int* scrollIndex, int active);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiMessageBox")]
            internal static extern int GuiMessageBox(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string title, [MarshalAs(UnmanagedType.LPStr)] string message, [MarshalAs(UnmanagedType.LPStr)] string buttons);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiTextInputBox")]
            internal static extern int GuiTextInputBox(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string title, [MarshalAs(UnmanagedType.LPStr)] string message, [MarshalAs(UnmanagedType.LPStr)] string buttons, sbyte* text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiColorPicker")]
            internal static extern global::Raylib.Color.__Internal GuiColorPicker(global::System.IntPtr bounds, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiLoadStyle")]
            internal static extern void GuiLoadStyle([MarshalAs(UnmanagedType.LPStr)] string fileName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiLoadStyleDefault")]
            internal static extern void GuiLoadStyleDefault();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiIconText")]
            internal static extern global::System.IntPtr GuiIconText(int iconId, [MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ConvertHSVtoRGB@@YA?AUVector3@@U1@@Z")]
            internal static extern void ConvertHSVtoRGB(global::System.IntPtr @return, global::System.IntPtr hsv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ConvertRGBtoHSV@@YA?AUVector3@@U1@@Z")]
            internal static extern void ConvertRGBtoHSV(global::System.IntPtr @return, global::System.IntPtr rgb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextWidth@@YAHPEBD@Z")]
            internal static extern int GetTextWidth([MarshalAs(UnmanagedType.LPStr)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextBounds@@YA?AURectangle@@HU1@@Z")]
            internal static extern void GetTextBounds(global::System.IntPtr @return, int control, global::System.IntPtr bounds);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextIcon@@YAPEBDPEBDPEAH@Z")]
            internal static extern global::System.IntPtr GetTextIcon([MarshalAs(UnmanagedType.LPStr)] string text, int* iconId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiDrawText@@YAXPEBDURectangle@@HUColor@@@Z")]
            internal static extern void GuiDrawText([MarshalAs(UnmanagedType.LPStr)] string text, global::System.IntPtr bounds, int alignment, global::Raylib.Color.__Internal tint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiTextSplit@@YAPEAPEBDPEBDPEAH1@Z")]
            internal static extern sbyte** GuiTextSplit([MarshalAs(UnmanagedType.LPStr)] string text, int* count, int* textRow);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiSliderPro")]
            internal static extern float GuiSliderPro(global::System.IntPtr bounds, [MarshalAs(UnmanagedType.LPStr)] string textLeft, [MarshalAs(UnmanagedType.LPStr)] string textRight, float value, float minValue, float maxValue, int sliderWidth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiColorPanelEx")]
            internal static extern global::Raylib.Color.__Internal GuiColorPanelEx(global::System.IntPtr bounds, global::Raylib.Color.__Internal color, float hue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiColorPanel")]
            internal static extern global::Raylib.Color.__Internal GuiColorPanel(global::System.IntPtr bounds, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiColorBarAlpha")]
            internal static extern float GuiColorBarAlpha(global::System.IntPtr bounds, float alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="GuiColorBarHue")]
            internal static extern float GuiColorBarHue(global::System.IntPtr bounds, float hue);
        }

        public static void GuiEnable()
        {
            __Internal.GuiEnable();
        }

        public static void GuiDisable()
        {
            __Internal.GuiDisable();
        }

        public static void GuiLock()
        {
            __Internal.GuiLock();
        }

        public static void GuiUnlock()
        {
            __Internal.GuiUnlock();
        }

        public static void GuiFade(float alpha)
        {
            __Internal.GuiFade(alpha);
        }

        public static void GuiSetState(int state)
        {
            __Internal.GuiSetState(state);
        }

        public static int GuiGetState()
        {
            var __ret = __Internal.GuiGetState();
            return __ret;
        }

        public static void GuiSetFont(global::Raylib.Font font)
        {
            if (ReferenceEquals(font, null))
                throw new global::System.ArgumentNullException("font", "Cannot be null because it is passed by value.");
            var __arg0 = font.__Instance;
            __Internal.GuiSetFont(__arg0);
        }

        public static global::Raylib.Font GuiGetFont()
        {
            var __ret = new global::Raylib.Font.__Internal();
            __Internal.GuiGetFont(new IntPtr(&__ret));
            return global::Raylib.Font.__CreateInstance(__ret);
        }

        public static void GuiSetStyle(int control, int property, int value)
        {
            __Internal.GuiSetStyle(control, property, value);
        }

        public static int GuiGetStyle(int control, int property)
        {
            var __ret = __Internal.GuiGetStyle(control, property);
            return __ret;
        }

        public static bool GuiWindowBox(global::Raylib.Rectangle bounds, string title)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiWindowBox(__arg0, title);
            return __ret;
        }

        public static void GuiGroupBox(global::Raylib.Rectangle bounds, string text)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            __Internal.GuiGroupBox(__arg0, text);
        }

        public static void GuiLine(global::Raylib.Rectangle bounds, string text)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            __Internal.GuiLine(__arg0, text);
        }

        public static void GuiPanel(global::Raylib.Rectangle bounds)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            __Internal.GuiPanel(__arg0);
        }

        public static global::Raylib.Rectangle GuiScrollPanel(global::Raylib.Rectangle bounds, global::Raylib.Rectangle content, global::Raylib.Vector2 scroll)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            if (ReferenceEquals(content, null))
                throw new global::System.ArgumentNullException("content", "Cannot be null because it is passed by value.");
            var __arg1 = content.__Instance;
            var __arg2 = ReferenceEquals(scroll, null) ? global::System.IntPtr.Zero : scroll.__Instance;
            var __ret = new global::Raylib.Rectangle.__Internal();
            __Internal.GuiScrollPanel(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::Raylib.Rectangle.__CreateInstance(__ret);
        }

        public static void GuiLabel(global::Raylib.Rectangle bounds, string text)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            __Internal.GuiLabel(__arg0, text);
        }

        public static bool GuiButton(global::Raylib.Rectangle bounds, string text)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiButton(__arg0, text);
            return __ret;
        }

        public static bool GuiLabelButton(global::Raylib.Rectangle bounds, string text)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiLabelButton(__arg0, text);
            return __ret;
        }

        public static bool GuiImageButton(global::Raylib.Rectangle bounds, string text, global::Raylib.Texture2D texture)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg2 = texture.__Instance;
            var __ret = __Internal.GuiImageButton(__arg0, text, __arg2);
            return __ret;
        }

        public static bool GuiImageButtonEx(global::Raylib.Rectangle bounds, string text, global::Raylib.Texture2D texture, global::Raylib.Rectangle texSource)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            if (ReferenceEquals(texture, null))
                throw new global::System.ArgumentNullException("texture", "Cannot be null because it is passed by value.");
            var __arg2 = texture.__Instance;
            if (ReferenceEquals(texSource, null))
                throw new global::System.ArgumentNullException("texSource", "Cannot be null because it is passed by value.");
            var __arg3 = texSource.__Instance;
            var __ret = __Internal.GuiImageButtonEx(__arg0, text, __arg2, __arg3);
            return __ret;
        }

        public static bool GuiToggle(global::Raylib.Rectangle bounds, string text, bool active)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiToggle(__arg0, text, active);
            return __ret;
        }

        public static int GuiToggleGroup(global::Raylib.Rectangle bounds, string text, int active)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiToggleGroup(__arg0, text, active);
            return __ret;
        }

        public static bool GuiCheckBox(global::Raylib.Rectangle bounds, string text, bool @checked)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiCheckBox(__arg0, text, @checked);
            return __ret;
        }

        public static int GuiComboBox(global::Raylib.Rectangle bounds, string text, int active)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiComboBox(__arg0, text, active);
            return __ret;
        }

        public static bool GuiDropdownBox(global::Raylib.Rectangle bounds, string text, ref int active, bool editMode)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            fixed (int* __active2 = &active)
            {
                var __arg2 = __active2;
                var __ret = __Internal.GuiDropdownBox(__arg0, text, __arg2, editMode);
                return __ret;
            }
        }

        public static bool GuiSpinner(global::Raylib.Rectangle bounds, string text, ref int value, int minValue, int maxValue, bool editMode)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            fixed (int* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.GuiSpinner(__arg0, text, __arg2, minValue, maxValue, editMode);
                return __ret;
            }
        }

        public static bool GuiValueBox(global::Raylib.Rectangle bounds, string text, ref int value, int minValue, int maxValue, bool editMode)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            fixed (int* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.GuiValueBox(__arg0, text, __arg2, minValue, maxValue, editMode);
                return __ret;
            }
        }

        public static bool GuiTextBox(global::Raylib.Rectangle bounds, sbyte* text, int textSize, bool editMode)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiTextBox(__arg0, text, textSize, editMode);
            return __ret;
        }

        public static bool GuiTextBoxMulti(global::Raylib.Rectangle bounds, sbyte* text, int textSize, bool editMode)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiTextBoxMulti(__arg0, text, textSize, editMode);
            return __ret;
        }

        public static float GuiSlider(global::Raylib.Rectangle bounds, string textLeft, string textRight, float value, float minValue, float maxValue)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiSlider(__arg0, textLeft, textRight, value, minValue, maxValue);
            return __ret;
        }

        public static float GuiSliderBar(global::Raylib.Rectangle bounds, string textLeft, string textRight, float value, float minValue, float maxValue)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiSliderBar(__arg0, textLeft, textRight, value, minValue, maxValue);
            return __ret;
        }

        public static float GuiProgressBar(global::Raylib.Rectangle bounds, string textLeft, string textRight, float value, float minValue, float maxValue)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiProgressBar(__arg0, textLeft, textRight, value, minValue, maxValue);
            return __ret;
        }

        public static void GuiStatusBar(global::Raylib.Rectangle bounds, string text)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            __Internal.GuiStatusBar(__arg0, text);
        }

        public static void GuiDummyRec(global::Raylib.Rectangle bounds, string text)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            __Internal.GuiDummyRec(__arg0, text);
        }

        public static int GuiScrollBar(global::Raylib.Rectangle bounds, int value, int minValue, int maxValue)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiScrollBar(__arg0, value, minValue, maxValue);
            return __ret;
        }

        public static global::Raylib.Vector2 GuiGrid(global::Raylib.Rectangle bounds, float spacing, int subdivs)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiGrid(__arg0, spacing, subdivs);
            return global::Raylib.Vector2.__CreateInstance(__ret);
        }

        public static int GuiListView(global::Raylib.Rectangle bounds, string text, ref int scrollIndex, int active)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            fixed (int* __scrollIndex2 = &scrollIndex)
            {
                var __arg2 = __scrollIndex2;
                var __ret = __Internal.GuiListView(__arg0, text, __arg2, active);
                return __ret;
            }
        }

        public static int GuiListViewEx(global::Raylib.Rectangle bounds, sbyte** text, int count, ref int focus, ref int scrollIndex, int active)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            fixed (int* __focus3 = &focus)
            {
                var __arg3 = __focus3;
                fixed (int* __scrollIndex4 = &scrollIndex)
                {
                    var __arg4 = __scrollIndex4;
                    var __ret = __Internal.GuiListViewEx(__arg0, text, count, __arg3, __arg4, active);
                    return __ret;
                }
            }
        }

        public static int GuiMessageBox(global::Raylib.Rectangle bounds, string title, string message, string buttons)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiMessageBox(__arg0, title, message, buttons);
            return __ret;
        }

        public static int GuiTextInputBox(global::Raylib.Rectangle bounds, string title, string message, string buttons, sbyte* text)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiTextInputBox(__arg0, title, message, buttons, text);
            return __ret;
        }

        public static global::Raylib.Color GuiColorPicker(global::Raylib.Rectangle bounds, global::Raylib.Color color)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            var __ret = __Internal.GuiColorPicker(__arg0, *(global::Raylib.Color.__Internal*) __arg1);
            return global::Raylib.Color.__CreateInstance(__ret);
        }

        public static void GuiLoadStyle(string fileName)
        {
            __Internal.GuiLoadStyle(fileName);
        }

        public static void GuiLoadStyleDefault()
        {
            __Internal.GuiLoadStyleDefault();
        }

        public static string GuiIconText(int iconId, string text)
        {
            var __ret = __Internal.GuiIconText(iconId, text);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public static global::Raylib.Vector3 ConvertHSVtoRGB(global::Raylib.Vector3 hsv)
        {
            if (ReferenceEquals(hsv, null))
                throw new global::System.ArgumentNullException("hsv", "Cannot be null because it is passed by value.");
            var __arg0 = hsv.__Instance;
            var __ret = new global::Raylib.Vector3.__Internal();
            __Internal.ConvertHSVtoRGB(new IntPtr(&__ret), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public static global::Raylib.Vector3 ConvertRGBtoHSV(global::Raylib.Vector3 rgb)
        {
            if (ReferenceEquals(rgb, null))
                throw new global::System.ArgumentNullException("rgb", "Cannot be null because it is passed by value.");
            var __arg0 = rgb.__Instance;
            var __ret = new global::Raylib.Vector3.__Internal();
            __Internal.ConvertRGBtoHSV(new IntPtr(&__ret), __arg0);
            return global::Raylib.Vector3.__CreateInstance(__ret);
        }

        public static int GetTextWidth(string text)
        {
            var __ret = __Internal.GetTextWidth(text);
            return __ret;
        }

        public static global::Raylib.Rectangle GetTextBounds(int control, global::Raylib.Rectangle bounds)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg1 = bounds.__Instance;
            var __ret = new global::Raylib.Rectangle.__Internal();
            __Internal.GetTextBounds(new IntPtr(&__ret), control, __arg1);
            return global::Raylib.Rectangle.__CreateInstance(__ret);
        }

        public static string GetTextIcon(string text, ref int iconId)
        {
            fixed (int* __iconId1 = &iconId)
            {
                var __arg1 = __iconId1;
                var __ret = __Internal.GetTextIcon(text, __arg1);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        public static void GuiDrawText(string text, global::Raylib.Rectangle bounds, int alignment, global::Raylib.Color tint)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg1 = bounds.__Instance;
            if (ReferenceEquals(tint, null))
                throw new global::System.ArgumentNullException("tint", "Cannot be null because it is passed by value.");
            var __arg3 = tint.__Instance;
            __Internal.GuiDrawText(text, __arg1, alignment, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static sbyte** GuiTextSplit(string text, ref int count, ref int textRow)
        {
            fixed (int* __count1 = &count)
            {
                var __arg1 = __count1;
                fixed (int* __textRow2 = &textRow)
                {
                    var __arg2 = __textRow2;
                    var __ret = __Internal.GuiTextSplit(text, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        public static float GuiSliderPro(global::Raylib.Rectangle bounds, string textLeft, string textRight, float value, float minValue, float maxValue, int sliderWidth)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiSliderPro(__arg0, textLeft, textRight, value, minValue, maxValue, sliderWidth);
            return __ret;
        }

        public static global::Raylib.Color GuiColorPanelEx(global::Raylib.Rectangle bounds, global::Raylib.Color color, float hue)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            var __ret = __Internal.GuiColorPanelEx(__arg0, *(global::Raylib.Color.__Internal*) __arg1, hue);
            return global::Raylib.Color.__CreateInstance(__ret);
        }

        public static global::Raylib.Color GuiColorPanel(global::Raylib.Rectangle bounds, global::Raylib.Color color)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            var __ret = __Internal.GuiColorPanel(__arg0, *(global::Raylib.Color.__Internal*) __arg1);
            return global::Raylib.Color.__CreateInstance(__ret);
        }

        public static float GuiColorBarAlpha(global::Raylib.Rectangle bounds, float alpha)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiColorBarAlpha(__arg0, alpha);
            return __ret;
        }

        public static float GuiColorBarHue(global::Raylib.Rectangle bounds, float hue)
        {
            if (ReferenceEquals(bounds, null))
                throw new global::System.ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
            var __arg0 = bounds.__Instance;
            var __ret = __Internal.GuiColorBarHue(__arg0, hue);
            return __ret;
        }

        public static global::Raylib.GuiControlState GuiState
        {
            get
            {
                var __ptr = (global::Raylib.GuiControlState*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiState");
                return *__ptr;
            }

            set
            {
                var __ptr = (global::Raylib.GuiControlState*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiState");
                *__ptr = value;
            }
        }

        public static global::Raylib.Font GuiFont
        {
            get
            {
                var __ptr = (global::Raylib.Font.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiFont");
                return global::Raylib.Font.__CreateInstance(*__ptr);
            }

            set
            {
                var __ptr = (global::Raylib.Font.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiFont");
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                *__ptr = *(global::Raylib.Font.__Internal*) value.__Instance;
            }
        }

        public static bool GuiLocked
        {
            get
            {
                var __ptr = (bool*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiLocked");
                return *__ptr;
            }

            set
            {
                var __ptr = (bool*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiLocked");
                *__ptr = value;
            }
        }

        public static float GuiAlpha
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiAlpha");
                return *__ptr;
            }

            set
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiAlpha");
                *__ptr = value;
            }
        }

        public static uint[] GuiStyle
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiStyle");
                uint[] __value = null;
                if (__ptr != null)
                {
                    __value = new uint[384];
                    for (int i = 0; i < 384; i++)
                        __value[i] = __ptr[i];
                }
                return __value;
            }
        }

        public static bool GuiStyleLoaded
        {
            get
            {
                var __ptr = (bool*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiStyleLoaded");
                return *__ptr;
            }

            set
            {
                var __ptr = (bool*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiStyleLoaded");
                *__ptr = value;
            }
        }
    }

    public enum GuiIconName
    {
        RICON_NONE = 0,
        RICON_FOLDER_FILE_OPEN = 1,
        RICON_FILE_SAVE_CLASSIC = 2,
        RICON_FOLDER_OPEN = 3,
        RICON_FOLDER_SAVE = 4,
        RICON_FILE_OPEN = 5,
        RICON_FILE_SAVE = 6,
        RICON_FILE_EXPORT = 7,
        RICON_FILE_NEW = 8,
        RICON_FILE_DELETE = 9,
        RICON_FILETYPE_TEXT = 10,
        RICON_FILETYPE_AUDIO = 11,
        RICON_FILETYPE_IMAGE = 12,
        RICON_FILETYPE_PLAY = 13,
        RICON_FILETYPE_VIDEO = 14,
        RICON_FILETYPE_INFO = 15,
        RICON_FILE_COPY = 16,
        RICON_FILE_CUT = 17,
        RICON_FILE_PASTE = 18,
        RICON_CURSOR_HAND = 19,
        RICON_CURSOR_POINTER = 20,
        RICON_CURSOR_CLASSIC = 21,
        RICON_PENCIL = 22,
        RICON_PENCIL_BIG = 23,
        RICON_BRUSH_CLASSIC = 24,
        RICON_BRUSH_PAINTER = 25,
        RICON_WATER_DROP = 26,
        RICON_COLOR_PICKER = 27,
        RICON_RUBBER = 28,
        RICON_COLOR_BUCKET = 29,
        RICON_TEXT_T = 30,
        RICON_TEXT_A = 31,
        RICON_SCALE = 32,
        RICON_RESIZE = 33,
        RICON_FILTER_POINT = 34,
        RICON_FILTER_BILINEAR = 35,
        RICON_CROP = 36,
        RICON_CROP_ALPHA = 37,
        RICON_SQUARE_TOGGLE = 38,
        RICON_SIMMETRY = 39,
        RICON_SIMMETRY_HORIZONTAL = 40,
        RICON_SIMMETRY_VERTICAL = 41,
        RICON_LENS = 42,
        RICON_LENS_BIG = 43,
        RICON_EYE_ON = 44,
        RICON_EYE_OFF = 45,
        RICON_FILTER_TOP = 46,
        RICON_FILTER = 47,
        RICON_TARGET_POINT = 48,
        RICON_TARGET_SMALL = 49,
        RICON_TARGET_BIG = 50,
        RICON_TARGET_MOVE = 51,
        RICON_CURSOR_MOVE = 52,
        RICON_CURSOR_SCALE = 53,
        RICON_CURSOR_SCALE_RIGHT = 54,
        RICON_CURSOR_SCALE_LEFT = 55,
        RICON_UNDO = 56,
        RICON_REDO = 57,
        RICON_REREDO = 58,
        RICON_MUTATE = 59,
        RICON_ROTATE = 60,
        RICON_REPEAT = 61,
        RICON_SHUFFLE = 62,
        RICON_EMPTYBOX = 63,
        RICON_TARGET = 64,
        RICON_TARGET_SMALL_FILL = 65,
        RICON_TARGET_BIG_FILL = 66,
        RICON_TARGET_MOVE_FILL = 67,
        RICON_CURSOR_MOVE_FILL = 68,
        RICON_CURSOR_SCALE_FILL = 69,
        RICON_CURSOR_SCALE_RIGHT_FILL = 70,
        RICON_CURSOR_SCALE_LEFT_FILL = 71,
        RICON_UNDO_FILL = 72,
        RICON_REDO_FILL = 73,
        RICON_REREDO_FILL = 74,
        RICON_MUTATE_FILL = 75,
        RICON_ROTATE_FILL = 76,
        RICON_REPEAT_FILL = 77,
        RICON_SHUFFLE_FILL = 78,
        RICON_EMPTYBOX_SMALL = 79,
        RICON_BOX = 80,
        RICON_BOX_TOP = 81,
        RICON_BOX_TOP_RIGHT = 82,
        RICON_BOX_RIGHT = 83,
        RICON_BOX_BOTTOM_RIGHT = 84,
        RICON_BOX_BOTTOM = 85,
        RICON_BOX_BOTTOM_LEFT = 86,
        RICON_BOX_LEFT = 87,
        RICON_BOX_TOP_LEFT = 88,
        RICON_BOX_CENTER = 89,
        RICON_BOX_CIRCLE_MASK = 90,
        RICON_POT = 91,
        RICON_ALPHA_MULTIPLY = 92,
        RICON_ALPHA_CLEAR = 93,
        RICON_DITHERING = 94,
        RICON_MIPMAPS = 95,
        RICON_BOX_GRID = 96,
        RICON_GRID = 97,
        RICON_BOX_CORNERS_SMALL = 98,
        RICON_BOX_CORNERS_BIG = 99,
        RICON_FOUR_BOXES = 100,
        RICON_GRID_FILL = 101,
        RICON_BOX_MULTISIZE = 102,
        RICON_ZOOM_SMALL = 103,
        RICON_ZOOM_MEDIUM = 104,
        RICON_ZOOM_BIG = 105,
        RICON_ZOOM_ALL = 106,
        RICON_ZOOM_CENTER = 107,
        RICON_BOX_DOTS_SMALL = 108,
        RICON_BOX_DOTS_BIG = 109,
        RICON_BOX_CONCENTRIC = 110,
        RICON_BOX_GRID_BIG = 111,
        RICON_OK_TICK = 112,
        RICON_CROSS = 113,
        RICON_ARROW_LEFT = 114,
        RICON_ARROW_RIGHT = 115,
        RICON_ARROW_BOTTOM = 116,
        RICON_ARROW_TOP = 117,
        RICON_ARROW_LEFT_FILL = 118,
        RICON_ARROW_RIGHT_FILL = 119,
        RICON_ARROW_BOTTOM_FILL = 120,
        RICON_ARROW_TOP_FILL = 121,
        RICON_AUDIO = 122,
        RICON_FX = 123,
        RICON_WAVE = 124,
        RICON_WAVE_SINUS = 125,
        RICON_WAVE_SQUARE = 126,
        RICON_WAVE_TRIANGULAR = 127,
        RICON_CROSS_SMALL = 128,
        RICON_PLAYER_PREVIOUS = 129,
        RICON_PLAYER_PLAY_BACK = 130,
        RICON_PLAYER_PLAY = 131,
        RICON_PLAYER_PAUSE = 132,
        RICON_PLAYER_STOP = 133,
        RICON_PLAYER_NEXT = 134,
        RICON_PLAYER_RECORD = 135,
        RICON_MAGNET = 136,
        RICON_LOCK_CLOSE = 137,
        RICON_LOCK_OPEN = 138,
        RICON_CLOCK = 139,
        RICON_TOOLS = 140,
        RICON_GEAR = 141,
        RICON_GEAR_BIG = 142,
        RICON_BIN = 143,
        RICON_HAND_POINTER = 144,
        RICON_LASER = 145,
        RICON_COIN = 146,
        RICON_EXPLOSION = 147,
        RICON_1UP = 148,
        RICON_PLAYER = 149,
        RICON_PLAYER_JUMP = 150,
        RICON_KEY = 151,
        RICON_DEMON = 152,
        RICON_TEXT_POPUP = 153,
        RICON_GEAR_EX = 154,
        RICON_CRACK = 155,
        RICON_CRACK_POINTS = 156,
        RICON_STAR = 157,
        RICON_DOOR = 158,
        RICON_EXIT = 159,
        RICON_MODE_2D = 160,
        RICON_MODE_3D = 161,
        RICON_CUBE = 162,
        RICON_CUBE_FACE_TOP = 163,
        RICON_CUBE_FACE_LEFT = 164,
        RICON_CUBE_FACE_FRONT = 165,
        RICON_CUBE_FACE_BOTTOM = 166,
        RICON_CUBE_FACE_RIGHT = 167,
        RICON_CUBE_FACE_BACK = 168,
        RICON_CAMERA = 169,
        RICON_SPECIAL = 170,
        RICON_LINK_NET = 171,
        RICON_LINK_BOXES = 172,
        RICON_LINK_MULTI = 173,
        RICON_LINK = 174,
        RICON_LINK_BROKE = 175,
        RICON_TEXT_NOTES = 176,
        RICON_NOTEBOOK = 177,
        RICON_SUITCASE = 178,
        RICON_SUITCASE_ZIP = 179,
        RICON_MAILBOX = 180,
        RICON_MONITOR = 181,
        RICON_PRINTER = 182,
        RICON_PHOTO_CAMERA = 183,
        RICON_PHOTO_CAMERA_FLASH = 184,
        RICON_HOUSE = 185,
        RICON_HEART = 186,
        RICON_CORNER = 187,
        RICON_VERTICAL_BARS = 188,
        RICON_VERTICAL_BARS_FILL = 189,
        RICON_LIFE_BARS = 190,
        RICON_INFO = 191,
        RICON_CROSSLINE = 192,
        RICON_HELP = 193,
        RICON_FILETYPE_ALPHA = 194,
        RICON_FILETYPE_HOME = 195,
        RICON_LAYERS_VISIBLE = 196,
        RICON_LAYERS = 197,
        RICON_WINDOW = 198,
        RICON_HIDPI = 199,
        RICON_200 = 200,
        RICON_201 = 201,
        RICON_202 = 202,
        RICON_203 = 203,
        RICON_204 = 204,
        RICON_205 = 205,
        RICON_206 = 206,
        RICON_207 = 207,
        RICON_208 = 208,
        RICON_209 = 209,
        RICON_210 = 210,
        RICON_211 = 211,
        RICON_212 = 212,
        RICON_213 = 213,
        RICON_214 = 214,
        RICON_215 = 215,
        RICON_216 = 216,
        RICON_217 = 217,
        RICON_218 = 218,
        RICON_219 = 219,
        RICON_220 = 220,
        RICON_221 = 221,
        RICON_222 = 222,
        RICON_223 = 223,
        RICON_224 = 224,
        RICON_225 = 225,
        RICON_226 = 226,
        RICON_227 = 227,
        RICON_228 = 228,
        RICON_229 = 229,
        RICON_230 = 230,
        RICON_231 = 231,
        RICON_232 = 232,
        RICON_233 = 233,
        RICON_234 = 234,
        RICON_235 = 235,
        RICON_236 = 236,
        RICON_237 = 237,
        RICON_238 = 238,
        RICON_239 = 239,
        RICON_240 = 240,
        RICON_241 = 241,
        RICON_242 = 242,
        RICON_243 = 243,
        RICON_244 = 244,
        RICON_245 = 245,
        RICON_246 = 246,
        RICON_247 = 247,
        RICON_248 = 248,
        RICON_249 = 249,
        RICON_250 = 250,
        RICON_251 = 251,
        RICON_252 = 252,
        RICON_253 = 253,
        RICON_254 = 254,
        RICON_255 = 255
    }

    public unsafe partial class ricons
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiDrawIcon@@YAXHUVector2@@HUColor@@@Z")]
            internal static extern void GuiDrawIcon(int iconId, global::Raylib.Vector2.__Internal position, int pixelSize, global::Raylib.Color.__Internal color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiGetIcons@@YAPEAIXZ")]
            internal static extern uint* GuiGetIcons();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiGetIconData@@YAPEAIH@Z")]
            internal static extern uint* GuiGetIconData(int iconId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiSetIconData@@YAXHPEAI@Z")]
            internal static extern void GuiSetIconData(int iconId, uint* data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiSetIconPixel@@YAXHHH@Z")]
            internal static extern void GuiSetIconPixel(int iconId, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiClearIconPixel@@YAXHHH@Z")]
            internal static extern void GuiClearIconPixel(int iconId, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiCheckIconPixel@@YA_NHHH@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GuiCheckIconPixel(int iconId, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("raylib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GuiLoadIcons@@YAPEAPEADPEBD_N@Z")]
            internal static extern sbyte** GuiLoadIcons([MarshalAs(UnmanagedType.LPStr)] string fileName, bool loadIconsName);
        }

        public static void GuiDrawIcon(int iconId, global::Raylib.Vector2 position, int pixelSize, global::Raylib.Color color)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is passed by value.");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.GuiDrawIcon(iconId, *(global::Raylib.Vector2.__Internal*) __arg1, pixelSize, *(global::Raylib.Color.__Internal*) __arg3);
        }

        public static uint* GuiGetIcons()
        {
            var __ret = __Internal.GuiGetIcons();
            return __ret;
        }

        public static uint* GuiGetIconData(int iconId)
        {
            var __ret = __Internal.GuiGetIconData(iconId);
            return __ret;
        }

        public static void GuiSetIconData(int iconId, ref uint data)
        {
            fixed (uint* __data1 = &data)
            {
                var __arg1 = __data1;
                __Internal.GuiSetIconData(iconId, __arg1);
            }
        }

        public static void GuiSetIconPixel(int iconId, int x, int y)
        {
            __Internal.GuiSetIconPixel(iconId, x, y);
        }

        public static void GuiClearIconPixel(int iconId, int x, int y)
        {
            __Internal.GuiClearIconPixel(iconId, x, y);
        }

        public static bool GuiCheckIconPixel(int iconId, int x, int y)
        {
            var __ret = __Internal.GuiCheckIconPixel(iconId, x, y);
            return __ret;
        }

        public static sbyte** GuiLoadIcons(string fileName, bool loadIconsName)
        {
            var __ret = __Internal.GuiLoadIcons(fileName, loadIconsName);
            return __ret;
        }

        public static uint[] GuiIcons
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("raylib", "guiIcons");
                uint[] __value = null;
                if (__ptr != null)
                {
                    __value = new uint[2048];
                    for (int i = 0; i < 2048; i++)
                        __value[i] = __ptr[i];
                }
                return __value;
            }
        }
    }
}
